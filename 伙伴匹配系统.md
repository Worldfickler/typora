# 伙伴匹配系统

## 需求分析

1. 用户去添加标签，标签的分类（要有哪些标签、怎么把标签进行分类）
2. 主动搜索：允许用户根据标签去搜索其他用户（Redis 缓存）
3. 组队
   1. 创建队伍
   2. 加入队伍
   3. 根据标签查询队伍
   4. 邀请其他人
4. 允许用户去修改标签
5. 推荐（相似度计算算法 + 本地分布式计算）

## 技术栈

前端：

	1. Vue3 开发框架（提高页面开发的效率）
	1. Vant UI（基于 Vue 的移动端组件库）（React 版 Zent）
	1. Vite（打包工具，快！）
	1. Nginx 来单机部署

后端：

	1. Java + SpringBoot
	1. SpringMVC + MyBatis + MyBatis-Plus
	1. MySQL 数据库
	1. Redis 缓存
	1. Swagger + Knife4j 接口文档

## 前端初始化

### 一、前端项目初始化

> 用脚手架初始化项目
>
> - Vue CLI
> - Vite 脚手架

#### 1. 使用脚手架初始化项目

1. 先看一下 Vite 的官网

![image-20230330085150712](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230330085150712.png)

2. 搭建第一个 Vite 项目

![image-20230330085245637](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230330085245637.png)

3. 新建一个文件夹，进入后调出 cmd

![image-20230330085501597](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230330085501597.png)

4. 使用 npm 命令初始化项目

初始化时要输入项目名（matchup-frontend）、选择脚手架的类型（vue）、前端的类型（TS），都选择好项目就初始化完成了，这个速度还是很快的，比起 Ant Design Pro 块了不止一倍...

![image-20230330090248006](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230330090248006.png)

![image-20230330090509447](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230330090509447.png)

5. 在 webstorm 中打开项目

![image-20230330090613334](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230330090613334.png)

#### 2. 解读一下 `package.json` 中的命令

| package.json                                                 | 是前端项目包管理器的一个依赖文件，在这里，你可以配置项目需要执行的脚本 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20230330091419913](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230330091419913.png) | dev 在本地开发环境去启动一个可以实时更新的项目               |
| ![image-20230330091433593](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230330091433593.png) | build 就是对项目进行打包，这个 build 命令相当于先执行了 vue-tsc 将 type script 转换成 javascript 然后再执行 vite build |
| ![image-20230330091453997](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230330091453997.png) | 其实这个 script 后面的内容你可以随便写，然后随便改成自己的命令 |
| ![image-20230330091506371](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230330091506371.png) | preview 可以让你在本地去运行一个预发布环境，提前去浏览这个项目正式上线前是什么样子和 dev 还是有区别的，这个更倾向于线上，它的项目体积可能会更小，删掉一些无用的东西之类的 |
| ![image-20230330091521501](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230330091521501.png)![image-20230330091534824](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230330091534824.png) | vitejs/plugin-vue 默认安装 vitejs/plugin-vue，vite 是一个构建工具，vite 不需要 vue 和 react 的绑定，这里除了安装 vite 还安装 plugin-vue，这就是一个非常好的设计，它的构建工具是独立于任何的框架，针对每个框架去提供了一个额外的适配，通过一个插件化的方式，然后可以让整个框架，让整个 vite 构建工具的通用性变的更强 |
| ![image-20230330093835921](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230330093835921.png) | 这些东西都是放在 devDependencies，就是说这个项目上线的时候，这些依赖就用不到了，这些依赖只在我们开发阶段要把项目打包成包的时候需要用到 |

#### 3. 下载依赖，启动项目

1. `npm install` 下载安装依赖

![image-20230330094323164](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230330094323164.png)

依赖安装好后，会多出一个 `node_modules` 文件，这个是整个项目依赖的一些包

2. 启动项目

![image-20230330094430042](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230330094430042.png)

启动成功

![image-20230330094443409](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230330094443409.png)

访问一下页面

![image-20230330094513520](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230330094513520.png)

#### 4. 整合组件库

1. 官方文档的介绍

![image-20230330095112026](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230330095112026.png)

2. 按需引入

```shell
npm i unplugin-vue-components -D
```

> 按需引入的一个好处，这个这个组件库有很多组件，但是大部分我们并用不到，就没必要把它们全都引入到项目中，只需要按需引入就可以了，这样就精简了项目的体积

3. 在终端中输入对应的命令

![image-20230331081810865](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331081810865.png)

4. 配置插件

1. 安装成功后，去根据官方文档配置一下插件

![image-20230331081952085](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331081952085.png)

```tsx
import vue from '@vitejs/plugin-vue';
import Components from 'unplugin-vue-components/vite';
import { VantResolver } from 'unplugin-vue-components/resolvers';

export default {
  plugins: [
    vue(),
    Components({
      resolvers: [VantResolver()],
    }),
  ],
};

```

2. 找到 `vite.config.js` 文件，把代码复制进去

![image-20230331082447260](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331082447260.png)

3. 先安装 vant

![image-20230331082551827](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331082551827.png)

```shell
npm i vant
```

![image-20230331082801182](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331082801182.png)

4. 根据文档提示，引入组件

![image-20230331082842248](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331082842248.png)

```tsx
import { createApp } from 'vue';
// 1. 引入你需要的组件
import { Button } from 'vant';
// 2. 引入组件样式
import 'vant/lib/index.css';

const app = createApp();

// 3. 注册你需要的组件
app.use(Button);
```

5. 我们找到 vue 的主文件（主页面入口），找到 `main.ts`

> `main.ts` 就是前端项目的入口。看他做了什么事情，从 vue 中引入一个 createApp 来创建一个 App 的组件，然后用 mount 将 vue 的页面和我们的 domin 元素关联起来。
>
> 这个 mount 我们将它叫做挂载，就是把一个组件页面挂载到某个页面上，可以理解为：你有一面墙（墙=html），还有一个墙贴（墙贴=app.vue），我们要把**墙贴**贴到**墙**上的某个部分，`index.html`这里有个 id 的 app，然后就和这个关联到了，#app 这个井号就是来指定 ID 的。

![image-20230331083255672](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331083255672.png)

![image-20230331083428623](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331083428623.png)

6. 将刚刚的组件配置文件复制到 `main.ts` 文件中

![image-20230331083756090](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331083756090.png)

#### 5. 测试一下 vant 语法

1. 选择一个 Button 基础组件，复制一下

![image-20230331083914706](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331083914706.png)

```vue
<van-button type="primary">主要按钮</van-button>
<van-button type="success">成功按钮</van-button>
<van-button type="default">默认按钮</van-button>
<van-button type="warning">警告按钮</van-button>
<van-button type="danger">危险按钮</van-button>
```

2. 粘贴到 `App.vue` 中

![image-20230331084235362](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331084235362.png)

3. 再次启动项目，访问一下

![image-20230331084211454](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331084211454.png)

### 二、前端主页 + 组件概览

F12 或者鼠标右键检查，这里可以参考手机和 ipad 适应布局显示，去想象对应页面相应的修改和调整

![image-20230331084520590](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331084520590.png)

![image-20230331084550226](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331084550226.png)

#### 1. 需要做的设计

导航条：展示当前页面名称

主页搜索框 => 搜索页 => 搜索结果页（标签筛选页）

内容：

- 主页（推广页 + 广告）ps：如果你要做商业性的网页，一定要考虑清楚，广告的位置
  - 搜索框
  - banner
  - 最简信息流
- 队伍页
- 用户页（消息 - 暂时考虑发邮件）

#### 2. 前端开发

1. 精简一下老页面

![image-20230331085031520](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331085031520.png)

2. `HelloWorld.vue` 组件

`HelloWorld.vue` 组件的目的是给不是很熟悉 vue 语法的用户提供一个参考

![image-20230331085159045](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331085159045.png)

3. 新建一个目录

在 `src` 目录下面新建一个 `layouts` 目录

很多页面要复用组件 / 样式，重复写很麻烦、不利于维护，所以抽象一个通用的布局（Layout）**一个很重要的设计**

在 `layouts` 目录下新建一个 `BasicLayout.vue`（基础的布局）

![image-20230331085540375](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331085540375.png)

在 `BasicLayout.vue` 写下一些所有页面都要用到的东西

4. 去文档找一下导航条的样式

![image-20230331085822043](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331085822043.png)

![image-20230331085840096](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331085840096.png)

```vue
<van-nav-bar
  title="标题"
  left-text="返回"
  right-text="按钮"
  left-arrow
  @click-left="onClickLeft"
  @click-right="onClickRight"
/>

import { showToast } from 'vant';

export default {
  setup() {
    const onClickLeft = () => history.back();
    const onClickRight = () => showToast('按钮');
    return {
      onClickLeft,
      onClickRight,
    };
  },
};

<van-nav-bar title="标题" left-text="返回" left-arrow>
  <template #right>
    <van-icon name="search" size="18" />
  </template>
</van-nav-bar>
```

5. 在使用之前还要引入导航栏（NavBar）和图标（Icon），不然 vant 不认识它，在 `mian` 引入它

![image-20230331090202797](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331090202797.png)

6. 将上面的导航栏代码粘贴到 `BasicLayout.vue` 并修改一下，到 `App.vue` 引入一下

![image-20230331092444036](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331092444036.png)

![image-20230331091924717](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331091924717.png)

7. 查看一下页面

点击返回时左，点击按钮是右

![image-20230331093234577](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331093234577.png)

![image-20230331093238280](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331093238280.png)

8. 如法炮制，再引入底部的 tabbar，选个功能多一点的

![image-20230331093421995](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331093421995.png)

```vue
<van-tabbar v-model="active" @change="onChange">
  <van-tabbar-item icon="home-o">标签 1</van-tabbar-item>
  <van-tabbar-item icon="search">标签 2</van-tabbar-item>
  <van-tabbar-item icon="friends-o">标签 3</van-tabbar-item>
  <van-tabbar-item icon="setting-o">标签 4</van-tabbar-item>
</van-tabbar>
```

```tsx
import { ref } from 'vue';
import { showToast } from 'vant';

export default {
  setup() {
    const active = ref(0);
    const onChange = (index) => showToast(`标签 ${index}`);
    return {
      icon,
      onChange,
    };
  },
};
```

```tsx
app.use(Tabbar)
app.use(TabbarItem)
```

![image-20230331093601551](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331093601551.png)

![image-20230331094017762](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331094017762.png)

9. 刷新一下页面

![image-20230331094100497](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331094100497.png)

10. 但是鼠标放在下面的图标上一个都没有亮

> 这里我们给 tabbar 标签栏组件中指定了一个 active，这个 active 就是用来表示当前应该高亮哪个 tab，当前用户的位置属于哪个 tab 下。

![image-20230331094322493](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331094322493.png)

这个 active 默认值是 0，改为 index（主页的 name 属性，或者说主页的名字），没有点击主页，主页的图标就高亮了

![image-20230331094545971](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331094545971.png)

> 其实就是通过这个 active 去关联了每个标签上的内容，当你点击某个 tab 时，就会触发切换事件，并且更改这个 active 当前激活的 tab 值。

这里使用了 change 事件，就是当用户切换这个 tab 栏时，会触发 Toast（也是 vant 的组件），触发一个比较轻量的提示

![image-20230331101948837](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331101948837.png)

11. 分别点击三个图标

![image-20230331102011947](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331102011947.png)

![image-20230331102020718](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331102020718.png)

![image-20230331102029330](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331102029330.png)

12. 现在给中间添加一些内容

![image-20230331102207666](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331102207666.png)

![image-20230331102322711](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331102322711.png)

13. 再去创建一个页面，在 src 目录下新建 pages 目录

![image-20230331102417146](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331102417146.png)

14. 然后在 pages 目录下新建两个页面 `Index.vue` 和 `Team.vue`

![image-20230331102526754](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331102526754.png)

15. 当我们点击这个 tab 栏时，然后就去加载对应的页面

![image-20230331103034743](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331103034743.png)

![image-20230331103530916](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331103530916.png)

## 数据库表设计

> 标签的分类（要有哪些标签，怎么把标签进行分类）

### 一、新增标签表（分类表）

> 建议用标签，不要用分类，更灵活

#### 1. 想一想，需要哪些标签分类？

1. 性别：男、女
2. 方向：Java、C++、Py、Go、前端
3. 正在学：Spring
4. 目标：考研、春招、秋招、校招、社招、考公、竞赛（蓝桥杯）、转行、跳槽
5. 段位：初级、中级、高级、王者
6. 身份：小学、初中、高中、大一、大二、大三、大四、学生、待业、已就业、研一、研二、研三
7. 状态：乐观、有点丧、一般、单身、已婚、有对象

或者：【用户自己定义标签】

#### 2. 表设计

| 标签表（分类表） |                                                              |                                   |
| ---------------- | ------------------------------------------------------------ | --------------------------------- |
| 字段             | 说明                                                         | 类型                              |
| id               | 主键                                                         | bigint                            |
| tagName          | 标签名（非空；必须唯一、唯一索引）                           | varchar                           |
| userId           | 上传标签的用户（如果要根据 userId 查已上传标签的话，最好加上，普通索引） | bigint                            |
| parentId         | 父标签id（分类）                                             | bigint                            |
| isParent         | 是否为父标签                                                 | tingint（0-不是父标签、1-父标签） |
| createTime       | 创建时间                                                     | datetime                          |
| updateTime       | 更新时间                                                     | dateTime                          |
| isDelete         | 是否删除（逻辑删除）                                         | tinyint（0、1）                   |

> 怎么查询所有标签，并且把标签分好组？按父标签 id 分组，能实现 √
>
> 根据父标签查询子标签？根据 id 查询，能实现 √

> **小知识**
>
> SQL 语言分类：
>
> 1. DDL define 建表、操作表
> 2. DML manage 更新删除数据，影响实际表里的内容
> 3. DCL control 控制、权限
> 4. DQL query 查询，select
>
> 附加：[DQL、DML、DDL、DCL的概念与区别 - 范兵 - 博客园 (cnblogs.com)](https://www.cnblogs.com/fan-yuan/p/7879353.html)

在数据库中建立 tag 表

```mysql
-- auto-generated definition
create table tag
(
    id           bigint auto_increment comment 'id' primary key,
    tagName      varchar(256)                       null comment '标签名称',
    userId       bigint                             null comment '用户 id',
    parentId     bigint                             null comment '父标签 id',
    isParent     tinyint                            null comment '0-不是, 1-父标签',
    creatTime    datetime default CURRENT_TIMESTAMP null comment '创建时间',
    updateTime   datetime default CURRENT_TIMESTAMP null on update CURRENT_TIMESTAMP comment '更新时间',
    isDelete     tinyint  default 0                 not null comment '是否删除'
)
    comment '标签表' auto_increment = 8;
```

![image-20230331110628133](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331110628133.png)

### 二、修改用户表

> 修改用户表，就要知道用户有哪些标签

**方式一：**

直接在用户表补充 tags 字段，[ ‘Java’, ‘男’ ] 存 json 字符串

**优点**：查询方便、不用新建关联表，标签是用户的固有属性

（除了该系统、其他系统可能要用到，标签是用户的固有属性）节省开发成本

**应用场景**：查询用户列表，查关系表拿到这 100 个用户的所有标签 id，再根据标签 id 去查标签表

**缺点**：用户表多一列，会降低性能



**方式二：**

加一个关联表，记录用户和标签的关系

**关联表的应用场景**：查询灵活，可以正查反查

**缺点**：要多建一个表、多维护一个表

**重点**：企业大项目开发中尽量减少关联查询，很难影响扩展性，而且会影响查询性能



我们采用第一种方法

```mysql
alter table user add COLUMN tags varchar(1024) null comment '标签列表';
```

![image-20230331115052790](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331115052790.png)

之后可能要经常通过这个标签名去搜索，给标签名加上一个唯一索引，上传标签的用户加上普通索引

![image-20230331115504918](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331115504918.png)

![image-20230331115643814](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331115643814.png)

可以看到多了两个索引

![image-20230331115724461](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331115724461.png)

将刚刚写的添加字段和新建 tag 表语句，添加到 `create_table.sql` 中

![image-20230331223622883](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230331223622883.png)

## 开发后端

### 一、开发后端接口设计

**搜索标签的两种方式**

#### 1. SQL 查询

> 实现简单，可以通过拆分查询进一步优化

1. 允许用户传入多个标签，多个标签都存在才搜索的出来 and。like ‘%Java%’ and like ‘%C++%’ 。
2. 允许用户传入多个标签，有任何一个标签存在就能搜索出来 or。like ‘%Java%’ or like ‘%C++%’ 。

#### 2. 内存查询

（灵活，可以通过并发进一步优化）

**思路**：

- 如果参数可以分析，根据用户的参数去选择查询方式，比如标签数
- 如果参数不可以分析，并且数据库连接足够、内存空间足够，可以并发同时查询，谁先返回用谁
- 还可以 SQL 查询与内存计算相结合，比如先用 SQL 过掉部分 tag

### 二、初始化后端

> 用户中心来集中提供用户的检索、操作、注册、登录、鉴权

#### 1. 编写用户标签搜索方法

1. 我们已经有了一个用户中心，直接在用户中心的基础上写

![image-20230401132125845](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401132125845.png)

2. 在 UserServiceImpl 中写下搜索用户的接口，再打上注释输入 /**

![image-20230401132721296](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401132721296.png)

```java
    /**
     * 根据标签搜索用户
     * @param tagNameList 用户要拥有的标签
     * @return
     */
    @Override
    public int searchUsersByTags(List<String> tagNameList) {

    }
```

3. 在 UserService 中也给这个方法打上注释

![image-20230401133437572](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401133437572.png)

```java
    /**
     * 根据标签搜索用户
     * @param tagNameList 用户拥有的标签
     * @return
     */
    int searchUsersByTags(List<String> tagNameList);
```

3. 回到 UserServiceImpl 中开始编写逻辑

> 先判断一下是否为空，然后如果说是空的话，直接抛出异常返回；否则的话，创建这个查询，放进一个 queryWrapper = new QueryWrapper，在 queryWrapper 把 tagList 全部组成一个 and 的查询…

![image-20230401135332121](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401135332121.png)

```java
/**
 * 根据标签搜索用户
 * @param tagNameList 用户要拥有的标签
 * @return
 */
@Override
public List<User> searchUsersByTags(List<String> tagNameList) {
    if (CollectionUtils.isEmpty(tagNameList)) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    QueryWrapper<User> queryWrapper = new QueryWrapper<>();
    // 拼接 and 查询
    // like '%Java%' and like '%Python%'
    for (String tagName : tagNameList) {
        queryWrapper = queryWrapper.like("tags", tagName);
    }
    List<User> userList = userMapper.selectList(queryWrapper);
    userList.forEach(this::getSafetyUser);
}
```

4. 我们要返回一个新的列表

![image-20230401135928794](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401135928794.png)

```java
return userList.stream().map(this::getSafetyUser).collect(Collectors.toList());
```

#### 2. 测试

1. 编写测试代码

![image-20230401141258481](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401141258481.png)

```java
@Test
void testSearchUsersByTags() {
    List<String> tagNameList = Arrays.asList("java", "python");
    List<User> userList = userService.searchUsersByTags(tagNameList);
    Assert.assertNotNull(userList);
}
```

2. 不过现在搜不到，我们要去数据库修改下数据

![image-20230401141606301](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401141606301.png)

3. 开启 sql 输出日志

![image-20230401141832016](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401141832016.png)

4. 测试一下，看看结果

![image-20230401142616262](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401142616262.png)

5. 因为在数据库中添加了一个 tags 字段，但是在 mybatis-plus 中还没有添加，现在添加一下

![image-20230401142807648](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401142807648.png)

![image-20230401142853930](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401142853930.png)

![image-20230401142932283](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401142932283.png)

6. 替换一下 create.sql 中 user 表的建表语句

![image-20230401143214741](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401143214741.png)

7. 现在换一种查询方式

![image-20230401144039514](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401144039514.png)

```java
    /**
     * 根据标签搜索用户
     * @param tagNameList 用户要拥有的标签
     * @return
     */
    @Override
    public List<User> searchUsersByTags(List<String> tagNameList) {
        if (CollectionUtils.isEmpty(tagNameList)) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
//        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
//        // 拼接 and 查询
//        // like '%Java%' and like '%Python%'
//        for (String tagName : tagNameList) {
//            queryWrapper = queryWrapper.like("tags", tagName);
//        }
//        List<User> userList = userMapper.selectList(queryWrapper);
        // 1.查询所有用户
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        List<User> userList = userMapper.selectList(queryWrapper);
        // 2.在内存中判断是否包含要求的标签
        for (User user : userList) {
            String tagsStr = user.getTags();
        }
        return userList.stream().map(this::getSafetyUser).collect(Collectors.toList());
    }
```

#### 3. 将字符串转为 json

> **解析 JSON 字符串**：
>
> 1. 序列化：java 对象转成 json
> 2. 反序列化：把 json 转为 java 对象
>
> **java json 序列化库有很多**：
>
> 1. gson（goole 的）
> 2. fastjson alibaba（ali 出品，块，但漏洞多）
> 3. jackson
> 4. kryo

1. 去 maven 仓库中搜索 gson，复制依赖

![image-20230401144430014](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401144430014.png)

```xml
<!-- https://mvnrepository.com/artifact/com.google.code.gson/gson -->
<dependency>
    <groupId>com.google.code.gson</groupId>
    <artifactId>gson</artifactId>
    <version>2.8.9</version>
</dependency>
```

2. 放到 pom.xml 文件中，加载依赖

![image-20230401144601596](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401144601596.png)

3. 继续编写 UserServiceImp 方法

![image-20230401145157223](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401145157223.png)

```java
    /**
     * 根据标签搜索用户
     * @param tagNameList 用户要拥有的标签
     * @return
     */
    @Override
    public List<User> searchUsersByTags(List<String> tagNameList) {
        if (CollectionUtils.isEmpty(tagNameList)) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
//        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
//        // 拼接 and 查询
//        // like '%Java%' and like '%Python%'
//        for (String tagName : tagNameList) {
//            queryWrapper = queryWrapper.like("tags", tagName);
//        }
//        List<User> userList = userMapper.selectList(queryWrapper);
        // 1.查询所有用户
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        List<User> userList = userMapper.selectList(queryWrapper);
        Gson gson = new Gson();
        // 2.在内存中判断是否包含要求的标签
        return userList.stream().filter(user -> {
            String tagsStr = user.getTags();
            if (StringUtils.isBlank(tagsStr)) {
                return false;
            }
            Set<String> tempTagNameSet = gson.fromJson(tagsStr, new TypeToken<Set<String>>() {
            }.getType());
            for (String tagName : tagNameList) {
                if (!tempTagNameSet.contains(tagName)) {
                    return false;
                }
            }
            return true;
        }).map(this::getSafetyUser).collect(Collectors.toList());
    }
```

4. 测试一下

![image-20230401145344273](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401145344273.png)

**思考？**两种查询的方式哪种更快呢？

> 应该是第二种方式更快，第一种方式是直接用 sql 来进行查询，查询的内容是硬盘上的
>
> 而第二种方式，我们是直接将所有的数据都取出来，在内存中进行查询，显然，内存的速度要远远快于硬盘的速度
>
> 所以，一般来说第二种的速度会更快一点，但是由于当前的数据量比较小，所以测试并不准确，具体的快慢还是要看具体的应用场景

### 三、后端标签接口调试

#### 1. 内存过滤

```java
/**
 * 根据标签搜索用户（内存过滤）
 *
 * @param tagNameList 用户要拥有的标签
 * @return
 */
@Override
public List<User> searchUsersByTags(List<String> tagNameList) {
    if (CollectionUtils.isEmpty(tagNameList)) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    // 1.查询所有用户
    QueryWrapper<User> queryWrapper = new QueryWrapper<>();
    List<User> userList = userMapper.selectList(queryWrapper);
    Gson gson = new Gson();
    // 2.在内存中判断是否包含要求的标签
    return userList.stream().filter(user -> {
        String tagsStr = user.getTags();
        if (StringUtils.isBlank(tagsStr)) {
            return false;
        }
        Set<String> tempTagNameSet = gson.fromJson(tagsStr, new TypeToken<Set<String>>() {
        }.getType());
        tempTagNameSet = Optional.ofNullable(tempTagNameSet).orElse(new HashSet<>());
        for (String tagName : tagNameList) {
            if (!tempTagNameSet.contains(tagName)) {
                return false;
            }
        }
        return true;
    }).map(this::getSafetyUser).collect(Collectors.toList());
}
```

#### 2. SQL查询版

```java
/**
 * 根据标签搜索用户（SQL查询版）
 *
 * @param tagNameList 用户要拥有的标签
 * @return
 */
@Deprecated
public List<User> searchUsersBySql(List<String> tagNameList) {
    if (CollectionUtils.isEmpty(tagNameList)) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    QueryWrapper<User> queryWrapper = new QueryWrapper<>();
    // 拼接 and 查询
    // like '%Java%' and like '%Python%'
    for (String tagName : tagNameList) {
        queryWrapper = queryWrapper.like("tags", tagName);
    }
    List<User> userList = userMapper.selectList(queryWrapper);
    return userList.stream().map(this::getSafetyUser).collect(Collectors.toList());
}
```

## 前端开发

### 一、前端整合路由

#### 1. 下载安装vue路由

1. 引入一个路由：[Vue Router | The official Router for Vue.js (vuejs.org)](https://router.vuejs.org/)

![image-20230401231950810](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401231950810.png)

2. 下载安装路由

```shell
# npm
npm install vue-router@4

# yarn
yarn add vue-router@4
```

![image-20230401232313357](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401232313357.png)

3. 再次启动项目，`package.json` 中多了 `vue-router`

![image-20230401232401533](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401232401533.png)

#### 2. 整合路由框架

1. 继续跟着官方文档，看一下怎么引用

![image-20230401232503487](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401232503487.png)

```javascript
// 1. 定义路由组件.
// 也可以从其他文件导入
const Home = { template: '<div>Home</div>' }
const About = { template: '<div>About</div>' }

// 2. 定义一些路由
// 每个路由都需要映射到一个组件。
// 我们后面再讨论嵌套路由。
const routes = [
  { path: '/', component: Home },
  { path: '/about', component: About },
]

// 3. 创建路由实例并传递 `routes` 配置
// 你可以在这里输入更多的配置，但我们在这里
// 暂时保持简单
const router = VueRouter.createRouter({
  // 4. 内部提供了 history 模式的实现。为了简单起见，我们在这里使用 hash 模式。
  history: VueRouter.createWebHashHistory(),
  routes, // `routes: routes` 的缩写
})

// 5. 创建并挂载根实例
const app = Vue.createApp({})
//确保 _use_ 路由实例使
//整个应用支持路由。
app.use(router)

app.mount('#app')

// 现在，应用已经启动了！
```

2. 找到前端项目的主页面，修改一下

![image-20230401232652769](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401232652769.png)

修改后：

![image-20230401233725476](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401233725476.png)

```tsx
import { createApp } from 'vue';
import {Button, Icon, NavBar, Tabbar, TabbarItem } from 'vant';
import App from './App.vue';
import 'vant/es/toast/style';
// @ts-ignore
import * as VueRouter from "vue-router";
import Index from "./pages/Index.vue";
import Team from "./pages/Team.vue";

const app = createApp(App);
app.use(Button);
app.use(Icon);
app.use(NavBar);
app.use(Tabbar)
app.use(TabbarItem)

// 定义一些路由
const routes = [
    { path: '/', component: Index },
    { path: '/about', component: Team },
]

const router = VueRouter.createRouter({
    // 4. 内部提供了 history 模式的实现。为了简单起见，我们在这里使用 hash 模式。
    history: VueRouter.createWebHashHistory(),
    routes, // `routes: routes` 的缩写
})

app.use(router);

app.mount('#app');
```

> 这个页面的跳转的规则，它是一个全局性的东西，所以尽量把它提出，要不然后面可能写起来会非常复杂，不要什么东西都写在主文件里面
>
> ![image-20230401233935618](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401233935618.png)

3. 新建一个配置文件，在 src 目录下创建 config 目录，在 config 目录下创建 `route.ts` 文件

![image-20230401234221320](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401234221320.png)

4. 在 `main.ts` 中引入一下

![image-20230401234325578](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401234325578.png)

5. 找到布局文件 `BasicLayout.vue`，之前我们用 v-if，现在不用了，引入 `route-view`，这个是根据不同的页面展示不同的内容

![image-20230401234633693](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401234633693.png)

改为：

![image-20230401234730220](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401234730220.png)

6. 搭配 `router-link` 来创建链接，试一下

![image-20230401234840837](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401234840837.png)

![image-20230401235011047](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401235011047.png)

7. 测试一下

点击 Go to Home 显示主页面，点击队伍显示队伍，路径也不一样

![image-20230401235056634](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401235056634.png)

#### 3. tab栏切换路由

这说明框架已经整合成功了，我们现在需要用底下这个 tab 栏去切换路由

1. 去看一下 vant3 的官方文档

![image-20230401235356002](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401235356002.png)

```vue
<router-view />

<van-tabbar route>
  <van-tabbar-item replace to="/home" icon="home-o">标签</van-tabbar-item>
  <van-tabbar-item replace to="/search" icon="search">标签</van-tabbar-item>
</van-tabbar>
```

2. 继续修改 `BasicLayout.vue`

![image-20230401235637975](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401235637975.png)

3. 在 `pages` 目录下新建一个个人页 `User.vue`

![image-20230401235832886](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230401235832886.png)

4. 在 `route.ts` 中加上个人页路由

![image-20230402000042473](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402000042473.png)

5. 测试一下

![image-20230402000114165](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402000114165.png)

6. 将 `router-link` 删掉，路由整合就完成了

![image-20230402000211822](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402000211822.png)

### 二、搜索页面

#### 1. 添加一个搜索页面

1. 去看下 vant3 的文档：找一个合适的搜索页面，参考一下 bilibili

![image-20230402102340302](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402102340302.png)

![image-20230402102558451](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402102558451.png)

```html
<form action="/">
  <van-search
    v-model="value"
    show-action
    placeholder="请输入搜索关键词"
    @search="onSearch"
    @cancel="onCancel"
  />
</form>
```

```tsx
import { ref } from 'vue';
import { showToast } from 'vant';

export default {
  setup() {
    const value = ref('');
    const onSearch = (val) => showToast(val);
    const onCancel = () => showToast('取消');
    return {
      value,
      onSearch,
      onCancel,
    };
  },
};
```

2. 新建一个搜索页 `Search.vue`，把代码粘贴过去，修改一下

![image-20230402103037733](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402103037733.png)

```vue
<template>
  <form action="/">
    <van-search
        v-model="searchText"
        show-action
        placeholder="请输入搜索关键词"
        @search="onSearch"
        @cancel="onCancel"
    />
  </form>
</template>

<script setup>
  import { ref } from 'vue';
  import { showToast } from 'vant';
  const searchText = ref('');
  const onSearch = (val) => showToast(val);
  const onCancel = () => showToast('取消');
</script>
```

3. 然后做一个点击搜索按钮，跳转到搜索页面，看一下 vue 官方文档

![image-20230402103426370](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402103426370.png)

```vue
// 字符串路径
router.push('/users/eduardo')
```

4. 到 `BasicLayout.vue` 粘贴过去，修改一下

![image-20230402103647635](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402103647635.png)

5. 挂载一下搜索路由

![image-20230402104007091](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402104007091.png)

6. 点击搜索按钮试一下，会先弹出一个提示框，然后跳转到搜索页面

![image-20230402104313798](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402104313798.png)

![image-20230402105323557](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402105323557.png)

#### 2. 添加标签和分组

1. 但是点击搜索后，我们还想让它展示当前已选择的标签

![image-20230402105622953](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402105622953.png)

```html
<van-tag :show="show" closeable size="medium" type="primary" @close="close">
  标签
</van-tag>
```

```tsx
import { ref } from 'vue';

export default {
  setup() {
    const show = ref(true);
    const close = () => {
      show.value = false;
    };

    return {
      show,
      close,
    };
  },
};
```

2. 还需要一个列表给它分组

![image-20230402105810685](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402105810685.png)

```vue
<van-divider content-position="left">文字</van-divider>
<van-divider content-position="right">文字</van-divider>
```

3. 将文件名字改一下，标准一下

![image-20230402110204375](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402110204375.png)

![image-20230402110711703](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402110711703.png)

4. 将 tag 标签和分割线代码都粘贴到 `SearchPage.vue` 中，修改一下

![image-20230402110847718](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402110847718.png)

5. 试一下，标签出来了（有点丑）

![image-20230402110931844](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402110931844.png)

6. 选择标签就用 `TreeSelect` 分类选择

![image-20230402111340710](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402111340710.png)

```vue
<van-tree-select
  v-model:active-id="activeIds"
  v-model:main-active-index="activeIndex"
  :items="items"
/>
```

```tsx
import { ref } from 'vue';

export default {
  setup() {
    const activeId = ref([1, 2]);
    const activeIndex = ref(0);
    const items = [
      {
        text: '浙江',
        children: [
          { text: '杭州', id: 1 },
          { text: '温州', id: 2 },
          { text: '宁波', id: 3, disabled: true },
        ],
      },
      {
        text: '江苏',
        children: [
          { text: '南京', id: 4 },
          { text: '无锡', id: 5 },
          { text: '徐州', id: 6 },
        ],
      },
      { text: '福建', disabled: true },
    ];

    return {
      items,
      activeId,
      activeIndex,
    };
  },
};
```

7. 粘贴进 `SearchPage.vue`，修改一下

![image-20230402112825916](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402112825916.png)

![image-20230402112842057](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402112842057.png)

8. 测试一下

![image-20230402112911686](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402112911686.png)

9. 现在已选的标签还不能被移除，我们修改一下

![image-20230402113111065](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402113111065.png)

![image-20230402113153095](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402113153095.png)

10. 测试一下

![image-20230402113319838](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402113319838.png)

11. 将标签的 id 改为 text 的文本

![image-20230402113447734](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402113447734.png)

12. 测试一下

![image-20230402113725988](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402113725988.png)

#### 3. 优化一下

1. 已选中标签挤在一起，不美观

![image-20230402113831018](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402113831018.png)

```vue
<van-row gutter="20">
  <van-col span="8">span: 8</van-col>
  <van-col span="8">span: 8</van-col>
  <van-col span="8">span: 8</van-col>
</van-row>
```

2. 粘贴进 `SearchPage.vue`，修改一下

![image-20230402213236560](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402213236560.png)

3. 看一下

![image-20230402213356271](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402213356271.png)

4. 现在还差个过滤标签

> 可以直接在前端里面过滤，因为标签数据量不大，没有必要向后端发送请求

![image-20230402213637390](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402213637390.png)

![image-20230402213723527](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402213723527.png)

> 原来是嵌套结构，这一步其实就是把数组打平，或者叫扁平化

5. 打平之后，再过滤

![image-20230402214153332](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402214153332.png)

![image-20230402221618376](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402221618376.png)

6. 点击搜索试一下

![image-20230402221656559](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402221656559.png)

### 三、用户信息页

1. 去官方文档找一个现成的

![image-20230402222720541](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402222720541.png)

```vue
<van-cell title="单元格" is-link />
<van-cell title="单元格" is-link value="内容" />
<van-cell title="单元格" is-link arrow-direction="down" value="内容" />
```

2. 粘贴进 `UserPage.vue`

> 定义一下后台用户数据的类别，我们现在用的是 ts，它有一个好处是可以定义一下某一个对象它的规范，比如说有哪些字段，字段是什么类型，那这个类型从哪里取？我们是不是以后中心的时候写过这个规范，写过这个类别

```tsx
  type CurrentUser = {
    id?: number;
    username?: string;
    userAccount: string;
    avatarUrl: string;
    gender?: number;
    phone?: string;
    email?: string;
    userStatus?: number;
    userRole?: number;
    planetCode?: string;
    createTime?: Date;
  };
```

3. 在 src 下新建一个 models 目录，在 models 目录下新建 `user.d.ts`，在这里定义我们的数据类型，把代码粘贴进去，修改一下

![image-20230402223818490](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402223818490.png)

```tsx
/**
 * 用户类型
 */
export type UserType = {
    id: number;
    username: string;
    userAccount: string;
    avatarUrl?: string;
    gender: number;
    phone: string;
    email: string;
    userStatus: number;
    userRole: number;
    planetCode: string;
    tags: string[];
    createTime: Date;
};
```

4. 在 `UserPage.vue` 中引入

![image-20230402232308015](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402232308015.png)

```vue
<template>
  <van-cell title="昵称" is-link to="/user/edit" :value="user.username" />
  <van-cell title="账号" :value="user.userAccount" />
  <van-cell title="头像" is-link to="/user/edit">
    <img style="height: 48px" :src="user.avatarUrl" />
  </van-cell>
  <van-cell title="性别" is-link to="/user/edit" :value="user.gender" />
  <van-cell title="电话" is-link to="/user/edit" :value="user.phone" />
  <van-cell title="邮箱" is-link to="/user/edit" :value="user.email" />
  <van-cell title="星球编号" :value="user.planetCode" />
  <van-cell title="注册时间" :value="user.createTime.toISOString()" />
</template>

<script setup>
const user = {
  id: 1,
  username: 'fickle',
  userAccount: 'fickle',
  avatarUrl: 'http://qzapp.qlogo.cn/qzapp/101983660/DE2DFA542010DAD2696FC2082D1EE3E7/100',
  gender: '男',
  phone: '123',
  email: '456@qq.com',
  planetCode: '1234',
  createTime: new Date(),
}
</script>

<style scoped>

</style>
```

5. 测试一下

![image-20230402232348243](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402232348243.png)

6. 现在做编辑信息，编辑就是点击 `>` 进入到编辑页面

![image-20230402232443758](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402232443758.png)

### 四、用户信息修改页

1. 复制 `UserPage.vue`，粘贴到 pages 目录下，重命名为 `UserEditPage.vue`，新建一个编辑用户页

![image-20230402232641681](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402232641681.png)

2. 在 `route.ts` 新增路由

![image-20230402232807409](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402232807409.png)

3. 修改一下 `UserPage.vue` 和 `UserEditPage.vue`

![image-20230402234905690](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402234905690.png)

![image-20230402235124823](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402235124823.png)

4. 试一下

![image-20230402235226117](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402235226117.png)

5. 删掉一些代码，恢复成如图所示

![image-20230402235506741](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402235506741.png)

![image-20230402235414512](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402235414512.png)

6. 去官方文档找一个编辑方法

![image-20230402235643334](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230402235643334.png)

```vue
<van-form @submit="onSubmit">
  <van-cell-group inset>
    <van-field
      v-model="username"
      name="用户名"
      label="用户名"
      placeholder="用户名"
      :rules="[{ required: true, message: '请填写用户名' }]"
    />
    <van-field
      v-model="password"
      type="password"
      name="密码"
      label="密码"
      placeholder="密码"
      :rules="[{ required: true, message: '请填写密码' }]"
    />
  </van-cell-group>
  <div style="margin: 16px;">
    <van-button round block type="primary" native-type="submit">
      提交
    </van-button>
  </div>
</van-form>
```

```tsx
import { ref } from 'vue';

export default {
  setup() {
    const username = ref('');
    const password = ref('');
    const onSubmit = (values) => {
      console.log('submit', values);
    };

    return {
      username,
      password,
      onSubmit,
    };
  },
};
```

7. 粘贴进 `UserEditPage.vue`，修改一下

![image-20230403000414395](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230403000414395.png)

![image-20230403000423505](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230403000423505.png)

8. 再修改一下 `UserPage.vue`

![image-20230403000645213](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230403000645213.png)

9. 再试一下，修改页就出来了，点击提交，数据也传过来了

![image-20230403000806795](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230403000806795.png)

但是点击左上角的返回时，直接回到了主页，修改一下

10. 让它回到上一个页面，将 `router.push('/')`改为`router.back()`

![image-20230403000944051](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230403000944051.png)

## 后端整合Swagger + Knife4j

> 什么是接口文档？**写接口信息的文档**，每条接口包括：
>
> - 请求参数
> - 响应参数
>   - 错误码
> - 接口地址
> - 接口名称
> - 请求类型
> - 请求格式
> - 备注
>
> who 谁用？一般是后端或者负责人来提供，后端和前端都要使用
>
> 为什么需要接口文档？
>
> - 有个书面内容（背书或者归档），方便大家参考和查阅，便于**沉淀和维护**，拒绝口口相传
> - 接口文档便于前端和后端开发对接，前后端联调的**介质**。后端 => 接口文档 <= 前端
> - 好的接口文档支持在线调试、在线测试，可以作为工具提高我们的开发效率
>
> 怎么做好接口文档？
>
> - 手写（比如腾讯文档、Markdown 笔记）
> - 自动化接口文档生成：自动根据项目代码生成完整的文档或者在线调试的网页。Swagger、Postman（侧重接口管理）（国外）；apifox、apipost、eolink（国内）
>
> 接口文档有哪些技巧？
>
> Swagger 原理：
>
> 1. 引入依赖（Swagger 或 Knife4j）[快速开始 | Knife4j (xiaominfo.com)](https://doc.xiaominfo.com/docs/quick-start)
> 2. 自定义 Swagger 配置类
> 3. 定义需要生成接口文档的代码位置（Controller）
> 4. 千万注意：线上环境不要把接口暴露出去！！！可以通过在 SwaggerConfig 配置文件开头加上 `@Profile({"dev", "test"})` 限定配置仅在部分环境中开启
> 5. 启动即可
> 6. 可以通过在 controller 方法上添加 `@Api`、`@ApiImplicitParam(name = "name",value = "姓名",required = true)` `@ApiOperation(value = "向客人问好")` 等注释来自定义生成的接口描述信息
>
> 若 `springboot version >= 2.6`，需要添加如下配置：
>
> ```yaml
> spring:
>   mvc:
>     pathmatch:
>       matching-strategy: ant_path_matcher
> ```

### 一、swagger

#### 1. 引入依赖

```xml
  <!-- swagger 接口文档 -->
    <dependency>
        <groupId>io.springfox</groupId>
        <artifactId>springfox-swagger2</artifactId>
        <version>2.9.2</version>
    </dependency>
    <dependency>
        <groupId>io.springfox</groupId>
        <artifactId>springfox-swagger-ui</artifactId>
        <version>2.9.2</version>
    </dependency>
```

#### 2. 配置文件

1. 新建 config 文件

![image-20230406163422955](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230406163422955.png)

2. 在文件夹下新建 `SwaggerConfig` 文件

```java
package com.example.usercenterbackendmaster.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

/**
 * @author dell
 * @date 2023/4/6 16:35
 * 自定义 Swagger 接口文档配置
 */

@Configuration // 配置类
@EnableSwagger2 // 开启 swagger2 的自动配置
public class SwaggerConfig {

    @Bean
    public Docket docket() {
        // 创建一个 swagger 的 bean 实例
        return new Docket(DocumentationType.SWAGGER_2)

                // 配置接口信息
                .select() // 设置扫描接口
                // 配置如何扫描接口
                .apis(RequestHandlerSelectors
                                //.any() // 扫描全部的接口，默认
                                //.none() // 全部不扫描
                                .basePackage("com.example.usercenterbackendmaster.controller") // 扫描指定包下的接口，最为常用
                        //.withClassAnnotation(RestController.class) // 扫描带有指定注解的类下所有接口
                        //.withMethodAnnotation(PostMapping.class) // 扫描带有只当注解的方法接口

                )
                .paths(PathSelectors
                                .any() // 满足条件的路径，该断言总为true
                        //.none() // 不满足条件的路径，该断言总为false（可用于生成环境屏蔽 swagger）
                        //.ant("/user/**") // 满足字符串表达式路径
                        //.regex("") // 符合正则的路径
                )
                .build();
    }

    // 基本信息设置
    private ApiInfo apiInfo() {
        Contact contact = new Contact(
                "fickler", // 作者姓名
                "fickler.cn", // 作者网址
                "2586844575@qq.com"); // 作者邮箱
        return new ApiInfoBuilder()
                .title("伙伴匹配系统-接口文档") // 标题
                .description("众里寻他千百度，慕然回首那人却在灯火阑珊处") // 描述
                .termsOfServiceUrl("https://www.baidu.com") // 跳转连接
                .version("1.0") // 版本
                .license("Swagger-的使用(详细教程)")
                .licenseUrl("https://blog.csdn.net/xhmico/article/details/125353535")
                .contact(contact)
                .build();
    }


}
```

#### 3. 配置yml文件

```yaml
  mvc:
    path match:
      matching-strategy: ant_path_matcher
```

#### 4. 运行启动

http://localhost:8080/api/swagger-ui.html#/user-controller

![image-20230406165604535](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230406165604535.png)



### 二、Knife4j

#### 1. 引入依赖

```xml
<!-- knife4j 接口文档 -->
<dependency>
    <groupId>com.github.xiaoymin</groupId>
    <artifactId>knife4j-spring-boot-starter</artifactId>
    <version>2.0.7</version>
</dependency>
```

#### 2. 配置文件

```java
package com.example.usercenterbackendmaster.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2WebMvc;

/**
 * @author dell
 * @date 2023/4/6 16:35
 * 自定义 Swagger 接口文档配置
 */

@Configuration
@EnableSwagger2WebMvc
@Profile({"dev", "test"})   //版本控制访问
public class SwaggerConfig {

    @Bean(value = "defaultApi2")
    public Docket defaultApi2() {
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .select()
                // 这里一定要标注你控制器的位置
                .apis(RequestHandlerSelectors.basePackage("com.example.usercenterbackendmaster.controller"))
                .paths(PathSelectors.any())
                .build();
    }

    /**
     * api 信息
     * @return
     */
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title("伙伴匹配系统")
                .description("伙伴匹配系统接口文档")
                .termsOfServiceUrl("https://github.com/Worldfickler")
                .contact(new Contact("fickler","https://blog.csdn.net/qq_52354698?type=blog","2586844575@qq.com"))
                .version("1.0")
                .build();
    }
}
```

#### 3. 配置yml文件

```yaml
  mvc:
    path match:
      matching-strategy: ant_path_matcher

  profiles:
    active: dev
```

#### 4. 启动一下

http://localhost:8080/api/doc.html#/home

![image-20230406172652760](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230406172652760.png)

#### 5. 测试接口

> 因为笔记用了云床（腾讯云），所以可能涉及到密码什么隐私性的标识会查看失败....所以这里就进行了一些打码...

![image-20230406173223135](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230406173223135.png)

## 存量用户信息导入及同步

> 1. 把所有星球用户的信息导入
> 2. 把写了自我介绍的同学的标签信息导入
> 3. `FeHelper` 钱罐辅助插件，推荐安装

**看上了网页信息，怎么抓取？**

1. 分析原网站是怎么获取这些数据的？哪个接口？

F12 进入控制台，查看网络请求，复制 curl 代码便于查看和执行

```http
curl "https://api.zsxq.com/v2/hashtags/48844541224218/topics?count=20" ^
  -H "authority: api.zsxq.com" ^
  -H "accept: application/json, text/plain, */*" ^
  -H "accept-language: zh-CN,zh;q=0.9" ^
  -H "cache-control: no-cache" ^
  -H "cookie: zsxq_access_token=594D9AC8-11B7-946B-23A5-13755B43EE45_662C462C57CAB9C2; zsxqsessionid=07992e44e4933596449360a2492954d5; abtest_env=product" ^
  -H "origin: https://wx.zsxq.com" ^
  -H "pragma: no-cache" ^
  -H "referer: https://wx.zsxq.com/" ^
  -H "sec-ch-ua: ^\^"Google Chrome^\^";v=^\^"111^\^", ^\^"Not(A:Brand^\^";v=^\^"8^\^", ^\^"Chromium^\^";v=^\^"111^\^"" ^
  -H "sec-ch-ua-mobile: ?0" ^
  -H "sec-ch-ua-platform: ^\^"Windows^\^"" ^
  -H "sec-fetch-dest: empty" ^
  -H "sec-fetch-mode: cors" ^
  -H "sec-fetch-site: same-site" ^
  -H "user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36" ^
  -H "x-request-id: ef98ad4b4-d5ff-68be-88cf-a3b764d3f22" ^
  -H "x-signature: 305bb241ffdf60b2eaca4c70f6663cfa74571f89" ^
  -H "x-timestamp: 1680773992" ^
  -H "x-version: 2.35.0" ^
  --compressed
```

![image-20230406174205160](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230406174205160.png)

2. 用程序去调用接口（java okhttp httpclient / python 都可以）
3. 处理（清洗）一下数据，之后就可以写到数据库里



## 流程（数据导入）

1. 从 Excel 中导入全量用户数据，**判重**

easy excel：[EasyExcel官方文档 - 基于Java的Excel处理工具 | Easy Excel (alibaba.com)](https://easyexcel.opensource.alibaba.com/index.html)

2. 住区写了自我介绍的用户信息，提取出用户昵称、用户唯一id、自我介绍信息
3. 从自我介绍中提取信息，然后写入到数据库中

**两种读对象的方式**：

1. 确定表头：建立对象，和表头形成映射关系
2. 不确定表头：每一行数据映射为 Map<String, Object>

**两种读取模式**：

1. 监听器：先创建监听器、在读取文件时绑定监听器。单独抽离处理逻辑，代码清洗，易维护；一条一条处理，适用于数据量大的场景。
2. 同步读：无需创建监听器，一次性获取完整数据。方便简单，但是数据量大时会有等待时常，也可能内存溢出。

### easy excel

![image-20230406175933517](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230406175933517.png)

#### 1. 引入依赖

```xml
    <!-- easy Excel -->
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>easyexcel</artifactId>
        <version>3.1.0</version>
    </dependency>
```

#### 2. 新建文件夹和星球表格用户信息文件

```java
package com.example.usercenterbackendmaster.easyExcel;

import com.alibaba.excel.annotation.ExcelProperty;

/**
 * @author dell
 * @date 2023/4/6 18:08
 * 星球用户信息
 */

@Data
public class PlanetTableUserInfo {

    /**
     * 用户id
     */
    @ExcelProperty("成员编号")
    private String planetCode;

    /**
     * 用户昵称
     */
    @ExcelProperty("成员昵称")
    private String username;

}

```

#### 3. 新建监听器

```java
package com.example.usercenterbackendmaster.easyExcel;

import com.alibaba.excel.context.AnalysisContext;
import com.alibaba.excel.read.listener.ReadListener;
import lombok.extern.slf4j.Slf4j;

/**
 * @author dell
 * @date 2023/4/6 18:11
 * 监听器
 */

// 有个很重要的点 TableListener 不能被spring管理，要每次读取excel都要new,然后里面用到spring可以构造方法传进去
@Slf4j
public class TableListener implements ReadListener<PlanetTableUserInfo> {

    /**
     * 这个每一条数据解析都会来调用
     *
     * @param data    one row value. Is is same as {@link AnalysisContext#readRowHolder()}
     * @param context
     */
    @Override
    public void invoke(PlanetTableUserInfo data, AnalysisContext context) {
        System.out.println(data);
    }

    /**
     * 所有数据解析完成了 都会来调用
     *
     * @param context
     */
    @Override
    public void doAfterAllAnalysed(AnalysisContext context) {
        System.out.println("已解析完成");
    }

}
```

#### 4. 新建读取数据文件

```java
package com.example.usercenterbackendmaster.easyExcel;

import com.alibaba.excel.EasyExcel;

import java.util.List;

/**
 * @author dell
 * @date 2023/4/6 18:14
 * 导入excel，读取数据
 */
public class ImportExcel {

    /**
     * 读取数据
     */
    public static void main(String[] args) {
        // 写法1：JDK8+ ,不用额外写一个DemoDataListener
        // since: 3.0.0-beta1
        //Excel数据文件放在自己电脑上，能够找到的路径
        String fileName = "C:\\Users\\dell\\Downloads\\testExcel.xlsx";
//          readByListener(fileName);
        synchronousRead(fileName);

    }
    /**
     * 监听器读取
     * @param fileName
     */
    public static void readByListener(String fileName) {
        // 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭
        // 这里每次会读取100条数据 然后返回过来 直接调用使用数据就行
        EasyExcel.read(fileName, PlanetTableUserInfo.class, new TableListener()).sheet().doRead();
    }

    /**
     * 同步读
     * 同步的返回，不推荐使用，如果数据量大会把数据放到内存里面
     */
    public static void synchronousRead(String fileName) {
        // 这里 需要指定读用哪个class去读，然后读取第一个sheet 同步读取会自动finish
        List<PlanetTableUserInfo> list = EasyExcel.read(fileName).head(PlanetTableUserInfo.class).sheet().doReadSync();
        for (PlanetTableUserInfo planetTableUserInfo : list) {
            System.out.println(planetTableUserInfo);
        }

    }

}
```

#### 5. 运行代码

![image-20230406182033354](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230406182033354.png)

#### 6. 导入数据库

> 这里并没有真正的导入数据库....🐶

```java
package com.example.usercenterbackendmaster.easyExcel;

import com.alibaba.excel.EasyExcel;
import org.apache.commons.lang3.StringUtils;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * @author dell
 * @date 2023/4/6 18:22
 * 导入星球数据库
 */
public class ImportPlanetUser {

    public static void main(String[] args) {
        //Excel数据文件放在自己电脑上，能够找到的路径
        String fileName = "C:\\Users\\dell\\Downloads\\testExcel.xlsx";
        // 这里 需要指定读用哪个class去读，然后读取第一个sheet 同步读取会自动finish
        List<PlanetTableUserInfo> userInfoList =
                EasyExcel.read(fileName).head(PlanetTableUserInfo.class).sheet().doReadSync();
        System.out.println("总数 = " + userInfoList.size());
        Map<String, List<PlanetTableUserInfo>> listMap =
                userInfoList.stream()
                        .filter(userInfo -> StringUtils.isNotEmpty(userInfo.getUsername()))
                        .collect(Collectors.groupingBy(PlanetTableUserInfo::getUsername));
        for (Map.Entry<String, List<PlanetTableUserInfo>> stringListEntry : listMap.entrySet()) {
            if (stringListEntry.getValue().size() > 1) {
                System.out.println("username = " + stringListEntry.getKey());
                System.out.println("1");
            }
        }
        System.out.println("不重复昵称数 = " + listMap.keySet().size());
    }

}
```

## 页面开发

### 一、搜索页面

#### 1. 新建搜索页面

1. 新建一个搜索结果页面 `SearchResultPage`

![image-20230407083214314](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407083214314.png)

2. 为新页面添加一个路由

![image-20230407084226374](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407084226374.png)

3. 添加一个搜索按钮

因为我们之前的搜索页面没有搜索按钮，所以先添加一个按钮来挑战页面

```vue
<van-button type="primary" @click="doSearchResult">搜索</van-button>
```

![image-20230407103406915](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407103406915.png)

4. 添加路由组件

```tsx
const router = useRouter();
```

在当前页压入一个新的地址，网页就会导航到一个新的地址

```tsx
const onClickRight = () => alert(router.push('/search'));
```

![image-20230407085300464](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407085300464.png)

#### 2. 前端传值

> 前端页面跳转传值
>
> 1. query => url searchParams， url 后附加参数，传递的值长度有限
> 2. vuex（全局状态管理），搜索页面将关键词塞到状态中，搜索结果页从状态中取值

1. 看一下 `vue Router` 的官方文档

![image-20230407090207597](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407090207597.png)

2. 将搜索的值附加到地址栏中

![image-20230407093854545](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407093854545.png)

```ts
  /**
   * 执行搜索
   */
  const doSearchResult = () => {
    router.push({
      path: '/search/list',
      query: {
        tags: activeIds.value
      }
    });
  }
```

3. 测试一下

搜索的值成功的添加到地址栏中，我们现在就只需要从地址栏中拿到传过来的值就可以了

![image-20230407090543529](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407090543529.png)

4. 看一下 `vue Router` 官方文档是如何取值

这里官方文档没有明确的介绍...🐶

直接用 `route.query`可以拿到值

![image-20230407093417903](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407093417903.png)

测试一下

![image-20230407093943972](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407093943972.png)

成功拿到值了

![image-20230407093932419](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407093932419.png)

#### 3. 添加信息展示组件

1. 设置一个假的用户信息

```tsx
const mockUser = {
  id: 12332,
  username: 'fickler',
  userAccount: '112221',
  avatarUrl: 'https://profile.csdnimg.cn/4/A/E/2_qq_52354698',
  gender: 0,
  phone: '12121212121',
  email: '1221112112@qq.com',
  userStatus: 0,
  userRole: 0,
  planetCode: '2332',
  tags: ['java', 'c++', 'emo'],
  createTime: new Date(),
}
```

2. 去 `vant` 组件库找一个适合我们的列表组件

![image-20230407094649958](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407094649958.png)

```vue
<van-card
  num="2"
  price="2.00"
  desc="描述信息"
  title="商品标题"
  thumb="https://fastly.jsdelivr.net/npm/@vant/assets/ipad.jpeg"
>
  <template #tags>
    <van-tag plain type="primary">标签</van-tag>
    <van-tag plain type="primary">标签</van-tag>
  </template>
  <template #footer>
    <van-button size="mini">按钮</van-button>
    <van-button size="mini">按钮</van-button>
  </template>
</van-card>
```

3. 我们展示页面是展示全部的用户，所以用一个 v-for 循环将 userList 组件中的全部用户都取出来

```vue
      v-for="user in userList"
```

4. 修改数据库表，增加一个用户简介

![image-20230407095111379](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407095111379.png)

5. 前端对应的数据类型也要增加

![image-20230407095153089](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407095153089.png)

6. 修改一下列表组件对应的值

> 如果网上别人的图片有防盗链应该怎么拿到呢？
>
> ```html
> <meta name="referrer" content="no-referrer">
> ```
>
> 上面的代码是将我们伪装成陌生人
>
> 对于防盗链，部分可能对陌生人不加以阻拦，那么我们就可以通过上述的方法来拿到
>
> 如果对于陌生人也进行阻拦的话那就不能通过上述方法拿到了

```vue
<template>
  <van-card
      v-for="user in userList"
      :desc="user.profile"
      :title="`${user.username} (${user.planetCode})`"
      :thumb="user.avatarUrl"
  >
    <template #tags>
      <van-tag plain type="primary" v-for="tag in user.tags" style="margin-right: 8px; margin-top: 8px">
        {{tag}}
      </van-tag>
    </template>
    <template #footer>
      <van-button size="mini">联系我</van-button>
    </template>
  </van-card>
</template>
```

![image-20230407103444141](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407103444141.png)

![image-20230407103537593](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407103537593.png)

7. 优化一下搜索按钮（太丑了🐶）

```vue
<div style="padding: 12px">
  <van-button block type="primary" @click="doSearchResult">搜索</van-button>
</div>
```

![image-20230407104048005](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407104048005.png)

#### 4. 对接后端接口

> 我们之前已经写了一个根据标签搜索用户的方法，但是在 `controller` 层中还没有增加对应的接口

1. 在 `controller` 层中添加一个按标签搜索用户列表的接口

```java
/**
 * 根据标签搜索用户
 * @param tagNameList 标签列表
 * @return
 */
@GetMapping("/search/tags")
public BaseResponse<List<User>> searchUserByTags(List<String> tagNameList) {
    if (CollectionUtils.isEmpty(tagNameList)) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    List<User> userList = userService.searchUsersByTags(tagNameList);
    return ResultUtils.success(userList);
}
```

#### 附加：Spring启动图标

在 `resources` 文件下，新建一个 `banner.txt` 文件，然后在文件内替换你喜欢的图标即可，或者打广告...🐶

2. 测试一下（使用我们之前的接口文档）

发送空值

![image-20230407111820951](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407111820951.png)

发送一个值

![image-20230407112218691](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407112218691.png)

依旧是不行，我们去给后端换个方法

![image-20230407112348756](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407112348756.png)

再测试一下传空值

![image-20230407112544436](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407112544436.png)

> 爆了一堆的错误信息...
>
> 我们不应该将这一堆的错误信息发送给前端

再修改一下接口，允许传空值

![image-20230407112709784](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407112709784.png)

再测试一下

![image-20230407112836951](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407112836951.png)

> 现在已经按照我们的后端处理，正常抛出错误信息了

正常传入值测试

![image-20230407112946711](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407112946711.png)

#### 5. 前后端对接

1. 安装一下 axios

```shell
npm install axios
```

![image-20230407113951997](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407113951997.png)

![image-20230407114100611](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407114100611.png)

2. 新建一个 `plugins` 文件夹

![image-20230407114201776](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407114201776.png)

3. 在 `plugins` 文件夹下，新建一个 `myAxios.js` 文件

![image-20230407114252648](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230407114252648.png)

4. `myAxios` 基础配置

```js
import axios from "axios";

const myAxios = axios.create({
    baseURL: 'http://localhost:8080/api',
});

export default myAxios;
```

我在 baseURL 中填写我们的后端地址，这样在每次接收和向后端发送请求的时候，就不需要重复的加这个前缀了

5. `myAxios` 的请求拦截器

```js
// 添加请求拦截器
myAxios.interceptors.request.use(function (config) {
    console.log("我要发请求了！")
    // 在发送请求之前做些什么
    return config;
}, function (error) {
    // 对请求错误做些什么
    return Promise.reject(error);
});

// 添加响应拦截器
myAxios.interceptors.response.use(function (response) {
    console.log("我接收到请求了！")
    // 2xx 范围内的状态码都会触发该函数。
    // 对响应数据做点什么
    return response;
}, function (error) {
    // 超出 2xx 范围的状态码都会触发该函数。
    // 对响应错误做点什么
    return Promise.reject(error);
});
```

通过添加 axios 的请求拦截器，我们可以在接收到后端请求后做一些事情，也可以在向后端发送请求前做一些事情

6. 添加一下 axios 请求

```tsx
  onMounted(() => {
    // 上述请求也可以按以下方式完成（可选）
    myAxios.get('/user/search/tags', {
      params: {
        tagNameList: tags
      }
    })
        .then(function (response) {
          console.log('/user/search/tags success', response);
          showSuccessToast('请求成功');
        })
        .catch(function (error) {
          console.log('/user/search/tags error', error);
          showFailToast('请求失败');
        })
        .then(function () {
          // 总是会执行
        });
  })
```

7. 测试一下

![image-20230408170147797](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230408170147797.png)

请求失败...

跨域问题！！！

#### 6. 解决报错

1. 去后端处理跨域问题

![image-20230408170527394](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230408170527394.png)

```java
@CrossOrigin(origins = {"http://127.0.0.1:5173"})
```

后端通过配置 `@CrossOrigin(origins = {"http://127.0.0.1:5173"})` 来只允许这个域名可以向后端发送请求

> 这个只能防前端，而不能防后端，因为跨域是浏览器的问题

2. 再测试一下

![image-20230408170800462](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230408170800462.png)

3. 通过标签搜索测试一下

![image-20230408171921931](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230408171921931.png)

请求失败了，为什么失败了？

```http
Request URL: http://localhost:8080/api/user/search/tagstagNameList[]=%E7%94%B7&tagNameList[]=%E5%A5%B3
```

后端不认识这个带中括号的东西，我们要将它转换一下

4. 转换一下格式

[axios中get请求传参为数组/参数序列化 - 简书 (jianshu.com)](https://www.jianshu.com/p/656c22a24b69)

```tsx
import qs from 'qs';
export function getMetricList(params) {
  return axios.get(`/xxx/metrics`, {
    params,
    paramsSerializer: params => {
      return qs.stringify(params, { indices: false })
    }
  });
}
```

![image-20230408172758794](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230408172758794.png)

5. 再测试一下

请求成功了！

![image-20230408172832854](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230408172832854.png)

6. 给数据库添加一些假数据

![image-20230408223440494](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230408223440494.png)

7. 前端接收一下响应的数据

```tsx
  onMounted(async () => {
    // 上述请求也可以按以下方式完成（可选）
    const userListData = await myAxios.get('/user/search/tags', {
      params: {
        tagNameList: tags
      },
      paramsSerializer: params => {
        return qs.stringify(params, { indices: false })
      }
    })
        .then(function (response) {
          console.log('/user/search/tags success', response);
          showSuccessToast('请求成功');
          console.log(response);
          return response;
        })
        .catch(function (error) {
          console.log('/user/search/tags error', error);
          showFailToast('请求失败');
        })
    if (userListData) {
      userList.value = userListData;
    }
  })
```

![image-20230409181955901](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230409181955901.png)

可以看到，响应得到的数据是在 data 中的 data 中，修改一下前端接收响应的代码

![image-20230409182047514](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230409182047514.png)

8. 测试一下

![image-20230409182116401](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230409182116401.png)

tags 标签展示错误了，因为我们后端 tags 标签是 json 格式，但是前端将其识别成了字符串，这里我们要转换一下

9. 在前端将将 tags 转换为 json 格式

```tsx
    if (userListData) {
      userListData.forEach(user => {
        if (user.tags) {
          user.tags = JSON.parse(user.tags);
        }
      })
      userList.value = userListData;
    }
```

![image-20230409182758459](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230409182758459.png)

10. 添加一个数据为空的提示

![image-20230409183039115](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230409183039115.png)

```vue
<van-empty description="描述文字" />
```

![image-20230409183201783](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230409183201783.png)

### 二、登录页面

#### 1. 新建登录页面

1. 新建一个登录页面 `UserLoginPage`

![image-20230410102026187](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230410102026187.png)

2. 增加一个登录页面的路由

![image-20230410102207689](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230410102207689.png)

3. 增加一个登录表单项

![image-20230410102910078](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230410102910078.png)

```vue
  <van-form @submit="onSubmit">
    <van-cell-group inset>
      <van-field
          v-model="username"
          name="用户名"
          label="用户名"
          placeholder="用户名"
          :rules="[{ required: true, message: '请填写用户名' }]"
      />
      <van-field
          v-model="password"
          type="password"
          name="密码"
          label="密码"
          placeholder="密码"
          :rules="[{ required: true, message: '请填写密码' }]"
      />
    </van-cell-group>
    <div style="margin: 16px;">
      <van-button round block type="primary" native-type="submit">
        提交
      </van-button>
    </div>
  </van-form>
```

```ts
import {ref} from "vue";

const userAccount = ref('');
const userPassword = ref('');
const onSubmit = (values) => {
  console.log('submit', values);
};
```

4. 修改一下，使其适用后端

```vue
  <van-form @submit="onSubmit">
    <van-cell-group inset>
      <van-field
          v-model="userAccount"
          name="账号"
          label="账号"
          placeholder="请输入账号"
          :rules="[{ required: true, message: '请填写用户名' }]"
      />
      <van-field
          v-model="userPassword"
          type="password"
          name="密码"
          label="密码"
          placeholder="请输入密码"
          :rules="[{ required: true, message: '请填写密码' }]"
      />
    </van-cell-group>
    <div style="margin: 16px;">
      <van-button round block type="primary" native-type="submit">
        提交
      </van-button>
    </div>
  </van-form>
```

#### 2. 编写提交事件

```tsx
const onSubmit = async () => {
  const res = await myAxios.post('/user/login', {
    userAccount: userAccount.value,
    userPassword: userPassword.value,
  })
  console.log(res, "用户登录");
  if (res.code == 0 && res.data) {
    showSuccessToast("登录成功");
    router.replace("/");
  } else {
    showFailToast("登录失败");
  }
};
```

#### 3. 测试

1. 由于我们还没有编写登录页面的入口，所以直接输入地址访问

`http://127.0.0.1:5173/#/user/login`

![image-20230410104309580](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230410104309580.png)

显示登录失败，但是已经拿到值了

![image-20230410104416309](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230410104416309.png)

2. 修改一下取值

![image-20230410104536449](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230410104536449.png)

可以看到，我们要拿的数据在响应 response 中的 data 中的 data

我们直接修改全局响应拦截器取值的地方

![image-20230410104714416](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230410104714416.png)

3. 再测试一下

![image-20230410104742221](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230410104742221.png)

### 三、用户信息页

#### 1. 将 myAxios,js 修改我 .ts 文件

![image-20230410001745772](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230410001745772.png)

#### 2. 获取当前用户登录信息

```tsx
onMounted(async () => {
  const res = await myAxios.get('/user/current');
  if (res.code === 0) {
    user.value = res.data;
    showSuccessToast("获取用户信息成功");
  } else {
    showFailToast("获取用户信息失败");
  }
})
```

#### 3. 测试

![image-20230410112153927](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230410112153927.png)

1. 我们添加一个 v-if，如果用户信息存在我们展示，不存在我们就不进行展示了

```vue
<template>
  <div v-if="user">
    <van-cell title="昵称" is-link to="/user/edit" :value="user.username" />
    <van-cell title="账号" :value="user.userAccount" />
    <van-cell title="头像" is-link to="/user/edit">
      <img style="height: 48px" :src="user.avatarUrl" />
    </van-cell>
    <van-cell title="性别" is-link to="/user/edit" :value="user.gender" @click="toEdit('gender', '性别', user.gender)" />
    <van-cell title="电话" is-link to="/user/edit" :value="user.phone" @click="toEdit('phone', '电话', user.phone)" />
    <van-cell title="邮箱" is-link to="/user/edit" :value="user.email" />
    <van-cell title="星球编号" :value="user.planetCode" />
    <van-cell title="注册时间" :value="user.createTime.toISOString()" />
  </div>
</template>
```

2. 再测试一下

![image-20230410112551851](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230410112551851.png)

不报错了，但是获取用户信息失败了

![image-20230410112636494](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230410112636494.png)

3. 分析失败原因

> 前端向后端发送请求的时候没有携带上 cookie

![image-20230410115045721](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230410115045721.png)

4. axios 开启携带 cookie

```tsx
axios.defaults.withCredentials = true; // 请求携带 cookie
```

> **出错了😭**
>
> 1. 配置后出现了跨域问题：[axios 添加 withCredentials = true 后出现了跨域问题_在人间负债^的博客-CSDN博客](https://blog.csdn.net/qq_52354698/article/details/130059079?spm=1001.2014.3001.5501)
>
> 2. 前端设置了携带 cookie 后，浏览器依旧不能携带 cookie：

5. 再测试一下

![image-20230410143909793](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230410143909793.png)

6. 修改一下时间的格式

![image-20230410144206358](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230410144206358.png)

![image-20230410144949748](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230410144949748.png)

### 四、用户修改页面

#### 1. 后端用户个人信息修改接口

1. 编写获取当前用户信息的方法

```java
@Override
public User getLoginUser(HttpServletRequest request) {
    if (request == null) {
        return null;
    }
    Object userObj = request.getSession().getAttribute(USER_LOGIN_STATE);
    if (userObj == null) {
        throw new BusinessException(ErrorCode.NO_AUTH);
    }
    return (User) userObj;
}
```

2. 将之前的判断用户是否为管理员抽象为一个公共方法

这里再重写一个判断是否为管理员的方法

```java
    /**
     * 是否为管理员
     * @param request 用户登录状态
     * @return
     */
    @Override
    public boolean isAdmin(HttpServletRequest request) {
        Object userObj = request.getSession().getAttribute(USER_LOGIN_STATE);
        User user = (User) userObj;
        return user != null && user.getUserRole() == UserConstant.ADMIN_ROLE;
    }

    /**
     * 是否为管理员
     * @param loginUser 用户登录状态
     * @return
     */
    @Override
    public boolean isAdmin(User loginUser) {
        return loginUser != null && loginUser.getUserRole() == UserConstant.ADMIN_ROLE;
    }
```

3. 编写用户个人信息修改 `service` 方法

```java
    /**
     * 更新用户信息
     * @param user 用户信息
     * @return
     */
    Integer updateUser(User user, User loginUser);
```

4. 编写用户个人信息修改 `serviceimpl` 接口

```java
    @Override
    public Integer updateUser(User user, User loginUser) {
        long userId = user.getId();
        if (userId <= 0) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        // 如果是管理员，允许更新任意用户
        // 如果不是管理员，只允许更新当前信息
        if (!isAdmin(loginUser) && userId != loginUser.getId()) {
            throw new BusinessException(ErrorCode.NO_AUTH);
        }
        User oldUser = userMapper.selectById(userId);
        if (oldUser == null) {
            throw new BusinessException(ErrorCode.NULL_ERROR);
        }
        return userMapper.updateById(user);
    }
```

5. 编写用户个人信息修改 `controller` 层方法

```java
    /**
     * 更新用户信息
     * @param user 用户信息
     * @param request 用户登录状态
     * @return
     */
    @PostMapping("/update")
    public BaseResponse<Integer> updateUser(@RequestBody User user, HttpServletRequest request) {
        // 校验参数是否为空
        if (user == null) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        User loginUser = userService.getLoginUser(request);
        int result = userService.updateUser(user, loginUser);
        return ResultUtils.success(result);
    }
```

#### 2. 将获取当前用户抽取为公共方法

1. 新建一个 `service` 文件夹

![image-20230410150548799](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230410150548799.png)

> 我们在该文件夹下定义一些向后端发送请求的方法

2. 在 `service` 文件夹下新建一个 `user.ts` 文件

![image-20230410150947911](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230410150947911.png)

3. 编写方法

```tsx
import myAxios from "../plugins/myAxios";

export const getCurrentUser = async () => {
    return await myAxios.get('/user/current');
}
```

### 3. 将用户登录信息缓存在前端

1. 新建一个 `states` 文件夹

![image-20230411000127746](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411000127746.png)

2. 在 `states` 文件夹下新建一个 `user.ts` 文件

![image-20230411000218822](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411000218822.png)

3. 编写缓存逻辑

```tsx
import {UserType} from "../models/user";

let currentUser : UserType;

const setCurrentUserState = (user : UserType) => {
    currentUser = user;
}

const getCurrentUserState = () : UserType => {
    return currentUser;
}

export {
    setCurrentUserState,
    getCurrentUserState,
}
```

4. 修改之前的的获取当前用户信息的代码

```tsx
import myAxios from "../plugins/myAxios";
import {getCurrentUserState, setCurrentUserState} from "../states/user";

export const getCurrentUser = async () => {
    const currentUser = getCurrentUserState();
    if (currentUser) {
        return currentUser;
    }
    // 不存在则从远程获取
    const res = await myAxios.get('/user/current');
    if (res.code === 0) {
        setCurrentUserState(res.data);
        return res.data;
    }
    return null;
}
```

#### 4. 前端对接一下

1. 编写更新请求 axios

```tsx
const onSubmit = async () => {

  const currentUser = await getCurrentUser();

  if (!currentUser) {
    showFailToast("用户未登录");
    return;
  }

  const res = await myAxios.post('/user/update', {
    'id': currentUser.id,
    [editUser.value.editKey]: editUser.value.currentValue,
  })
  if (res.data > 0 && res.code === 0 ) {
    showSuccessToast("修改成功！");
    router.back();
  } else {
    showFailToast("修改错误！");
  }
};
```

2. 测试一下

![image-20230411002133000](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411002133000.png)

获取用户信息失败

分析可知，我们返回的就是 `.data` 数据了，所以需要将之前的代码修改一下

3. 修改历史代码

![image-20230411002312989](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411002312989.png)

4. 再测试一下

![image-20230411002328639](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411002328639.png)

5. 测试一下修改用户信息

![image-20230411004624578](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411004624578.png)

修改成功，按时用户信息页并没有更新，为什么？

> 因为我们将用户一开始登录的信息存到了缓存中，用户更新信息后，缓存中的信息并没有及时的更新

6. 每次更新，我们重新从后端获取信息，并更新到缓存中

```tsx
const onSubmit = async () => {

  const currentUser = await getCurrentUser();

  if (!currentUser) {
    showFailToast("用户未登录");
    return;
  }

  const res = await myAxios.post('/user/update', {
    'id': currentUser.id,
    [editUser.value.editKey]: editUser.value.currentValue,
  })
  if (res.data > 0 && res.code === 0 ) {
    showSuccessToast("修改成功！");
    const updateUser = await myAxios.get('/user/current');
    if (updateUser.code === 0) {
      setCurrentUserState(updateUser.data);
    }
    router.back();
  } else {
    showFailToast("修改错误！");
  }
};
```

7. 再测试一下

修改成功，并且在个人信息页面更新了信息

![image-20230411005538242](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411005538242.png)

### 五、主页面

#### 1. 修改主页面的展示

1. 主页面的展示和搜索结果页面相似，我们直接将搜索结果页面的代码复制过来

![image-20230411082444992](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411082444992.png)

2. 修改部分地方

![image-20230411082647713](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411082647713.png)

#### 2. 开发后端接口

在后端 `controller` 层中添加方法

```java
    /**
     * 首页推荐
     * @param request 用户登录信息
     * @return
     */
    @GetMapping("/recommend")
    public BaseResponse<List<User>> recommendUsers(HttpServletRequest request) {
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        List<User> userList = userService.list(queryWrapper);
        List<User> result = userList.stream().map(user -> userService.getSafetyUser(user)).collect(Collectors.toList());
        return ResultUtils.success(result);
    }
```

#### 3. 测试效果

1. 回到页面查看效果

![image-20230411083436201](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411083436201.png)

2. 可以正常拿到数据，但是展示的时候有个小 bug，最后一个用户展示不完全

![image-20230411083523283](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411083523283.png)

3. 修改一下布局

```css
#content {
  padding-bottom: 50px;
}
```

![image-20230411083947484](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411083947484.png)

#### 4. 优化

我们在搜索结果页面和主页面都使用到了 `van-card` 这个组件，且十分的相似，因此我们可以将这个组件抽取为一个公共组件

1. 在 `components` 文件夹下新建 `UserCardList` 组件

![image-20230411084951706](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411084951706.png)

2. 编写公共组件

```vue
<template>
  <van-card
      v-for="user in props.userList"
      :desc="user.profile"
      :title="`${user.username} (${user.planetCode})`"
      :thumb="user.avatarUrl"
  >
    <template #tags>
      <van-tag plain type="primary" v-for="tag in user.tags" style="margin-right: 8px; margin-top: 8px">
        {{tag}}
      </van-tag>
    </template>
    <template #footer>
      <van-button size="mini">联系我</van-button>
    </template>
  </van-card>
</template>

<script setup lang="ts">

import {UserType} from "../models/user";

interface UserCardListProps {
  userList: UserType[];
}

const props = defineProps<UserCardListProps>();

</script>

<style scoped>

</style>
```

3. 将之前 `index` 和 `searchresult` 页面中的卡片组件替换成公共组件

![image-20230411085524408](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411085524408.png)

## 分布式session登录

种 session 的时候注意范围，cookie.domian

```yaml
    session:
      cookie:
        domain: 
```

![image-20230409191958011](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230409191958011.png)

比如两个域名：

aaa.yuipi.com

bbb.yupi.com

如果要共享 cookie，可以种一个更高层的公共域名，比如 yupi.com

**为什么服务器 A 登录后，请求发到服务器 B，不认识该用户？**

用户在 A 登录，所以 session （用户登录信息）存在了 A 上

结果请求 B 时，B 没有用户信息，所以不认识

![image.png](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/1669261508769-827a7a9d-0154-4ba8-835e-5532469c96a6.png)

解决方案：**共享存储**，而不是把数据放到单台服务器的内存中

![image.png](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/1669261508796-2a7e4371-9ad7-466a-9e8b-533fb6679221.png)

### session 共享实现 Redis

如何共享存储？

1. Redis（基于内存的 K / V 数据库）【此处使用 Redis：因为用户信息读取 / 是否登录的判断及其**频繁**，Redis 基于内存，读写性能很高，简单的数据单机 qps 5w - 10w】
2. MySQL
3. 文件服务器 each

#### 1. 下载安装 redis

官网：[Redis](https://redis.io/)

Redis 5.0.14 下载：

链接：https://pan.baidu.com/s/1XcsAIrdeesQAyQU2lE3cOg

提取码：vkoi 

redis 管理工具 quick redis：[QuickOfficial - QuickRedis (quick123.net)](https://quick123.net/)

#### 2. 整合 redis

1. 引入 redis，能够操作 redis

> redis 的版本一定要和 springboot 的版本一致

```xml
  <!-- redis -->
        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
            <version>2.6.4</version>
        </dependency>
```

2. redis 配置

```yaml
#redis
redis:
  port: 6379
  host: localhost
  database: 0
```

3. 引入 spring-session 和 redis 的整合，使得自动将 session 存储到 redis 中

```xml
 <!-- session-data-redis -->
        <!-- https://mvnrepository.com/artifact/org.springframework.session/spring-session-data-redis -->
        <dependency>
            <groupId>org.springframework.session</groupId>
            <artifactId>spring-session-data-redis</artifactId>
            <version>2.6.3</version>
        </dependency>
```

4. 修改 session 的配置

> 存储配置 spring.session.store-type
>
> 默认是 none，表示存储在单台服务器
>
> store-type: redis，表示从 redis 读写 session

```yaml
  session:
    timeout: 86400
    store-type: redis
```

#### 3. 测试

1. 使用 quickredis 连接 redis

![image-20230409201837638](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230409201837638.png)

2. 登录测试一下

![image-20230409201930065](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230409201930065.png)

3. 去 quickredis 中查看一下

> 可以看到成功将 cookie 存储到 redis 中了
>
> 看不懂存的什么？正常，因为这是 java 序列化之后存储的

![image-20230409202016076](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230409202016076.png)

4. 测试一下是否可以获取当前登录态

![image-20230409202129604](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230409202129604.png)



## 模拟千万用户

### 一、数据导入

#### 1. 可视化界面

![image-20230411091059903](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411091059903.png)

#### 2. sql语句

```sql
insert into MY_TABLE (id, first_name, last_name, birth) values (10001, 'Georgi', 'Facello', 'M');
insert into MY_TABLE (id, first_name, last_name, birth) values (10002, 'Bezalel', 'Simmel', 'F');
insert into MY_TABLE (id, first_name, last_name, birth) values (10003, 'Parto', 'Bamford', 'M');
insert into MY_TABLE (id, first_name, last_name, birth) values (10004, 'Chirstian', 'Koblick', 'M');
insert into MY_TABLE (id, first_name, last_name, birth) values (10005, 'Kyoichi', 'Maliniak', 'M');
insert into MY_TABLE (id, first_name, last_name, birth) values (10006, 'Anneke', 'Preusig', 'F');
insert into MY_TABLE (id, first_name, last_name, birth) values (10007, 'Tzvetan', 'Zielinski', 'F');
insert into MY_TABLE (id, first_name, last_name, birth) values (10008, 'Saniya', 'Kalloufi', 'M');
insert into MY_TABLE (id, first_name, last_name, birth) values (10009, 'Sumant', 'Peac', 'F');
insert into MY_TABLE (id, first_name, last_name, birth) values (10010, 'Duangkaew', 'Piveteau', 'F');

```

#### 2. 写程序

for 循环，建议分批，不要一把梭哈（可以用接口控制）**要保证可控**

### 二、定时任务

#### 1. 开启定时任务

直接使用 springboot 注解开始定时任务

```java
@EnableScheduling
```

![image-20230411094542832](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411094542832.png)

#### 2. 编写一次性任务

1. 新建一个 `InsertUser` 方法

![image-20230411094716936](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411094716936.png)

2. 添加 `Component` 注解

![image-20230411094822923](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411094822923.png)

3. 编写相关代码

```java
package com.example.usercenterbackendmaster.easyExcel;

import com.example.usercenterbackendmaster.mapper.UserMapper;
import com.example.usercenterbackendmaster.model.domain.User;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import org.springframework.util.StopWatch;

import javax.annotation.Resource;

/**
 * @author dell
 * @date 2023/4/11 9:47
 */

@Component
public class InsertUsers {

    @Resource
    private UserMapper userMapper;

    @Scheduled(initialDelay = 5000,fixedRate = Long.MAX_VALUE )
    public void doInsertUser() {
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        final int INSERT_NUM = 1000;
        for (int i = 0; i < INSERT_NUM; i++) {
            User user = new User();
            user.setUsername("假用户");
            user.setUserAccount("fakeUser");
            user.setAvatarUrl("https://p.qqan.com/up/2021-8/16280413188390471.jpg");
            user.setProfile("一条咸鱼");
            user.setGender(0);
            user.setUserPassword("12345678");
            user.setPhone("123456789108");
            user.setEmail("2586844575@qq.com");
            user.setUserStatus(0);
            user.setUserRole(0);
            user.setPlanetCode("931");
            user.setTags("[]");
            userMapper.insert(user);
        }
        stopWatch.stop();
        System.out.println( stopWatch.getLastTaskTimeMillis());

    }

}
```

### 三、数据插入

新建单元测试 `InsertUserTest.java`，并将刚刚的爱慕复制过来

> **用户插入单元测试，注意打包时要删掉欧哲忽略，不然打包一次就插入一次！！！**

![image-20230411101507338](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411101507338.png)

#### 1. for循环插入

```java
    /**
     * for循环插入
     */
    @Test
    public void doInsertUser1() {
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        final int INSERT_NUM = 1000;
        for (int i = 0; i < INSERT_NUM; i++) {
            User user = new User();
            user.setUsername("假用户");
            user.setUserAccount("fakeUser");
            user.setAvatarUrl("https://p.qqan.com/up/2021-8/16280413188390471.jpg");
            user.setProfile("一条咸鱼");
            user.setGender(0);
            user.setUserPassword("12345678");
            user.setPhone("123456789108");
            user.setEmail("2586844575@qq.com");
            user.setUserStatus(0);
            user.setUserRole(0);
            user.setPlanetCode("931");
            user.setTags("[]");
            userMapper.insert(user);
        }
        stopWatch.stop();
        System.out.println( stopWatch.getLastTaskTimeMillis());

    }
```

![image-20230411102059975](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411102059975.png)

for 循环插入数据的问题

1. 每次插入数据都要建立和释放数据库链接
2. for 循环是绝对线性的

#### 2. 批量插入

> 解决了**每次插入数据都要建立和释放数据库链接**

mybatis-plus 帮我们实现了批量插入

```java
    /**
     * 批量插入
     */
    @Test
    public void doInsertUser2() {
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        final int INSERT_NUM = 1000;
        List<User> userList = new ArrayList<>();
        for (int i = 0; i < INSERT_NUM; i++) {
            User user = new User();
            user.setUsername("假用户");
            user.setUserAccount("fakeUser");
            user.setAvatarUrl("https://p.qqan.com/up/2021-8/16280413188390471.jpg");
            user.setProfile("一条咸鱼");
            user.setGender(0);
            user.setUserPassword("12345678");
            user.setPhone("123456789108");
            user.setEmail("2586844575@qq.com");
            user.setUserStatus(0);
            user.setUserRole(0);
            user.setPlanetCode("931");
            user.setTags("[]");
            userList.add(user);
        }
        userService.saveBatch(userList);
        stopWatch.stop();
        System.out.println( stopWatch.getLastTaskTimeMillis());

    }
```

> 10个为一批进行插入，每插入10个建立和断开一次链接

![image-20230411103023043](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411103023043.png)

#### 3. 并发插入

> 解决了**for循环是绝对线性的**



并发插入（这里数据量是100000）

并发要注意执行的先后顺序无所谓，不要用到非并发类的集合

```java
private ExecutorService executorService = new ThreadPoolExecutor(16, 1000, 10000, TimeUnit.MINUTES, new ArrayBlockingQueue<>(10000));
```

// CPU 密集型：分配的核心线程数 = CPU - 1

// IO 密集型：分配的核心线程数可以大于 CPU 核数

```java
	    //线程设置
    private ExecutorService executorService = new ThreadPoolExecutor(16, 1000, 10000, TimeUnit.MINUTES, new ArrayBlockingQueue<>(10000));


	/**
     * 并发批量插入
     */
    @Test
    public void doInsertUser3() {
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        final int INSERT_NUM = 100000;
        // 分十组
        int j = 0;
        //批量插入数据的大小
        int batchSize = 5000;
        List<CompletableFuture<Void>> futureList = new ArrayList<>();
        // i 要根据数据量和插入批量来计算需要循环的次数。（鱼皮这里直接取了个值，会有问题,我这里随便写的）
        for (int i = 0; i < INSERT_NUM/batchSize; i++) {
            List<User> userList = new ArrayList<>();
            while (true){
                j++;
                User user = new User();
                user.setUsername("假用户");
                user.setUserAccount("fakeUser");
                user.setAvatarUrl("https://p.qqan.com/up/2021-8/16280413188390471.jpg");
                user.setProfile("一条咸鱼");
                user.setGender(0);
                user.setUserPassword("12345678");
                user.setPhone("123456789108");
                user.setEmail("2586844575@qq.com");
                user.setUserStatus(0);
                user.setUserRole(0);
                user.setPlanetCode("931");
                user.setTags("[]");
                userList.add(user);
                if (j % batchSize == 0 ){
                    break;
                }
            }
            //异步执行
            CompletableFuture<Void> future = CompletableFuture.runAsync(() ->{
                System.out.println("ThreadName：" + Thread.currentThread().getName());
                userService.saveBatch(userList,batchSize);
            },executorService);
            futureList.add(future);
        }
        CompletableFuture.allOf(futureList.toArray(new CompletableFuture[]{})).join();

        stopWatch.stop();
        System.out.println( stopWatch.getLastTaskTimeMillis());

    }
```

![image-20230411104155464](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411104155464.png)



### 四、分页查询

#### 1. 重启项目

刷新前端页面，查询时间 9s，且查询完后，并没有在页面上展示出来（因为数据量太大了）

![image-20230411110947803](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411110947803.png)

直接崩溃掉了....

![image-20230411111943162](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411111943162.png)

#### 2. 使用分页查询

[插件主体 | MyBatis-Plus (baomidou.com)](https://baomidou.com/pages/2976a3/#spring-boot)

1. 添加 mybatis-plus 分页的拦截器

```java
@Configuration
@MapperScan("scan.your.mapper.package")
public class MybatisPlusConfig {

    /**
     * 新的分页插件,一缓和二缓遵循mybatis的规则,需要设置 MybatisConfiguration#useDeprecatedExecutor = false 避免缓存出现问题(该属性会在旧插件移除后一同移除)
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.H2));
        return interceptor;
    }

    @Bean
    public ConfigurationCustomizer configurationCustomizer() {
        return configuration -> configuration.setUseDeprecatedExecutor(false);
    }
}
```

2. 复制到我们的 `config` 文件夹下

```java
package com.example.usercenterbackendmaster.config;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.autoconfigure.ConfigurationCustomizer;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@MapperScan("com.example.usercenterbackendmaster.mapper")
public class MybatisPlusConfig {

    /**
     * 新的分页插件,一缓和二缓遵循mybatis的规则,需要设置 MybatisConfiguration#useDeprecatedExecutor = false 避免缓存出现问题(该属性会在旧插件移除后一同移除)
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return interceptor;
    }

}
```

![image-20230411111305125](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411111305125.png)

3. 修改 `controller` 层的 `recommend` 方法（改为分页查询）

```java
/**
 * 首页推荐（分页查询）
 * @param request 用户登录信息
 * @return
 */
@GetMapping("/recommend")
public BaseResponse<Page<User>> recommendUsers(long pageSize, long pageNum, HttpServletRequest request) {
    QueryWrapper<User> queryWrapper = new QueryWrapper<>();
    Page<User> userList = userService.page(new Page<>(pageNum, pageSize), queryWrapper);
    return ResultUtils.success(userList);
}
```

4. 对应的前端也进行修改

![image-20230411111726467](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411111726467.png)

5. 运行测试

![image-20230411112011404](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411112011404.png)

## 缓存迅速查询

### 一、数据查询满怎么办？

用缓存：提前把数据取出来保存好（通常保存到读写更快的介质，比如内存），就可以更快的读写。

#### 1. 缓存的实现

- Redis（分布式缓存）
- memcached（分布式）
- Etcd（云原生架构的一个分布式存储，**存储配置**，扩容能力）
- ehcache（单机）
- 本地缓存（Java 内存 Map）
- Caffeine（Java 内存缓存，高性能）
- Google Guava

#### 2. Redis

> NoSQL 数据库

key-value 存储系统（区别与 MySql，redis 存储的是键值对）

**Redis 数据结构**

String 字符串类型：name: “yupi”

List 列表：names: [“yupi”, “dogyupi”, “yupi”]

Set 集合：names: [“yupi”, “dogyupi”]（值不能重复）

Hash 哈希：nameAge: {“yupi”: 1, “dogyupi”: 2}

Zset 集合：names: { yupi - 9, dogyupi - 12} （适合做排行榜）



bloomfilter（布隆过滤器，主要从大量的数据中快速过滤值，比如邮件黑名单拦截）

geo（计算地理位置）

hyperloglog（pv / uv）

pub / sub（发布订阅，类似消息队列）

BitMap（1000100101010100100101010101）

### 二、Java里的实现方式

#### 1. 分类

- **Spring Data Redis（推荐）**

- **Spring Data**
  - 通用的数据访问框架，定义了一组增删改查的接口，mysql、redis、jps...
- Jedis
  - 独立于 spring 操作 redis 的 java 客户端，要配合 jedis Pool 使用
- Lettuce
  - **高阶**的操作 Redis 的 Java 客户端
  - 异步、连接池
- Redisson
  - 分布式操作 Redis 的 Java 客户端，让你像在本地的集合一样操作 redis（分布式 redis 数据网格）

#### 2. 对比

1. 如果你用的是 spring，并且没有过多的定制化要求，可以使用 Spring Data Redis，最方便
2. 如果你用的不是 Spring，并且追求简单，并且没有过高的性能要求，可以用 Jedis + Jedis Pool
3. 如果你的项目不是 Spring，并且追求高性能、高定制化，可以用 Lettuce，支持异步、连接池
4. 如果你的项目是分布式的，需要用到一些分布式的特性（比如分布式锁、分布式集合），推荐用 redisson

### 三、Redis整合测试

#### 1. 引入

1. xml 依赖

```xml
       <!-- redis -->
        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
            <version>2.6.4</version>
        </dependency>
```

2. yaml 配置

```yaml
  #redis
  redis:
    port: 6379
    host: localhost
    database: 0
```

#### 2. 测试

1. 新建一个测试类 `RedisTest.java`

![image-20230411164053701](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411164053701.png)

2. 编写测试类代码

```java
package com.example.usercenterbackendmaster;

import com.example.usercenterbackendmaster.model.domain.User;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.ValueOperations;

import javax.annotation.Resource;

/**
 * @author dell
 * @date 2023/4/11 16:40
 */

@SpringBootTest
public class RedisTest {

    @Resource
    private RedisTemplate redisTemplate;

    @Test
    void test() {
        ValueOperations valueOperations = redisTemplate.opsForValue();
        // 增
        valueOperations.set("shayuString", "fish");
        valueOperations.set("shayuInt", 1);
        valueOperations.set("shayuDouble", 2.0);
        User user = new User();
        user.setId(1L);
        user.setUsername("shayu");
        valueOperations.set("shayuUser", user);

        // 查
        Object shayu = valueOperations.get("shayuString");
        Assertions.assertTrue("fish".equals((String) shayu));
        shayu = valueOperations.get("shayuInt");
        Assertions.assertTrue(1 == (Integer) shayu);
        shayu = valueOperations.get("shayuDouble");
        Assertions.assertTrue(2.0 == (Double) shayu);
        System.out.println(valueOperations.get("shayuUser"));
        valueOperations.set("shayuString", "fish");

        //删
//        redisTemplate.delete("shayuString");
    }

}
```

3. 配置序列化

```java
package com.example.usercenterbackendmaster.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializer;

@Configuration
public class RedisTemplateConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
        //创建RedisTemplate对象
        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();
       //设置连接工厂
        redisTemplate.setConnectionFactory(connectionFactory);
        //设置Key的序列化
        redisTemplate.setKeySerializer(RedisSerializer.string());

        //创建Json序列化工具
        GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer();
        //设置Value的序列化
        redisTemplate.setValueSerializer(jsonRedisSerializer);

        return redisTemplate;
    }
}
```

4. 进入 QuickRedis 查看

![image-20230411171604977](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230411171604977.png)

### 四、数据缓存

#### 1. 设计缓存key

不同用户看到的数据不同

`systemId:moduleId:func:options`（不要和别人冲突）

`matchup:user:recommend:userId`

**redis 内存不能无限增加，一定要设置过期时间！！！**

#### 2. 修改主页推荐接口

```java
    /**
     * 首页推荐（分页查询）
     * @param request 用户登录信息
     * @return
     */
    @GetMapping("/recommend")
    public BaseResponse<Page<User>> recommendUsers(long pageSize, long pageNum, HttpServletRequest request) {
        User loginUser = userService.getLoginUser(request);
        String redisKey = String.format("matchup:user:recommend%s", loginUser.getId());
        ValueOperations valueOperations = redisTemplate.opsForValue();
        // 如果有缓存，直接读取
        Page<User> userPage = (Page<User>) valueOperations.get(redisKey);
        if (userPage != null) {
            return ResultUtils.success(userPage);
        }
        // 无缓存，查数据库
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        userPage = userService.page(new Page<>(pageNum, pageSize), queryWrapper);
        // 写缓存，10s过期
        try {
            valueOperations.set(redisKey, userPage, 30000, TimeUnit.MILLISECONDS);
        } catch (Exception e) {
            log.error("redis set key error", e);
        }
        return ResultUtils.success(userPage);
    }
```

#### 3. 测试一下

1. 刷新主页面，查看第一次加载时间

![image-20230412115946611](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230412115946611.png)

2. 再次刷新，查看时间

![image-20230412120004545](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230412120004545.png)

很明显，有一个质的提升

3. 去 quickredis 中查看一下 redis 缓存

![image-20230412120110454](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230412120110454.png)

### 五、缓存预热

**问题：**第一个用户访问还是很慢，例如双十一时，大量用户第一次访问，都要读数据库，会直接崩掉，因此缓存预热可以一定程度上保护数据库

**缓存预热的优点：**

1. 解决上面的问题，可以让用户始终访问很快

**缺点：**

1. 增加开发成本（额外的开发，设计）
2. 预热的时机和时间，如果错了，可能缓存的数据不对
3. 需要占用空间

#### 1. 怎么缓存预热

1. 定时触发
2. 模拟触发（手动触发）

**实现**

用定时任务，每天刷新所有用户的推荐列表

注意点：

1. 缓存预热的意义（新增少，总用户多）
2. 缓存的空间不能太大，要预留其他缓存的空间
3. 缓存数据的周期（一天一次）

#### 2. 定时任务实现

> 1. Spring Scheduler（springboot 默认整合了）
> 2. Quartz（独立于 spring 存在的定时任务框架）
> 3. XXL-Job 之类的分布式任务调度平台
>
> 第一种方式：
>
> 1. 主类开启 `@EnableScheduling`
> 2. 给要定时执行的方法添加 `@EnableScheduling ` 注解，指定 corn 表达式或执行频率

1. 新建一个 `job` 文件夹

![image-20230412222207023](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230412222207023.png)

2. 在该文件夹下新建一个 `PreCacheJob` 文件

![image-20230412222427243](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230412222427243.png)

3. corn 表达式

[在线Cron表达式生成器 (qqe2.com)](https://cron.qqe2.com/)

4. 编写代码

```java
package com.example.usercenterbackendmaster.job;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.example.usercenterbackendmaster.mapper.UserMapper;
import com.example.usercenterbackendmaster.model.domain.User;
import com.example.usercenterbackendmaster.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * @author dell
 * @date 2023/4/12 22:24
 */

@Component
@Slf4j
public class PreCacheJob {

    @Resource
    private UserService userService;

    @Resource
    private RedisTemplate<String, Object> redisTemplate;

    // 动态用户
    private List<Long> mainUserList = Arrays.asList(1L);

    @Scheduled(cron = "0 47 22 * * * ")
    public void doCacheRecommendUser() {
        for (Long userId : mainUserList) {
            QueryWrapper<User> queryWrapper = new QueryWrapper<>();
            Page<User> userPage = userService.page(new Page<>(1, 20), queryWrapper);
            String redisKey = String.format("matchup:user:recommend%s", userId);
            ValueOperations<String, Object> valueOperations = redisTemplate.opsForValue();
            try {
                valueOperations.set(redisKey, userPage, 30000, TimeUnit.MILLISECONDS);
            } catch (Exception e) {
                log.error("redis set key error", e);
            }
        }
    }

}
```

5. 测试一下

![image-20230412224732261](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230412224732261.png)

执行完使用 quickredis 查看是否添加了缓存

![image-20230412224905844](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230412224905844.png)

## 锁和分布式锁

### 一、背景

我们上次实现了缓存预热，但是缓存是存在一台服务器上，那如果项目是部署在多台服务器上呢？

![image-20230413084533553](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230413084533553.png)

#### 1. 控制定时任务的执行（为啥？）

1. 浪费资源，想象 10000 台服务器同时 “打鸣”
2. 脏数据，比如重复插入

#### 2. 控制定时任务在同一时间只有 1 个服务器执行（怎么做？）

1. 分离定时任务程序和主程序，只在 1 个服务器运行定时任务。成本太大

2. **写死配置**，每个服务器都执行定时任务，但是只有 ip 符合配置的服务器才真实执行业务逻辑，其他的直接返回。成本最低。但是我们的 ip 可能不是不固定的，把 ip 写的太死了

3. **动态配置**，配置是可以轻松的、很方便地更新的，但是只有 ip 符合配置的服务器才真实执行业务逻辑。

   - 数据库
   - Redis
   - 配置中心（Nacos、Apollo、Spring Cloud Config）

   问题：服务器多了、IP 不可控还是很麻烦，还是要人工修改

4. **分布式锁**，只有抢到锁的服务器才能执行业务逻辑。

   坏处：增加成本

   好处：不用手动配置，多少个服务器都一样

### 二、锁

有限资源的情况下，控制同一时间（段）只有某些线程（用户/服务器）能访问到资源。

Java 实现锁：synchronized 关键字、并发包的类

问题：只对单个 JVM 有效

### 三、分布式锁

#### 1. 为什么需要分布式锁

1. 有限资源的情况下，控制同一时间（段）只有某些线程（用户/服务器）能访问到资源。
2. 单个锁只对单个 JVM 有效

[【分布式锁】三种分布式锁的实现【原创】_分布式锁的三种实现方式_jiandanokok的博客-CSDN博客](https://blog.csdn.net/jiandanokok/article/details/114296755?ops_request_misc=%7B%22request%5Fid%22%3A%22167189130116782425179973%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=167189130116782425179973&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114296755-null-null.142^v68^control,201^v4^add_ask,213^v2^t3_control2&utm_term=分布式锁&spm=1018.2226.3001.4187)

[什么是分布式锁？几种分布式锁分别是怎么实现的？_Java后端架构猛猛的博客-CSDN博客](https://blog.csdn.net/m0_67645544/article/details/124768505?ops_request_misc=%7B%22request%5Fid%22%3A%22167189130116782425179973%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=167189130116782425179973&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-124768505-null-null.142^v68^control,201^v4^add_ask,213^v2^t3_control2&utm_term=分布式锁&spm=1018.2226.3001.4187)

#### 2. 分布式锁实现的关键

##### (1) 抢锁机制

怎么保证同一时间只有 1 个服务器能抢到锁？

**核心思想**就是：先来的人把数据改成自己的标识（服务器ip）后来的人发现标识已经存在，就抢锁失败，继续等待。

等先来的人执行方法结束，把标识清空，其他人继续抢锁。

MySQL数据库：`select for update` 行级锁（最简单）

（乐观锁）

✔️Redis实现：内不吃你数据库，读写速度快。支持 **setnx**、lua 脚本，比较方便我们实现分布式锁。

> **setnx**：set if not exists 如果不存在，则设置；只有设置成功才会返回 true，否则返回 false。
>
> ![image-20230413092552642](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230413092552642.png)

Zookeeper实现

##### (2) 注意事项

1. 用完锁要释放

2. **锁一定要加过期时间**（防止服务器挂掉，锁不被释放掉）

3. 如果方法执行时间过长，锁提前过期了，

   问题：

   - 这样还是会存在多个方法同时执行的情况
   - 连锁效应：释放掉别人的锁

   解决方案：

   - 续期

   ```java
   boolean end = false;
   
   //线程
   new Thread(() -> {
       //判断状态
       if (!end)}{
           续期
       })
   
       end = true;
   ```

   

4. 释放锁的时候，有可能先判断出是自己的锁，但这时锁过期了，最好还释放了别人的锁

```shell
// 原子操作
if(get lock == A) {
    // set lock B
    del lock
}
```

Redis + lua 脚本

5. Redis 如果是集群（而不是只有一个 Redis），如果分布式锁的数据不同步怎么办？

Redis + lua 脚本实现

[Redisson--红锁(Redlock)--使用/原理_IT利刃出鞘的博客-CSDN博客](https://blog.csdn.net/feiying0canglang/article/details/113258494)

### 四、Redisson实现分布式锁

#### 1. Redisson概述

Java 客户端，数据网格

实现了很多 Java 里支持的 API 和数据结构

Redisson 是一个 java 操作 Redis 的客户端，**提供了大量的分布式数据集来简化对 Redis 的操作和使用，可以让开发者像使用本地集合一样使用 Redis，完全感知不到 Redis 的存在。**

[redisson/redisson: Redisson - Easy Redis Java client with features of In-Memory Data Grid. Over 50 Redis based Java objects and services: Set, Multimap, SortedSet, Map, List, Queue, Deque, Semaphore, Lock, AtomicLong, Map Reduce, Publish / Subscribe, Bloom filter, Spring Cache, Tomcat, Scheduler, JCache API, Hibernate, MyBatis, RPC, local cache ... (github.com)](https://github.com/redisson/redisson)

> 1. spring boot starter 引入（不推荐，版本迭代太快，容易冲突）
>
> [redisson/redisson-spring-boot-starter at master · redisson/redisson (github.com)](https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter)
>
> 2. 直接引入

#### 2. Quick start

1. 添加依赖

```xml
        <!-- https://github.com/redisson/redisson#quick-start -->
        <dependency>
            <groupId>org.redisson</groupId>
            <artifactId>redisson</artifactId>
            <version>3.19.1</version>
        </dependency>
```

2. 编写 `RedissonConfig` 文件

```java
package com.example.usercenterbackendmaster.config;

import lombok.Data;
import org.redisson.Redisson;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

/**
 * @author dell
 * @date 2023/4/13 10:24
 * Redisson 配置
 */

@Configuration
@ConfigurationProperties(prefix = "spring.redis")
@Data
public class RedissonConfig {

    private String host;
    private String port;

    @Bean
    public RedissonClient redissonClient() {
        // 1.快速创建配置
        Config config = new Config();
        String redisAddress = String.format("redis://%s:%s", host, port);
        // useSingleServer(): 使用单个 redis
        // useClusterServers(): 使用集群 redis
        config.useSingleServer().setAddress(redisAddress).setDatabase(3);
        // 2. 创建实例
        RedissonClient redissonClient = Redisson.create(config);
        return redissonClient;
    }

}
```

3. 测试

```java
package com.example.usercenterbackendmaster;

import org.junit.jupiter.api.Test;
import org.redisson.api.RList;
import org.redisson.api.RMap;
import org.redisson.api.RedissonClient;
import org.springframework.boot.test.context.SpringBootTest;

import javax.annotation.Resource;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * @author dell
 * @date 2023/4/13 10:47
 */

@SpringBootTest
public class RedissonTest {

    @Resource
    private RedissonClient redissonClient;

    @Test
    void test() {
        // list，数据存在本地 JVM 内存中
        List<String> list = new ArrayList<>();
        list.add("yupi");
        System.out.println("list:" + list.get(0));

        list.remove(0);

        // 数据存在 redis 的内存中
        RList<String> rList = redissonClient.getList("test-list");
        rList.add("yupi");
        System.out.println("rlist:" + rList.get(0));
        rList.remove(0);

        // map
        Map<String, Integer> map = new HashMap<>();
        map.put("yupi", 10);
        map.get("yupi");

        RMap<Object, Object> map1 = redissonClient.getMap("test-map");

        // set

        // stack


    }

}

```

#### 3. 分布式锁实现

1. waitTime 设置为 0，只抢一次，抢不到就放弃
2. 注意释放锁要卸载 finally 中

```java
package com.example.usercenterbackendmaster.job;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.example.usercenterbackendmaster.mapper.UserMapper;
import com.example.usercenterbackendmaster.model.domain.User;
import com.example.usercenterbackendmaster.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.redisson.api.RLock;
import org.redisson.api.RedissonClient;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * @author dell
 * @date 2023/4/12 22:24
 */

@Component
@Slf4j
public class PreCacheJob {

    @Resource
    private UserService userService;

    @Resource
    private RedisTemplate<String, Object> redisTemplate;

    @Resource
    private RedissonClient redissonClient;

    // 动态用户
    private List<Long> mainUserList = Arrays.asList(1L);

    @Scheduled(cron = "0 47 22 * * * ")
    public void doCacheRecommendUser() {
        RLock lock = redissonClient.getLock("matchup:precachejob:docache:lock");
        try {
            // 只有一个线程能获取到锁
            if (lock.tryLock(0, 30000, TimeUnit.MILLISECONDS)) {
                for (Long userId : mainUserList) {
                    QueryWrapper<User> queryWrapper = new QueryWrapper<>();
                    Page<User> userPage = userService.page(new Page<>(1, 20), queryWrapper);
                    String redisKey = String.format("matchup:user:recommend%s", userId);
                    ValueOperations<String, Object> valueOperations = redisTemplate.opsForValue();
                    try {
                        valueOperations.set(redisKey, userPage, 30000, TimeUnit.MILLISECONDS);
                    } catch (Exception e) {
                        log.error("redis set key error", e);
                    }
                }
            }
        } catch (InterruptedException e) {
            log.error("doCacheRecommendUser error", e);
        } finally {
            // 只能释放自己的锁
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }

}
```

#### 4. 测试

测试一下分布式，三个服务程序争抢锁

（提醒：我们这里是用定时任务触发抢锁，所以定时任务时间先设定好，大概延后几分钟就行，下面的操作包括	设定定时任务时间---打包---启动三个服务---到时间抢锁其中一个服务抢到锁控制台回馈）

在使用Java命令设置端口启动项目。

```
java -jar .\user-center-backend-0.0.1-SNAPSHOT.jar --server.port=8080
```

（8081端口）；开启三个服务。

![image-20230413195945296](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230413195945296.png)

第三个程序抢到了锁

![image-20230413201126040](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230413201126040.png)

#### 5. 看门狗机制（逾期问题）

> redisson 默认集成了看门狗机制，只需要将 unit 时间指定为 -1 即可
>
> ![image-20230413203725236](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230413203725236.png)

开启一个监听线程，如果方法还没执行完，就帮你重置 redis 锁的过期时间。

原理：

1. 监听当前线程，默认过期时间是 30 秒，每 10 秒续期一次（补到 30 秒）
2. 如果线程挂掉（注意 debug 模式下断点也会被当成服务器宕机），则不会续期

[Redisson 分布式锁的watch dog自动续期机制_redisson 续期_zhifeng687的博客-CSDN博客](https://blog.csdn.net/qq_26222859/article/details/79645203)

### 思考

Redisson 和 spring-data-redis 的区别？

[redission_小白要变大牛的博客-CSDN博客](https://blog.csdn.net/hnhroot/article/details/126296921?ops_request_misc=%7B%22request%5Fid%22%3A%22167498413116800180663057%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=167498413116800180663057&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-126296921-null-null.142^v71^one_line,201^v4^add_ask&utm_term=Redission的&spm=1018.2226.3001.4187)

[spring-data-redis概述及用法_spring data redis_jsxllht的博客-CSDN博客](https://blog.csdn.net/weixin_56219549/article/details/119484442?ops_request_misc=&request_id=&biz_id=102&utm_term=spring-data-redis和Redission的&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-119484442.142^v71^one_line,201^v4^add_ask&spm=1018.2226.3001.4187)

## 组队功能开发

### 一、需求分析

用户可以**创建**一个队伍，设置队伍人数、队伍名称（标题）、描述、超时时间

1. 队长、剩余的人数
2. 聊天？
3. 公开或 private 或加密
4. 用户创建队伍最多 5 个

展示队伍列表，根据名称搜索队伍，信息流中不展示已过期的队伍

修改队伍信息

用户可以加入队伍（其他人、未满、未过期），允许加入多个队伍，但是要有个上限

是否需要队长同意？筛选审批？

用户可以退出队伍（如果队长退出，权限转移给第二早加入的用户 ---- 先来后到）

队长可以解散队伍

分享队伍 => 邀请其他用户加入队伍

业务流程：

1. 生成分享链接（分享二维码）
2. 用户访问链接，可以点击加入

队伍人满后发送消息通知

### 二、数据库表设计

#### 1. 队伍表

队伍表 team

字段：

- id 主键 bigint（最简单、连续，放 url 上比较简短，但缺点是爬虫）
- name 队伍名称
- description 描述
- maxNum 最大人数
- expireTime 过期时间
- userId 创建人 id
- status 0 - 公开，1 - 私有，2 - 加密
- password 密码
- createTime 创建时间
- updateTime 更新时间
- isDelete 是否删除

```mysql
create table team
(
  id           bigint auto_increment comment 'id'
  primary key,
  name   varchar(256)                   not null comment '队伍名称',
  description varchar(1024)                      null comment '描述',
  maxNum    int      default 1                 not null comment '最大人数',
  expireTime    datetime  null comment '过期时间',
  userId            bigint comment '用户id',
  status    int      default 0                 not null comment '0 - 公开，1 - 私有，2 - 加密',
  password varchar(512)                       null comment '密码',

  createTime   datetime default CURRENT_TIMESTAMP null comment '创建时间',
  updateTime   datetime default CURRENT_TIMESTAMP null on update CURRENT_TIMESTAMP,
  isDelete     tinyint  default 0                 not null comment '是否删除'
)
comment '队伍';
```

#### 2. 用户-队伍表

两个关系：

1. 用户加了哪些队伍？
2. 队伍有哪些用户？



方式：

1. 建立用户 - 队伍关系表 teamId userId（便于修改，查询性能高一点，可以选择这个，不用全表遍历）
2. 用户表补充已加入的队伍字段，队伍表补充已加入的用户字段（便于查询，不用写多对多的代码，可以直接根据队伍查用户、根据用户查队伍）



用户 - 队伍表 user_team

字段：

- id 主键
- userId 用户 id
- teamId 队伍 id
- joinTime 加入时间
- createTime 创建时间
- updateTime 更新时间
- isDelete 是否删除

```mysql
create table user_team
(
    id           bigint auto_increment comment 'id'
        primary key,
    userId            bigint comment '用户id',
    teamId            bigint comment '队伍id',
    joinTime datetime  null comment '加入时间',
    createTime   datetime default CURRENT_TIMESTAMP null comment '创建时间',
    updateTime   datetime default CURRENT_TIMESTAMP null on update CURRENT_TIMESTAMP,
    isDelete     tinyint  default 0                 not null comment '是否删除'
)
    comment '用户队伍关系';
```

#### 3. 使用mybatis-plus生成代码

1. team表

![image-20230413221051069](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230413221051069.png)

2. user_team表

![image-20230413222250887](https://fickler-1314393782.cos.ap-beijing.myqcloud.com/img/image-20230413222250887.png)

> 将生成好的代码移动到对应的文件目录下
>
> 不要忘记给逻辑删除字段添加 `@TableLogic` 注解

