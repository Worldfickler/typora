# 伙伴匹配系统

## 需求分析

1. 用户去添加标签，标签的分类（要有哪些标签、怎么把标签进行分类）
2. 主动搜索：允许用户根据标签去搜索其他用户（Redis 缓存）
3. 组队
   1. 创建队伍
   2. 加入队伍
   3. 根据标签查询队伍
   4. 邀请其他人
4. 允许用户去修改标签
5. 推荐（相似度计算算法 + 本地分布式计算）

## 技术栈

前端：

	1. Vue3 开发框架（提高页面开发的效率）
	1. Vant UI（基于 Vue 的移动端组件库）（React 版 Zent）
	1. Vite（打包工具，快！）
	1. Nginx 来单机部署

后端：

	1. Java + SpringBoot
	1. SpringMVC + MyBatis + MyBatis-Plus
	1. MySQL 数据库
	1. Redis 缓存
	1. Swagger + Knife4j 接口文档

## 前端初始化

### 一、前端项目初始化

> 用脚手架初始化项目
>
> - Vue CLI
> - Vite 脚手架

#### 1. 使用脚手架初始化项目

1. 先看一下 Vite 的官网

![image-20230330085150712](http://qiniu.fickler.top/img/image-20230330085150712.png)

2. 搭建第一个 Vite 项目

![image-20230330085245637](http://qiniu.fickler.top/img/image-20230330085245637.png)

3. 新建一个文件夹，进入后调出 cmd

![image-20230330085501597](http://qiniu.fickler.top/img/image-20230330085501597.png)

4. 使用 npm 命令初始化项目

初始化时要输入项目名（matchup-frontend）、选择脚手架的类型（vue）、前端的类型（TS），都选择好项目就初始化完成了，这个速度还是很快的，比起 Ant Design Pro 块了不止一倍...

![image-20230330090248006](http://qiniu.fickler.top/img/image-20230330090248006.png)

![image-20230330090509447](http://qiniu.fickler.top/img/image-20230330090509447.png)

5. 在 webstorm 中打开项目

![image-20230330090613334](http://qiniu.fickler.top/img/image-20230330090613334.png)

#### 2. 解读一下 `package.json` 中的命令

| package.json                                                 | 是前端项目包管理器的一个依赖文件，在这里，你可以配置项目需要执行的脚本 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20230330091419913](http://qiniu.fickler.top/img/image-20230330091419913.png) | dev 在本地开发环境去启动一个可以实时更新的项目               |
| ![image-20230330091433593](http://qiniu.fickler.top/img/image-20230330091433593.png) | build 就是对项目进行打包，这个 build 命令相当于先执行了 vue-tsc 将 type script 转换成 javascript 然后再执行 vite build |
| ![image-20230330091453997](http://qiniu.fickler.top/img/image-20230330091453997.png) | 其实这个 script 后面的内容你可以随便写，然后随便改成自己的命令 |
| ![image-20230330091506371](http://qiniu.fickler.top/img/image-20230330091506371.png) | preview 可以让你在本地去运行一个预发布环境，提前去浏览这个项目正式上线前是什么样子和 dev 还是有区别的，这个更倾向于线上，它的项目体积可能会更小，删掉一些无用的东西之类的 |
| ![image-20230330091521501](http://qiniu.fickler.top/img/image-20230330091521501.png)![image-20230330091534824](http://qiniu.fickler.top/img/image-20230330091534824.png) | vitejs/plugin-vue 默认安装 vitejs/plugin-vue，vite 是一个构建工具，vite 不需要 vue 和 react 的绑定，这里除了安装 vite 还安装 plugin-vue，这就是一个非常好的设计，它的构建工具是独立于任何的框架，针对每个框架去提供了一个额外的适配，通过一个插件化的方式，然后可以让整个框架，让整个 vite 构建工具的通用性变的更强 |
| ![image-20230330093835921](http://qiniu.fickler.top/img/image-20230330093835921.png) | 这些东西都是放在 devDependencies，就是说这个项目上线的时候，这些依赖就用不到了，这些依赖只在我们开发阶段要把项目打包成包的时候需要用到 |

#### 3. 下载依赖，启动项目

1. `npm install` 下载安装依赖

![image-20230330094323164](http://qiniu.fickler.top/img/image-20230330094323164.png)

依赖安装好后，会多出一个 `node_modules` 文件，这个是整个项目依赖的一些包

2. 启动项目

![image-20230330094430042](http://qiniu.fickler.top/img/image-20230330094430042.png)

启动成功

![image-20230330094443409](http://qiniu.fickler.top/img/image-20230330094443409.png)

访问一下页面

![image-20230330094513520](http://qiniu.fickler.top/img/image-20230330094513520.png)

#### 4. 整合组件库

1. 官方文档的介绍

![image-20230330095112026](http://qiniu.fickler.top/img/image-20230330095112026.png)

2. 按需引入

```shell
npm i unplugin-vue-components -D
```

> 按需引入的一个好处，这个这个组件库有很多组件，但是大部分我们并用不到，就没必要把它们全都引入到项目中，只需要按需引入就可以了，这样就精简了项目的体积

3. 在终端中输入对应的命令

![image-20230331081810865](http://qiniu.fickler.top/img/image-20230331081810865.png)

4. 配置插件

1. 安装成功后，去根据官方文档配置一下插件

![image-20230331081952085](http://qiniu.fickler.top/img/image-20230331081952085.png)

```tsx
import vue from '@vitejs/plugin-vue';
import Components from 'unplugin-vue-components/vite';
import { VantResolver } from 'unplugin-vue-components/resolvers';

export default {
  plugins: [
    vue(),
    Components({
      resolvers: [VantResolver()],
    }),
  ],
};

```

2. 找到 `vite.config.js` 文件，把代码复制进去

![image-20230331082447260](http://qiniu.fickler.top/img/image-20230331082447260.png)

3. 先安装 vant

![image-20230331082551827](http://qiniu.fickler.top/img/image-20230331082551827.png)

```shell
npm i vant
```

![image-20230331082801182](http://qiniu.fickler.top/img/image-20230331082801182.png)

4. 根据文档提示，引入组件

![image-20230331082842248](http://qiniu.fickler.top/img/image-20230331082842248.png)

```tsx
import { createApp } from 'vue';
// 1. 引入你需要的组件
import { Button } from 'vant';
// 2. 引入组件样式
import 'vant/lib/index.css';

const app = createApp();

// 3. 注册你需要的组件
app.use(Button);
```

5. 我们找到 vue 的主文件（主页面入口），找到 `main.ts`

> `main.ts` 就是前端项目的入口。看他做了什么事情，从 vue 中引入一个 createApp 来创建一个 App 的组件，然后用 mount 将 vue 的页面和我们的 domin 元素关联起来。
>
> 这个 mount 我们将它叫做挂载，就是把一个组件页面挂载到某个页面上，可以理解为：你有一面墙（墙=html），还有一个墙贴（墙贴=app.vue），我们要把**墙贴**贴到**墙**上的某个部分，`index.html`这里有个 id 的 app，然后就和这个关联到了，#app 这个井号就是来指定 ID 的。

![image-20230331083255672](http://qiniu.fickler.top/img/image-20230331083255672.png)

![image-20230331083428623](http://qiniu.fickler.top/img/image-20230331083428623.png)

6. 将刚刚的组件配置文件复制到 `main.ts` 文件中

![image-20230331083756090](http://qiniu.fickler.top/img/image-20230331083756090.png)

#### 5. 测试一下 vant 语法

1. 选择一个 Button 基础组件，复制一下

![image-20230331083914706](http://qiniu.fickler.top/img/image-20230331083914706.png)

```vue
<van-button type="primary">主要按钮</van-button>
<van-button type="success">成功按钮</van-button>
<van-button type="default">默认按钮</van-button>
<van-button type="warning">警告按钮</van-button>
<van-button type="danger">危险按钮</van-button>
```

2. 粘贴到 `App.vue` 中

![image-20230331084235362](http://qiniu.fickler.top/img/image-20230331084235362.png)

3. 再次启动项目，访问一下

![image-20230331084211454](http://qiniu.fickler.top/img/image-20230331084211454.png)

### 二、前端主页 + 组件概览

F12 或者鼠标右键检查，这里可以参考手机和 ipad 适应布局显示，去想象对应页面相应的修改和调整

![image-20230331084520590](http://qiniu.fickler.top/img/image-20230331084520590.png)

![image-20230331084550226](http://qiniu.fickler.top/img/image-20230331084550226.png)

#### 1. 需要做的设计

导航条：展示当前页面名称

主页搜索框 => 搜索页 => 搜索结果页（标签筛选页）

内容：

- 主页（推广页 + 广告）ps：如果你要做商业性的网页，一定要考虑清楚，广告的位置
  - 搜索框
  - banner
  - 最简信息流
- 队伍页
- 用户页（消息 - 暂时考虑发邮件）

#### 2. 前端开发

1. 精简一下老页面

![image-20230331085031520](http://qiniu.fickler.top/img/image-20230331085031520.png)

2. `HelloWorld.vue` 组件

`HelloWorld.vue` 组件的目的是给不是很熟悉 vue 语法的用户提供一个参考

![image-20230331085159045](http://qiniu.fickler.top/img/image-20230331085159045.png)

3. 新建一个目录

在 `src` 目录下面新建一个 `layouts` 目录

很多页面要复用组件 / 样式，重复写很麻烦、不利于维护，所以抽象一个通用的布局（Layout）**一个很重要的设计**

在 `layouts` 目录下新建一个 `BasicLayout.vue`（基础的布局）

![image-20230331085540375](http://qiniu.fickler.top/img/image-20230331085540375.png)

在 `BasicLayout.vue` 写下一些所有页面都要用到的东西

4. 去文档找一下导航条的样式

![image-20230331085822043](http://qiniu.fickler.top/img/image-20230331085822043.png)

![image-20230331085840096](http://qiniu.fickler.top/img/image-20230331085840096.png)

```vue
<van-nav-bar
  title="标题"
  left-text="返回"
  right-text="按钮"
  left-arrow
  @click-left="onClickLeft"
  @click-right="onClickRight"
/>

import { showToast } from 'vant';

export default {
  setup() {
    const onClickLeft = () => history.back();
    const onClickRight = () => showToast('按钮');
    return {
      onClickLeft,
      onClickRight,
    };
  },
};

<van-nav-bar title="标题" left-text="返回" left-arrow>
  <template #right>
    <van-icon name="search" size="18" />
  </template>
</van-nav-bar>
```

5. 在使用之前还要引入导航栏（NavBar）和图标（Icon），不然 vant 不认识它，在 `mian` 引入它

![image-20230331090202797](http://qiniu.fickler.top/img/image-20230331090202797.png)

6. 将上面的导航栏代码粘贴到 `BasicLayout.vue` 并修改一下，到 `App.vue` 引入一下

![image-20230331092444036](http://qiniu.fickler.top/img/image-20230331092444036.png)

![image-20230331091924717](http://qiniu.fickler.top/img/image-20230331091924717.png)

7. 查看一下页面

点击返回时左，点击按钮是右

![image-20230331093234577](http://qiniu.fickler.top/img/image-20230331093234577.png)

![image-20230331093238280](http://qiniu.fickler.top/img/image-20230331093238280.png)

8. 如法炮制，再引入底部的 tabbar，选个功能多一点的

![image-20230331093421995](http://qiniu.fickler.top/img/image-20230331093421995.png)

```vue
<van-tabbar v-model="active" @change="onChange">
  <van-tabbar-item icon="home-o">标签 1</van-tabbar-item>
  <van-tabbar-item icon="search">标签 2</van-tabbar-item>
  <van-tabbar-item icon="friends-o">标签 3</van-tabbar-item>
  <van-tabbar-item icon="setting-o">标签 4</van-tabbar-item>
</van-tabbar>
```

```tsx
import { ref } from 'vue';
import { showToast } from 'vant';

export default {
  setup() {
    const active = ref(0);
    const onChange = (index) => showToast(`标签 ${index}`);
    return {
      icon,
      onChange,
    };
  },
};
```

```tsx
app.use(Tabbar)
app.use(TabbarItem)
```

![image-20230331093601551](http://qiniu.fickler.top/img/image-20230331093601551.png)

![image-20230331094017762](http://qiniu.fickler.top/img/image-20230331094017762.png)

9. 刷新一下页面

![image-20230331094100497](http://qiniu.fickler.top/img/image-20230331094100497.png)

10. 但是鼠标放在下面的图标上一个都没有亮

> 这里我们给 tabbar 标签栏组件中指定了一个 active，这个 active 就是用来表示当前应该高亮哪个 tab，当前用户的位置属于哪个 tab 下。

![image-20230331094322493](http://qiniu.fickler.top/img/image-20230331094322493.png)

这个 active 默认值是 0，改为 index（主页的 name 属性，或者说主页的名字），没有点击主页，主页的图标就高亮了

![image-20230331094545971](http://qiniu.fickler.top/img/image-20230331094545971.png)

> 其实就是通过这个 active 去关联了每个标签上的内容，当你点击某个 tab 时，就会触发切换事件，并且更改这个 active 当前激活的 tab 值。

这里使用了 change 事件，就是当用户切换这个 tab 栏时，会触发 Toast（也是 vant 的组件），触发一个比较轻量的提示

![image-20230331101948837](http://qiniu.fickler.top/img/image-20230331101948837.png)

11. 分别点击三个图标

![image-20230331102011947](http://qiniu.fickler.top/img/image-20230331102011947.png)

![image-20230331102020718](http://qiniu.fickler.top/img/image-20230331102020718.png)

![image-20230331102029330](http://qiniu.fickler.top/img/image-20230331102029330.png)

12. 现在给中间添加一些内容

![image-20230331102207666](http://qiniu.fickler.top/img/image-20230331102207666.png)

![image-20230331102322711](http://qiniu.fickler.top/img/image-20230331102322711.png)

13. 再去创建一个页面，在 src 目录下新建 pages 目录

![image-20230331102417146](http://qiniu.fickler.top/img/image-20230331102417146.png)

14. 然后在 pages 目录下新建两个页面 `Index.vue` 和 `Team.vue`

![image-20230331102526754](http://qiniu.fickler.top/img/image-20230331102526754.png)

15. 当我们点击这个 tab 栏时，然后就去加载对应的页面

![image-20230331103034743](http://qiniu.fickler.top/img/image-20230331103034743.png)

![image-20230331103530916](http://qiniu.fickler.top/img/image-20230331103530916.png)

## 数据库表设计

> 标签的分类（要有哪些标签，怎么把标签进行分类）

### 一、新增标签表（分类表）

> 建议用标签，不要用分类，更灵活

#### 1. 想一想，需要哪些标签分类？

1. 性别：男、女
2. 方向：Java、C++、Py、Go、前端
3. 正在学：Spring
4. 目标：考研、春招、秋招、校招、社招、考公、竞赛（蓝桥杯）、转行、跳槽
5. 段位：初级、中级、高级、王者
6. 身份：小学、初中、高中、大一、大二、大三、大四、学生、待业、已就业、研一、研二、研三
7. 状态：乐观、有点丧、一般、单身、已婚、有对象

或者：【用户自己定义标签】

#### 2. 表设计

| 标签表（分类表） |                                                              |                                   |
| ---------------- | ------------------------------------------------------------ | --------------------------------- |
| 字段             | 说明                                                         | 类型                              |
| id               | 主键                                                         | bigint                            |
| tagName          | 标签名（非空；必须唯一、唯一索引）                           | varchar                           |
| userId           | 上传标签的用户（如果要根据 userId 查已上传标签的话，最好加上，普通索引） | bigint                            |
| parentId         | 父标签id（分类）                                             | bigint                            |
| isParent         | 是否为父标签                                                 | tingint（0-不是父标签、1-父标签） |
| createTime       | 创建时间                                                     | datetime                          |
| updateTime       | 更新时间                                                     | dateTime                          |
| isDelete         | 是否删除（逻辑删除）                                         | tinyint（0、1）                   |

> 怎么查询所有标签，并且把标签分好组？按父标签 id 分组，能实现 √
>
> 根据父标签查询子标签？根据 id 查询，能实现 √

> **小知识**
>
> SQL 语言分类：
>
> 1. DDL define 建表、操作表
> 2. DML manage 更新删除数据，影响实际表里的内容
> 3. DCL control 控制、权限
> 4. DQL query 查询，select
>
> 附加：[DQL、DML、DDL、DCL的概念与区别 - 范兵 - 博客园 (cnblogs.com)](https://www.cnblogs.com/fan-yuan/p/7879353.html)

在数据库中建立 tag 表

```mysql
-- auto-generated definition
create table tag
(
    id           bigint auto_increment comment 'id' primary key,
    tagName      varchar(256)                       null comment '标签名称',
    userId       bigint                             null comment '用户 id',
    parentId     bigint                             null comment '父标签 id',
    isParent     tinyint                            null comment '0-不是, 1-父标签',
    creatTime    datetime default CURRENT_TIMESTAMP null comment '创建时间',
    updateTime   datetime default CURRENT_TIMESTAMP null on update CURRENT_TIMESTAMP comment '更新时间',
    isDelete     tinyint  default 0                 not null comment '是否删除'
)
    comment '标签表' auto_increment = 8;
```

![image-20230331110628133](http://qiniu.fickler.top/img/image-20230331110628133.png)

### 二、修改用户表

> 修改用户表，就要知道用户有哪些标签

**方式一：**

直接在用户表补充 tags 字段，[ ‘Java’, ‘男’ ] 存 json 字符串

**优点**：查询方便、不用新建关联表，标签是用户的固有属性

（除了该系统、其他系统可能要用到，标签是用户的固有属性）节省开发成本

**应用场景**：查询用户列表，查关系表拿到这 100 个用户的所有标签 id，再根据标签 id 去查标签表

**缺点**：用户表多一列，会降低性能



**方式二：**

加一个关联表，记录用户和标签的关系

**关联表的应用场景**：查询灵活，可以正查反查

**缺点**：要多建一个表、多维护一个表

**重点**：企业大项目开发中尽量减少关联查询，很难影响扩展性，而且会影响查询性能



我们采用第一种方法

```mysql
alter table user add COLUMN tags varchar(1024) null comment '标签列表';
```

![image-20230331115052790](http://qiniu.fickler.top/img/image-20230331115052790.png)

之后可能要经常通过这个标签名去搜索，给标签名加上一个唯一索引，上传标签的用户加上普通索引

![image-20230331115504918](http://qiniu.fickler.top/img/image-20230331115504918.png)

![image-20230331115643814](http://qiniu.fickler.top/img/image-20230331115643814.png)

可以看到多了两个索引

![image-20230331115724461](http://qiniu.fickler.top/img/image-20230331115724461.png)

将刚刚写的添加字段和新建 tag 表语句，添加到 `create_table.sql` 中

![image-20230331223622883](http://qiniu.fickler.top/img/image-20230331223622883.png)

## 开发后端

### 一、开发后端接口设计

**搜索标签的两种方式**

#### 1. SQL 查询

> 实现简单，可以通过拆分查询进一步优化

1. 允许用户传入多个标签，多个标签都存在才搜索的出来 and。like ‘%Java%’ and like ‘%C++%’ 。
2. 允许用户传入多个标签，有任何一个标签存在就能搜索出来 or。like ‘%Java%’ or like ‘%C++%’ 。

#### 2. 内存查询

（灵活，可以通过并发进一步优化）

**思路**：

- 如果参数可以分析，根据用户的参数去选择查询方式，比如标签数
- 如果参数不可以分析，并且数据库连接足够、内存空间足够，可以并发同时查询，谁先返回用谁
- 还可以 SQL 查询与内存计算相结合，比如先用 SQL 过掉部分 tag

### 二、初始化后端

> 用户中心来集中提供用户的检索、操作、注册、登录、鉴权

#### 1. 编写用户标签搜索方法

1. 我们已经有了一个用户中心，直接在用户中心的基础上写

![image-20230401132125845](http://qiniu.fickler.top/img/image-20230401132125845.png)

2. 在 UserServiceImpl 中写下搜索用户的接口，再打上注释输入 /**

![image-20230401132721296](http://qiniu.fickler.top/img/image-20230401132721296.png)

```java
    /**
     * 根据标签搜索用户
     * @param tagNameList 用户要拥有的标签
     * @return
     */
    @Override
    public int searchUsersByTags(List<String> tagNameList) {

    }
```

3. 在 UserService 中也给这个方法打上注释

![image-20230401133437572](http://qiniu.fickler.top/img/image-20230401133437572.png)

```java
    /**
     * 根据标签搜索用户
     * @param tagNameList 用户拥有的标签
     * @return
     */
    int searchUsersByTags(List<String> tagNameList);
```

3. 回到 UserServiceImpl 中开始编写逻辑

> 先判断一下是否为空，然后如果说是空的话，直接抛出异常返回；否则的话，创建这个查询，放进一个 queryWrapper = new QueryWrapper，在 queryWrapper 把 tagList 全部组成一个 and 的查询…

![image-20230401135332121](http://qiniu.fickler.top/img/image-20230401135332121.png)

```java
/**
 * 根据标签搜索用户
 * @param tagNameList 用户要拥有的标签
 * @return
 */
@Override
public List<User> searchUsersByTags(List<String> tagNameList) {
    if (CollectionUtils.isEmpty(tagNameList)) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    QueryWrapper<User> queryWrapper = new QueryWrapper<>();
    // 拼接 and 查询
    // like '%Java%' and like '%Python%'
    for (String tagName : tagNameList) {
        queryWrapper = queryWrapper.like("tags", tagName);
    }
    List<User> userList = userMapper.selectList(queryWrapper);
    userList.forEach(this::getSafetyUser);
}
```

4. 我们要返回一个新的列表

![image-20230401135928794](http://qiniu.fickler.top/img/image-20230401135928794.png)

```java
return userList.stream().map(this::getSafetyUser).collect(Collectors.toList());
```

#### 2. 测试

1. 编写测试代码

![image-20230401141258481](http://qiniu.fickler.top/img/image-20230401141258481.png)

```java
@Test
void testSearchUsersByTags() {
    List<String> tagNameList = Arrays.asList("java", "python");
    List<User> userList = userService.searchUsersByTags(tagNameList);
    Assert.assertNotNull(userList);
}
```

2. 不过现在搜不到，我们要去数据库修改下数据

![image-20230401141606301](http://qiniu.fickler.top/img/image-20230401141606301.png)

3. 开启 sql 输出日志

![image-20230401141832016](http://qiniu.fickler.top/img/image-20230401141832016.png)

4. 测试一下，看看结果

![image-20230401142616262](http://qiniu.fickler.top/img/image-20230401142616262.png)

5. 因为在数据库中添加了一个 tags 字段，但是在 mybatis-plus 中还没有添加，现在添加一下

![image-20230401142807648](http://qiniu.fickler.top/img/image-20230401142807648.png)

![image-20230401142853930](http://qiniu.fickler.top/img/image-20230401142853930.png)

![image-20230401142932283](http://qiniu.fickler.top/img/image-20230401142932283.png)

6. 替换一下 create.sql 中 user 表的建表语句

![image-20230401143214741](http://qiniu.fickler.top/img/image-20230401143214741.png)

7. 现在换一种查询方式

![image-20230401144039514](http://qiniu.fickler.top/img/image-20230401144039514.png)

```java
    /**
     * 根据标签搜索用户
     * @param tagNameList 用户要拥有的标签
     * @return
     */
    @Override
    public List<User> searchUsersByTags(List<String> tagNameList) {
        if (CollectionUtils.isEmpty(tagNameList)) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
//        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
//        // 拼接 and 查询
//        // like '%Java%' and like '%Python%'
//        for (String tagName : tagNameList) {
//            queryWrapper = queryWrapper.like("tags", tagName);
//        }
//        List<User> userList = userMapper.selectList(queryWrapper);
        // 1.查询所有用户
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        List<User> userList = userMapper.selectList(queryWrapper);
        // 2.在内存中判断是否包含要求的标签
        for (User user : userList) {
            String tagsStr = user.getTags();
        }
        return userList.stream().map(this::getSafetyUser).collect(Collectors.toList());
    }
```

#### 3. 将字符串转为 json

> **解析 JSON 字符串**：
>
> 1. 序列化：java 对象转成 json
> 2. 反序列化：把 json 转为 java 对象
>
> **java json 序列化库有很多**：
>
> 1. gson（goole 的）
> 2. fastjson alibaba（ali 出品，块，但漏洞多）
> 3. jackson
> 4. kryo

1. 去 maven 仓库中搜索 gson，复制依赖

![image-20230401144430014](http://qiniu.fickler.top/img/image-20230401144430014.png)

```xml
<!-- https://mvnrepository.com/artifact/com.google.code.gson/gson -->
<dependency>
    <groupId>com.google.code.gson</groupId>
    <artifactId>gson</artifactId>
    <version>2.8.9</version>
</dependency>
```

2. 放到 pom.xml 文件中，加载依赖

![image-20230401144601596](http://qiniu.fickler.top/img/image-20230401144601596.png)

3. 继续编写 UserServiceImp 方法

![image-20230401145157223](http://qiniu.fickler.top/img/image-20230401145157223.png)

```java
    /**
     * 根据标签搜索用户
     * @param tagNameList 用户要拥有的标签
     * @return
     */
    @Override
    public List<User> searchUsersByTags(List<String> tagNameList) {
        if (CollectionUtils.isEmpty(tagNameList)) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
//        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
//        // 拼接 and 查询
//        // like '%Java%' and like '%Python%'
//        for (String tagName : tagNameList) {
//            queryWrapper = queryWrapper.like("tags", tagName);
//        }
//        List<User> userList = userMapper.selectList(queryWrapper);
        // 1.查询所有用户
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        List<User> userList = userMapper.selectList(queryWrapper);
        Gson gson = new Gson();
        // 2.在内存中判断是否包含要求的标签
        return userList.stream().filter(user -> {
            String tagsStr = user.getTags();
            if (StringUtils.isBlank(tagsStr)) {
                return false;
            }
            Set<String> tempTagNameSet = gson.fromJson(tagsStr, new TypeToken<Set<String>>() {
            }.getType());
            for (String tagName : tagNameList) {
                if (!tempTagNameSet.contains(tagName)) {
                    return false;
                }
            }
            return true;
        }).map(this::getSafetyUser).collect(Collectors.toList());
    }
```

4. 测试一下

![image-20230401145344273](http://qiniu.fickler.top/img/image-20230401145344273.png)

**思考？**两种查询的方式哪种更快呢？

> 应该是第二种方式更快，第一种方式是直接用 sql 来进行查询，查询的内容是硬盘上的
>
> 而第二种方式，我们是直接将所有的数据都取出来，在内存中进行查询，显然，内存的速度要远远快于硬盘的速度
>
> 所以，一般来说第二种的速度会更快一点，但是由于当前的数据量比较小，所以测试并不准确，具体的快慢还是要看具体的应用场景

### 三、后端标签接口调试

#### 1. 内存过滤

```java
/**
 * 根据标签搜索用户（内存过滤）
 *
 * @param tagNameList 用户要拥有的标签
 * @return
 */
@Override
public List<User> searchUsersByTags(List<String> tagNameList) {
    if (CollectionUtils.isEmpty(tagNameList)) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    // 1.查询所有用户
    QueryWrapper<User> queryWrapper = new QueryWrapper<>();
    List<User> userList = userMapper.selectList(queryWrapper);
    Gson gson = new Gson();
    // 2.在内存中判断是否包含要求的标签
    return userList.stream().filter(user -> {
        String tagsStr = user.getTags();
        if (StringUtils.isBlank(tagsStr)) {
            return false;
        }
        Set<String> tempTagNameSet = gson.fromJson(tagsStr, new TypeToken<Set<String>>() {
        }.getType());
        tempTagNameSet = Optional.ofNullable(tempTagNameSet).orElse(new HashSet<>());
        for (String tagName : tagNameList) {
            if (!tempTagNameSet.contains(tagName)) {
                return false;
            }
        }
        return true;
    }).map(this::getSafetyUser).collect(Collectors.toList());
}
```

#### 2. SQL查询版

```java
/**
 * 根据标签搜索用户（SQL查询版）
 *
 * @param tagNameList 用户要拥有的标签
 * @return
 */
@Deprecated
public List<User> searchUsersBySql(List<String> tagNameList) {
    if (CollectionUtils.isEmpty(tagNameList)) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    QueryWrapper<User> queryWrapper = new QueryWrapper<>();
    // 拼接 and 查询
    // like '%Java%' and like '%Python%'
    for (String tagName : tagNameList) {
        queryWrapper = queryWrapper.like("tags", tagName);
    }
    List<User> userList = userMapper.selectList(queryWrapper);
    return userList.stream().map(this::getSafetyUser).collect(Collectors.toList());
}
```

## 前端开发

### 一、前端整合路由

#### 1. 下载安装vue路由

1. 引入一个路由：[Vue Router | The official Router for Vue.js (vuejs.org)](https://router.vuejs.org/)

![image-20230401231950810](http://qiniu.fickler.top/img/image-20230401231950810.png)

2. 下载安装路由

```shell
# npm
npm install vue-router@4

# yarn
yarn add vue-router@4
```

![image-20230401232313357](http://qiniu.fickler.top/img/image-20230401232313357.png)

3. 再次启动项目，`package.json` 中多了 `vue-router`

![image-20230401232401533](http://qiniu.fickler.top/img/image-20230401232401533.png)

#### 2. 整合路由框架

1. 继续跟着官方文档，看一下怎么引用

![image-20230401232503487](http://qiniu.fickler.top/img/image-20230401232503487.png)

```javascript
// 1. 定义路由组件.
// 也可以从其他文件导入
const Home = { template: '<div>Home</div>' }
const About = { template: '<div>About</div>' }

// 2. 定义一些路由
// 每个路由都需要映射到一个组件。
// 我们后面再讨论嵌套路由。
const routes = [
  { path: '/', component: Home },
  { path: '/about', component: About },
]

// 3. 创建路由实例并传递 `routes` 配置
// 你可以在这里输入更多的配置，但我们在这里
// 暂时保持简单
const router = VueRouter.createRouter({
  // 4. 内部提供了 history 模式的实现。为了简单起见，我们在这里使用 hash 模式。
  history: VueRouter.createWebHashHistory(),
  routes, // `routes: routes` 的缩写
})

// 5. 创建并挂载根实例
const app = Vue.createApp({})
//确保 _use_ 路由实例使
//整个应用支持路由。
app.use(router)

app.mount('#app')

// 现在，应用已经启动了！
```

2. 找到前端项目的主页面，修改一下

![image-20230401232652769](http://qiniu.fickler.top/img/image-20230401232652769.png)

修改后：

![image-20230401233725476](http://qiniu.fickler.top/img/image-20230401233725476.png)

```tsx
import { createApp } from 'vue';
import {Button, Icon, NavBar, Tabbar, TabbarItem } from 'vant';
import App from './App.vue';
import 'vant/es/toast/style';
// @ts-ignore
import * as VueRouter from "vue-router";
import Index from "./pages/Index.vue";
import Team from "./pages/Team.vue";

const app = createApp(App);
app.use(Button);
app.use(Icon);
app.use(NavBar);
app.use(Tabbar)
app.use(TabbarItem)

// 定义一些路由
const routes = [
    { path: '/', component: Index },
    { path: '/about', component: Team },
]

const router = VueRouter.createRouter({
    // 4. 内部提供了 history 模式的实现。为了简单起见，我们在这里使用 hash 模式。
    history: VueRouter.createWebHashHistory(),
    routes, // `routes: routes` 的缩写
})

app.use(router);

app.mount('#app');
```

> 这个页面的跳转的规则，它是一个全局性的东西，所以尽量把它提出，要不然后面可能写起来会非常复杂，不要什么东西都写在主文件里面
>
> ![image-20230401233935618](http://qiniu.fickler.top/img/image-20230401233935618.png)

3. 新建一个配置文件，在 src 目录下创建 config 目录，在 config 目录下创建 `route.ts` 文件

![image-20230401234221320](http://qiniu.fickler.top/img/image-20230401234221320.png)

4. 在 `main.ts` 中引入一下

![image-20230401234325578](http://qiniu.fickler.top/img/image-20230401234325578.png)

5. 找到布局文件 `BasicLayout.vue`，之前我们用 v-if，现在不用了，引入 `route-view`，这个是根据不同的页面展示不同的内容

![image-20230401234633693](http://qiniu.fickler.top/img/image-20230401234633693.png)

改为：

![image-20230401234730220](http://qiniu.fickler.top/img/image-20230401234730220.png)

6. 搭配 `router-link` 来创建链接，试一下

![image-20230401234840837](http://qiniu.fickler.top/img/image-20230401234840837.png)

![image-20230401235011047](http://qiniu.fickler.top/img/image-20230401235011047.png)

7. 测试一下

点击 Go to Home 显示主页面，点击队伍显示队伍，路径也不一样

![image-20230401235056634](http://qiniu.fickler.top/img/image-20230401235056634.png)

#### 3. tab栏切换路由

这说明框架已经整合成功了，我们现在需要用底下这个 tab 栏去切换路由

1. 去看一下 vant3 的官方文档

![image-20230401235356002](http://qiniu.fickler.top/img/image-20230401235356002.png)

```vue
<router-view />

<van-tabbar route>
  <van-tabbar-item replace to="/home" icon="home-o">标签</van-tabbar-item>
  <van-tabbar-item replace to="/search" icon="search">标签</van-tabbar-item>
</van-tabbar>
```

2. 继续修改 `BasicLayout.vue`

![image-20230401235637975](http://qiniu.fickler.top/img/image-20230401235637975.png)

3. 在 `pages` 目录下新建一个个人页 `User.vue`

![image-20230401235832886](http://qiniu.fickler.top/img/image-20230401235832886.png)

4. 在 `route.ts` 中加上个人页路由

![image-20230402000042473](http://qiniu.fickler.top/img/image-20230402000042473.png)

5. 测试一下

![image-20230402000114165](http://qiniu.fickler.top/img/image-20230402000114165.png)

6. 将 `router-link` 删掉，路由整合就完成了

![image-20230402000211822](http://qiniu.fickler.top/img/image-20230402000211822.png)

### 二、搜索页面

#### 1. 添加一个搜索页面

1. 去看下 vant3 的文档：找一个合适的搜索页面，参考一下 bilibili

![image-20230402102340302](http://qiniu.fickler.top/img/image-20230402102340302.png)

![image-20230402102558451](http://qiniu.fickler.top/img/image-20230402102558451.png)

```html
<form action="/">
  <van-search
    v-model="value"
    show-action
    placeholder="请输入搜索关键词"
    @search="onSearch"
    @cancel="onCancel"
  />
</form>
```

```tsx
import { ref } from 'vue';
import { showToast } from 'vant';

export default {
  setup() {
    const value = ref('');
    const onSearch = (val) => showToast(val);
    const onCancel = () => showToast('取消');
    return {
      value,
      onSearch,
      onCancel,
    };
  },
};
```

2. 新建一个搜索页 `Search.vue`，把代码粘贴过去，修改一下

![image-20230402103037733](http://qiniu.fickler.top/img/image-20230402103037733.png)

```vue
<template>
  <form action="/">
    <van-search
        v-model="searchText"
        show-action
        placeholder="请输入搜索关键词"
        @search="onSearch"
        @cancel="onCancel"
    />
  </form>
</template>

<script setup>
  import { ref } from 'vue';
  import { showToast } from 'vant';
  const searchText = ref('');
  const onSearch = (val) => showToast(val);
  const onCancel = () => showToast('取消');
</script>
```

3. 然后做一个点击搜索按钮，跳转到搜索页面，看一下 vue 官方文档

![image-20230402103426370](http://qiniu.fickler.top/img/image-20230402103426370.png)

```vue
// 字符串路径
router.push('/users/eduardo')
```

4. 到 `BasicLayout.vue` 粘贴过去，修改一下

![image-20230402103647635](http://qiniu.fickler.top/img/image-20230402103647635.png)

5. 挂载一下搜索路由

![image-20230402104007091](http://qiniu.fickler.top/img/image-20230402104007091.png)

6. 点击搜索按钮试一下，会先弹出一个提示框，然后跳转到搜索页面

![image-20230402104313798](http://qiniu.fickler.top/img/image-20230402104313798.png)

![image-20230402105323557](http://qiniu.fickler.top/img/image-20230402105323557.png)

#### 2. 添加标签和分组

1. 但是点击搜索后，我们还想让它展示当前已选择的标签

![image-20230402105622953](http://qiniu.fickler.top/img/image-20230402105622953.png)

```html
<van-tag :show="show" closeable size="medium" type="primary" @close="close">
  标签
</van-tag>
```

```tsx
import { ref } from 'vue';

export default {
  setup() {
    const show = ref(true);
    const close = () => {
      show.value = false;
    };

    return {
      show,
      close,
    };
  },
};
```

2. 还需要一个列表给它分组

![image-20230402105810685](http://qiniu.fickler.top/img/image-20230402105810685.png)

```vue
<van-divider content-position="left">文字</van-divider>
<van-divider content-position="right">文字</van-divider>
```

3. 将文件名字改一下，标准一下

![image-20230402110204375](http://qiniu.fickler.top/img/image-20230402110204375.png)

![image-20230402110711703](http://qiniu.fickler.top/img/image-20230402110711703.png)

4. 将 tag 标签和分割线代码都粘贴到 `SearchPage.vue` 中，修改一下

![image-20230402110847718](http://qiniu.fickler.top/img/image-20230402110847718.png)

5. 试一下，标签出来了（有点丑）

![image-20230402110931844](http://qiniu.fickler.top/img/image-20230402110931844.png)

6. 选择标签就用 `TreeSelect` 分类选择

![image-20230402111340710](http://qiniu.fickler.top/img/image-20230402111340710.png)

```vue
<van-tree-select
  v-model:active-id="activeIds"
  v-model:main-active-index="activeIndex"
  :items="items"
/>
```

```tsx
import { ref } from 'vue';

export default {
  setup() {
    const activeId = ref([1, 2]);
    const activeIndex = ref(0);
    const items = [
      {
        text: '浙江',
        children: [
          { text: '杭州', id: 1 },
          { text: '温州', id: 2 },
          { text: '宁波', id: 3, disabled: true },
        ],
      },
      {
        text: '江苏',
        children: [
          { text: '南京', id: 4 },
          { text: '无锡', id: 5 },
          { text: '徐州', id: 6 },
        ],
      },
      { text: '福建', disabled: true },
    ];

    return {
      items,
      activeId,
      activeIndex,
    };
  },
};
```

7. 粘贴进 `SearchPage.vue`，修改一下

![image-20230402112825916](http://qiniu.fickler.top/img/image-20230402112825916.png)

![image-20230402112842057](http://qiniu.fickler.top/img/image-20230402112842057.png)

8. 测试一下

![image-20230402112911686](http://qiniu.fickler.top/img/image-20230402112911686.png)

9. 现在已选的标签还不能被移除，我们修改一下

![image-20230402113111065](http://qiniu.fickler.top/img/image-20230402113111065.png)

![image-20230402113153095](http://qiniu.fickler.top/img/image-20230402113153095.png)

10. 测试一下

![image-20230402113319838](http://qiniu.fickler.top/img/image-20230402113319838.png)

11. 将标签的 id 改为 text 的文本

![image-20230402113447734](http://qiniu.fickler.top/img/image-20230402113447734.png)

12. 测试一下

![image-20230402113725988](http://qiniu.fickler.top/img/image-20230402113725988.png)

#### 3. 优化一下

1. 已选中标签挤在一起，不美观

![image-20230402113831018](http://qiniu.fickler.top/img/image-20230402113831018.png)

```vue
<van-row gutter="20">
  <van-col span="8">span: 8</van-col>
  <van-col span="8">span: 8</van-col>
  <van-col span="8">span: 8</van-col>
</van-row>
```

2. 粘贴进 `SearchPage.vue`，修改一下

![image-20230402213236560](http://qiniu.fickler.top/img/image-20230402213236560.png)

3. 看一下

![image-20230402213356271](http://qiniu.fickler.top/img/image-20230402213356271.png)

4. 现在还差个过滤标签

> 可以直接在前端里面过滤，因为标签数据量不大，没有必要向后端发送请求

![image-20230402213637390](http://qiniu.fickler.top/img/image-20230402213637390.png)

![image-20230402213723527](http://qiniu.fickler.top/img/image-20230402213723527.png)

> 原来是嵌套结构，这一步其实就是把数组打平，或者叫扁平化

5. 打平之后，再过滤

![image-20230402214153332](http://qiniu.fickler.top/img/image-20230402214153332.png)

![image-20230402221618376](http://qiniu.fickler.top/img/image-20230402221618376.png)

6. 点击搜索试一下

![image-20230402221656559](http://qiniu.fickler.top/img/image-20230402221656559.png)

### 三、用户信息页

1. 去官方文档找一个现成的

![image-20230402222720541](http://qiniu.fickler.top/img/image-20230402222720541.png)

```vue
<van-cell title="单元格" is-link />
<van-cell title="单元格" is-link value="内容" />
<van-cell title="单元格" is-link arrow-direction="down" value="内容" />
```

2. 粘贴进 `UserPage.vue`

> 定义一下后台用户数据的类别，我们现在用的是 ts，它有一个好处是可以定义一下某一个对象它的规范，比如说有哪些字段，字段是什么类型，那这个类型从哪里取？我们是不是以后中心的时候写过这个规范，写过这个类别

```tsx
  type CurrentUser = {
    id?: number;
    username?: string;
    userAccount: string;
    avatarUrl: string;
    gender?: number;
    phone?: string;
    email?: string;
    userStatus?: number;
    userRole?: number;
    planetCode?: string;
    createTime?: Date;
  };
```

3. 在 src 下新建一个 models 目录，在 models 目录下新建 `user.d.ts`，在这里定义我们的数据类型，把代码粘贴进去，修改一下

![image-20230402223818490](http://qiniu.fickler.top/img/image-20230402223818490.png)

```tsx
/**
 * 用户类型
 */
export type UserType = {
    id: number;
    username: string;
    userAccount: string;
    avatarUrl?: string;
    gender: number;
    phone: string;
    email: string;
    userStatus: number;
    userRole: number;
    planetCode: string;
    tags: string[];
    createTime: Date;
};
```

4. 在 `UserPage.vue` 中引入

![image-20230402232308015](http://qiniu.fickler.top/img/image-20230402232308015.png)

```vue
<template>
  <van-cell title="昵称" is-link to="/user/edit" :value="user.username" />
  <van-cell title="账号" :value="user.userAccount" />
  <van-cell title="头像" is-link to="/user/edit">
    <img style="height: 48px" :src="user.avatarUrl" />
  </van-cell>
  <van-cell title="性别" is-link to="/user/edit" :value="user.gender" />
  <van-cell title="电话" is-link to="/user/edit" :value="user.phone" />
  <van-cell title="邮箱" is-link to="/user/edit" :value="user.email" />
  <van-cell title="星球编号" :value="user.planetCode" />
  <van-cell title="注册时间" :value="user.createTime.toISOString()" />
</template>

<script setup>
const user = {
  id: 1,
  username: 'fickle',
  userAccount: 'fickle',
  avatarUrl: 'http://qzapp.qlogo.cn/qzapp/101983660/DE2DFA542010DAD2696FC2082D1EE3E7/100',
  gender: '男',
  phone: '123',
  email: '456@qq.com',
  planetCode: '1234',
  createTime: new Date(),
}
</script>

<style scoped>

</style>
```

5. 测试一下

![image-20230402232348243](http://qiniu.fickler.top/img/image-20230402232348243.png)

6. 现在做编辑信息，编辑就是点击 `>` 进入到编辑页面

![image-20230402232443758](http://qiniu.fickler.top/img/image-20230402232443758.png)

### 四、用户信息修改页

1. 复制 `UserPage.vue`，粘贴到 pages 目录下，重命名为 `UserEditPage.vue`，新建一个编辑用户页

![image-20230402232641681](http://qiniu.fickler.top/img/image-20230402232641681.png)

2. 在 `route.ts` 新增路由

![image-20230402232807409](http://qiniu.fickler.top/img/image-20230402232807409.png)

3. 修改一下 `UserPage.vue` 和 `UserEditPage.vue`

![image-20230402234905690](http://qiniu.fickler.top/img/image-20230402234905690.png)

![image-20230402235124823](http://qiniu.fickler.top/img/image-20230402235124823.png)

4. 试一下

![image-20230402235226117](http://qiniu.fickler.top/img/image-20230402235226117.png)

5. 删掉一些代码，恢复成如图所示

![image-20230402235506741](http://qiniu.fickler.top/img/image-20230402235506741.png)

![image-20230402235414512](http://qiniu.fickler.top/img/image-20230402235414512.png)

6. 去官方文档找一个编辑方法

![image-20230402235643334](http://qiniu.fickler.top/img/image-20230402235643334.png)

```vue
<van-form @submit="onSubmit">
  <van-cell-group inset>
    <van-field
      v-model="username"
      name="用户名"
      label="用户名"
      placeholder="用户名"
      :rules="[{ required: true, message: '请填写用户名' }]"
    />
    <van-field
      v-model="password"
      type="password"
      name="密码"
      label="密码"
      placeholder="密码"
      :rules="[{ required: true, message: '请填写密码' }]"
    />
  </van-cell-group>
  <div style="margin: 16px;">
    <van-button round block type="primary" native-type="submit">
      提交
    </van-button>
  </div>
</van-form>
```

```tsx
import { ref } from 'vue';

export default {
  setup() {
    const username = ref('');
    const password = ref('');
    const onSubmit = (values) => {
      console.log('submit', values);
    };

    return {
      username,
      password,
      onSubmit,
    };
  },
};
```

7. 粘贴进 `UserEditPage.vue`，修改一下

![image-20230403000414395](http://qiniu.fickler.top/img/image-20230403000414395.png)

![image-20230403000423505](http://qiniu.fickler.top/img/image-20230403000423505.png)

8. 再修改一下 `UserPage.vue`

![image-20230403000645213](http://qiniu.fickler.top/img/image-20230403000645213.png)

9. 再试一下，修改页就出来了，点击提交，数据也传过来了

![image-20230403000806795](http://qiniu.fickler.top/img/image-20230403000806795.png)

但是点击左上角的返回时，直接回到了主页，修改一下

10. 让它回到上一个页面，将 `router.push('/')`改为`router.back()`

![image-20230403000944051](http://qiniu.fickler.top/img/image-20230403000944051.png)

## 后端整合Swagger + Knife4j

> 什么是接口文档？**写接口信息的文档**，每条接口包括：
>
> - 请求参数
> - 响应参数
>   - 错误码
> - 接口地址
> - 接口名称
> - 请求类型
> - 请求格式
> - 备注
>
> who 谁用？一般是后端或者负责人来提供，后端和前端都要使用
>
> 为什么需要接口文档？
>
> - 有个书面内容（背书或者归档），方便大家参考和查阅，便于**沉淀和维护**，拒绝口口相传
> - 接口文档便于前端和后端开发对接，前后端联调的**介质**。后端 => 接口文档 <= 前端
> - 好的接口文档支持在线调试、在线测试，可以作为工具提高我们的开发效率
>
> 怎么做好接口文档？
>
> - 手写（比如腾讯文档、Markdown 笔记）
> - 自动化接口文档生成：自动根据项目代码生成完整的文档或者在线调试的网页。Swagger、Postman（侧重接口管理）（国外）；apifox、apipost、eolink（国内）
>
> 接口文档有哪些技巧？
>
> Swagger 原理：
>
> 1. 引入依赖（Swagger 或 Knife4j）[快速开始 | Knife4j (xiaominfo.com)](https://doc.xiaominfo.com/docs/quick-start)
> 2. 自定义 Swagger 配置类
> 3. 定义需要生成接口文档的代码位置（Controller）
> 4. 千万注意：线上环境不要把接口暴露出去！！！可以通过在 SwaggerConfig 配置文件开头加上 `@Profile({"dev", "test"})` 限定配置仅在部分环境中开启
> 5. 启动即可
> 6. 可以通过在 controller 方法上添加 `@Api`、`@ApiImplicitParam(name = "name",value = "姓名",required = true)` `@ApiOperation(value = "向客人问好")` 等注释来自定义生成的接口描述信息
>
> 若 `springboot version >= 2.6`，需要添加如下配置：
>
> ```yaml
> spring:
>   mvc:
>     pathmatch:
>       matching-strategy: ant_path_matcher
> ```

### 一、swagger

#### 1. 引入依赖

```xml
  <!-- swagger 接口文档 -->
    <dependency>
        <groupId>io.springfox</groupId>
        <artifactId>springfox-swagger2</artifactId>
        <version>2.9.2</version>
    </dependency>
    <dependency>
        <groupId>io.springfox</groupId>
        <artifactId>springfox-swagger-ui</artifactId>
        <version>2.9.2</version>
    </dependency>
```

#### 2. 配置文件

1. 新建 config 文件

![image-20230406163422955](http://qiniu.fickler.top/img/image-20230406163422955.png)

2. 在文件夹下新建 `SwaggerConfig` 文件

```java
package com.example.usercenterbackendmaster.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

/**
 * @author dell
 * @date 2023/4/6 16:35
 * 自定义 Swagger 接口文档配置
 */

@Configuration // 配置类
@EnableSwagger2 // 开启 swagger2 的自动配置
public class SwaggerConfig {

    @Bean
    public Docket docket() {
        // 创建一个 swagger 的 bean 实例
        return new Docket(DocumentationType.SWAGGER_2)

                // 配置接口信息
                .select() // 设置扫描接口
                // 配置如何扫描接口
                .apis(RequestHandlerSelectors
                                //.any() // 扫描全部的接口，默认
                                //.none() // 全部不扫描
                                .basePackage("com.example.usercenterbackendmaster.controller") // 扫描指定包下的接口，最为常用
                        //.withClassAnnotation(RestController.class) // 扫描带有指定注解的类下所有接口
                        //.withMethodAnnotation(PostMapping.class) // 扫描带有只当注解的方法接口

                )
                .paths(PathSelectors
                                .any() // 满足条件的路径，该断言总为true
                        //.none() // 不满足条件的路径，该断言总为false（可用于生成环境屏蔽 swagger）
                        //.ant("/user/**") // 满足字符串表达式路径
                        //.regex("") // 符合正则的路径
                )
                .build();
    }

    // 基本信息设置
    private ApiInfo apiInfo() {
        Contact contact = new Contact(
                "fickler", // 作者姓名
                "fickler.cn", // 作者网址
                "2586844575@qq.com"); // 作者邮箱
        return new ApiInfoBuilder()
                .title("伙伴匹配系统-接口文档") // 标题
                .description("众里寻他千百度，慕然回首那人却在灯火阑珊处") // 描述
                .termsOfServiceUrl("https://www.baidu.com") // 跳转连接
                .version("1.0") // 版本
                .license("Swagger-的使用(详细教程)")
                .licenseUrl("https://blog.csdn.net/xhmico/article/details/125353535")
                .contact(contact)
                .build();
    }


}
```

#### 3. 配置yml文件

```yaml
  mvc:
    path match:
      matching-strategy: ant_path_matcher
```

#### 4. 运行启动

http://localhost:8080/api/swagger-ui.html#/user-controller

![image-20230406165604535](http://qiniu.fickler.top/img/image-20230406165604535.png)



### 二、Knife4j

#### 1. 引入依赖

```xml
<!-- knife4j 接口文档 -->
<dependency>
    <groupId>com.github.xiaoymin</groupId>
    <artifactId>knife4j-spring-boot-starter</artifactId>
    <version>2.0.7</version>
</dependency>
```

#### 2. 配置文件

```java
package com.example.usercenterbackendmaster.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2WebMvc;

/**
 * @author dell
 * @date 2023/4/6 16:35
 * 自定义 Swagger 接口文档配置
 */

@Configuration
@EnableSwagger2WebMvc
@Profile({"dev", "test"})   //版本控制访问
public class SwaggerConfig {

    @Bean(value = "defaultApi2")
    public Docket defaultApi2() {
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .select()
                // 这里一定要标注你控制器的位置
                .apis(RequestHandlerSelectors.basePackage("com.example.usercenterbackendmaster.controller"))
                .paths(PathSelectors.any())
                .build();
    }

    /**
     * api 信息
     * @return
     */
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title("伙伴匹配系统")
                .description("伙伴匹配系统接口文档")
                .termsOfServiceUrl("https://github.com/Worldfickler")
                .contact(new Contact("fickler","https://blog.csdn.net/qq_52354698?type=blog","2586844575@qq.com"))
                .version("1.0")
                .build();
    }
}
```

#### 3. 配置yml文件

```yaml
  mvc:
    path match:
      matching-strategy: ant_path_matcher

  profiles:
    active: dev
```

#### 4. 启动一下

http://localhost:8080/api/doc.html#/home

![image-20230406172652760](http://qiniu.fickler.top/img/image-20230406172652760.png)

#### 5. 测试接口

> 因为笔记用了云床（腾讯云），所以可能涉及到密码什么隐私性的标识会查看失败....所以这里就进行了一些打码...

![image-20230406173223135](http://qiniu.fickler.top/img/image-20230406173223135.png)

## 存量用户信息导入及同步

> 1. 把所有星球用户的信息导入
> 2. 把写了自我介绍的同学的标签信息导入
> 3. `FeHelper` 钱罐辅助插件，推荐安装

**看上了网页信息，怎么抓取？**

1. 分析原网站是怎么获取这些数据的？哪个接口？

F12 进入控制台，查看网络请求，复制 curl 代码便于查看和执行

```http
curl "https://api.zsxq.com/v2/hashtags/48844541224218/topics?count=20" ^
  -H "authority: api.zsxq.com" ^
  -H "accept: application/json, text/plain, */*" ^
  -H "accept-language: zh-CN,zh;q=0.9" ^
  -H "cache-control: no-cache" ^
  -H "cookie: zsxq_access_token=594D9AC8-11B7-946B-23A5-13755B43EE45_662C462C57CAB9C2; zsxqsessionid=07992e44e4933596449360a2492954d5; abtest_env=product" ^
  -H "origin: https://wx.zsxq.com" ^
  -H "pragma: no-cache" ^
  -H "referer: https://wx.zsxq.com/" ^
  -H "sec-ch-ua: ^\^"Google Chrome^\^";v=^\^"111^\^", ^\^"Not(A:Brand^\^";v=^\^"8^\^", ^\^"Chromium^\^";v=^\^"111^\^"" ^
  -H "sec-ch-ua-mobile: ?0" ^
  -H "sec-ch-ua-platform: ^\^"Windows^\^"" ^
  -H "sec-fetch-dest: empty" ^
  -H "sec-fetch-mode: cors" ^
  -H "sec-fetch-site: same-site" ^
  -H "user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36" ^
  -H "x-request-id: ef98ad4b4-d5ff-68be-88cf-a3b764d3f22" ^
  -H "x-signature: 305bb241ffdf60b2eaca4c70f6663cfa74571f89" ^
  -H "x-timestamp: 1680773992" ^
  -H "x-version: 2.35.0" ^
  --compressed
```

![image-20230406174205160](http://qiniu.fickler.top/img/image-20230406174205160.png)

2. 用程序去调用接口（java okhttp httpclient / python 都可以）
3. 处理（清洗）一下数据，之后就可以写到数据库里



## 流程（数据导入）

1. 从 Excel 中导入全量用户数据，**判重**

easy excel：[EasyExcel官方文档 - 基于Java的Excel处理工具 | Easy Excel (alibaba.com)](https://easyexcel.opensource.alibaba.com/index.html)

2. 住区写了自我介绍的用户信息，提取出用户昵称、用户唯一id、自我介绍信息
3. 从自我介绍中提取信息，然后写入到数据库中

**两种读对象的方式**：

1. 确定表头：建立对象，和表头形成映射关系
2. 不确定表头：每一行数据映射为 Map<String, Object>

**两种读取模式**：

1. 监听器：先创建监听器、在读取文件时绑定监听器。单独抽离处理逻辑，代码清洗，易维护；一条一条处理，适用于数据量大的场景。
2. 同步读：无需创建监听器，一次性获取完整数据。方便简单，但是数据量大时会有等待时常，也可能内存溢出。

### easy excel

![image-20230406175933517](http://qiniu.fickler.top/img/image-20230406175933517.png)

#### 1. 引入依赖

```xml
    <!-- easy Excel -->
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>easyexcel</artifactId>
        <version>3.1.0</version>
    </dependency>
```

#### 2. 新建文件夹和星球表格用户信息文件

```java
package com.example.usercenterbackendmaster.easyExcel;

import com.alibaba.excel.annotation.ExcelProperty;

/**
 * @author dell
 * @date 2023/4/6 18:08
 * 星球用户信息
 */

@Data
public class PlanetTableUserInfo {

    /**
     * 用户id
     */
    @ExcelProperty("成员编号")
    private String planetCode;

    /**
     * 用户昵称
     */
    @ExcelProperty("成员昵称")
    private String username;

}

```

#### 3. 新建监听器

```java
package com.example.usercenterbackendmaster.easyExcel;

import com.alibaba.excel.context.AnalysisContext;
import com.alibaba.excel.read.listener.ReadListener;
import lombok.extern.slf4j.Slf4j;

/**
 * @author dell
 * @date 2023/4/6 18:11
 * 监听器
 */

// 有个很重要的点 TableListener 不能被spring管理，要每次读取excel都要new,然后里面用到spring可以构造方法传进去
@Slf4j
public class TableListener implements ReadListener<PlanetTableUserInfo> {

    /**
     * 这个每一条数据解析都会来调用
     *
     * @param data    one row value. Is is same as {@link AnalysisContext#readRowHolder()}
     * @param context
     */
    @Override
    public void invoke(PlanetTableUserInfo data, AnalysisContext context) {
        System.out.println(data);
    }

    /**
     * 所有数据解析完成了 都会来调用
     *
     * @param context
     */
    @Override
    public void doAfterAllAnalysed(AnalysisContext context) {
        System.out.println("已解析完成");
    }

}
```

#### 4. 新建读取数据文件

```java
package com.example.usercenterbackendmaster.easyExcel;

import com.alibaba.excel.EasyExcel;

import java.util.List;

/**
 * @author dell
 * @date 2023/4/6 18:14
 * 导入excel，读取数据
 */
public class ImportExcel {

    /**
     * 读取数据
     */
    public static void main(String[] args) {
        // 写法1：JDK8+ ,不用额外写一个DemoDataListener
        // since: 3.0.0-beta1
        //Excel数据文件放在自己电脑上，能够找到的路径
        String fileName = "C:\\Users\\dell\\Downloads\\testExcel.xlsx";
//          readByListener(fileName);
        synchronousRead(fileName);

    }
    /**
     * 监听器读取
     * @param fileName
     */
    public static void readByListener(String fileName) {
        // 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭
        // 这里每次会读取100条数据 然后返回过来 直接调用使用数据就行
        EasyExcel.read(fileName, PlanetTableUserInfo.class, new TableListener()).sheet().doRead();
    }

    /**
     * 同步读
     * 同步的返回，不推荐使用，如果数据量大会把数据放到内存里面
     */
    public static void synchronousRead(String fileName) {
        // 这里 需要指定读用哪个class去读，然后读取第一个sheet 同步读取会自动finish
        List<PlanetTableUserInfo> list = EasyExcel.read(fileName).head(PlanetTableUserInfo.class).sheet().doReadSync();
        for (PlanetTableUserInfo planetTableUserInfo : list) {
            System.out.println(planetTableUserInfo);
        }

    }

}
```

#### 5. 运行代码

![image-20230406182033354](http://qiniu.fickler.top/img/image-20230406182033354.png)

#### 6. 导入数据库

> 这里并没有真正的导入数据库....🐶

```java
package com.example.usercenterbackendmaster.easyExcel;

import com.alibaba.excel.EasyExcel;
import org.apache.commons.lang3.StringUtils;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * @author dell
 * @date 2023/4/6 18:22
 * 导入星球数据库
 */
public class ImportPlanetUser {

    public static void main(String[] args) {
        //Excel数据文件放在自己电脑上，能够找到的路径
        String fileName = "C:\\Users\\dell\\Downloads\\testExcel.xlsx";
        // 这里 需要指定读用哪个class去读，然后读取第一个sheet 同步读取会自动finish
        List<PlanetTableUserInfo> userInfoList =
                EasyExcel.read(fileName).head(PlanetTableUserInfo.class).sheet().doReadSync();
        System.out.println("总数 = " + userInfoList.size());
        Map<String, List<PlanetTableUserInfo>> listMap =
                userInfoList.stream()
                        .filter(userInfo -> StringUtils.isNotEmpty(userInfo.getUsername()))
                        .collect(Collectors.groupingBy(PlanetTableUserInfo::getUsername));
        for (Map.Entry<String, List<PlanetTableUserInfo>> stringListEntry : listMap.entrySet()) {
            if (stringListEntry.getValue().size() > 1) {
                System.out.println("username = " + stringListEntry.getKey());
                System.out.println("1");
            }
        }
        System.out.println("不重复昵称数 = " + listMap.keySet().size());
    }

}
```

## 页面开发

### 一、搜索页面

#### 1. 新建搜索页面

1. 新建一个搜索结果页面 `SearchResultPage`

![image-20230407083214314](http://qiniu.fickler.top/img/image-20230407083214314.png)

2. 为新页面添加一个路由

![image-20230407084226374](http://qiniu.fickler.top/img/image-20230407084226374.png)

3. 添加一个搜索按钮

因为我们之前的搜索页面没有搜索按钮，所以先添加一个按钮来挑战页面

```vue
<van-button type="primary" @click="doSearchResult">搜索</van-button>
```

![image-20230407103406915](http://qiniu.fickler.top/img/image-20230407103406915.png)

4. 添加路由组件

```tsx
const router = useRouter();
```

在当前页压入一个新的地址，网页就会导航到一个新的地址

```tsx
const onClickRight = () => alert(router.push('/search'));
```

![image-20230407085300464](http://qiniu.fickler.top/img/image-20230407085300464.png)

#### 2. 前端传值

> 前端页面跳转传值
>
> 1. query => url searchParams， url 后附加参数，传递的值长度有限
> 2. vuex（全局状态管理），搜索页面将关键词塞到状态中，搜索结果页从状态中取值

1. 看一下 `vue Router` 的官方文档

![image-20230407090207597](http://qiniu.fickler.top/img/image-20230407090207597.png)

2. 将搜索的值附加到地址栏中

![image-20230407093854545](http://qiniu.fickler.top/img/image-20230407093854545.png)

```ts
  /**
   * 执行搜索
   */
  const doSearchResult = () => {
    router.push({
      path: '/search/list',
      query: {
        tags: activeIds.value
      }
    });
  }
```

3. 测试一下

搜索的值成功的添加到地址栏中，我们现在就只需要从地址栏中拿到传过来的值就可以了

![image-20230407090543529](http://qiniu.fickler.top/img/image-20230407090543529.png)

4. 看一下 `vue Router` 官方文档是如何取值

这里官方文档没有明确的介绍...🐶

直接用 `route.query`可以拿到值

![image-20230407093417903](http://qiniu.fickler.top/img/image-20230407093417903.png)

测试一下

![image-20230407093943972](http://qiniu.fickler.top/img/image-20230407093943972.png)

成功拿到值了

![image-20230407093932419](http://qiniu.fickler.top/img/image-20230407093932419.png)

#### 3. 添加信息展示组件

1. 设置一个假的用户信息

```tsx
const mockUser = {
  id: 12332,
  username: 'fickler',
  userAccount: '112221',
  avatarUrl: 'https://profile.csdnimg.cn/4/A/E/2_qq_52354698',
  gender: 0,
  phone: '12121212121',
  email: '1221112112@qq.com',
  userStatus: 0,
  userRole: 0,
  planetCode: '2332',
  tags: ['java', 'c++', 'emo'],
  createTime: new Date(),
}
```

2. 去 `vant` 组件库找一个适合我们的列表组件

![image-20230407094649958](http://qiniu.fickler.top/img/image-20230407094649958.png)

```vue
<van-card
  num="2"
  price="2.00"
  desc="描述信息"
  title="商品标题"
  thumb="https://fastly.jsdelivr.net/npm/@vant/assets/ipad.jpeg"
>
  <template #tags>
    <van-tag plain type="primary">标签</van-tag>
    <van-tag plain type="primary">标签</van-tag>
  </template>
  <template #footer>
    <van-button size="mini">按钮</van-button>
    <van-button size="mini">按钮</van-button>
  </template>
</van-card>
```

3. 我们展示页面是展示全部的用户，所以用一个 v-for 循环将 userList 组件中的全部用户都取出来

```vue
      v-for="user in userList"
```

4. 修改数据库表，增加一个用户简介

![image-20230407095111379](http://qiniu.fickler.top/img/image-20230407095111379.png)

5. 前端对应的数据类型也要增加

![image-20230407095153089](http://qiniu.fickler.top/img/image-20230407095153089.png)

6. 修改一下列表组件对应的值

> 如果网上别人的图片有防盗链应该怎么拿到呢？
>
> ```html
> <meta name="referrer" content="no-referrer">
> ```
>
> 上面的代码是将我们伪装成陌生人
>
> 对于防盗链，部分可能对陌生人不加以阻拦，那么我们就可以通过上述的方法来拿到
>
> 如果对于陌生人也进行阻拦的话那就不能通过上述方法拿到了

```vue
<template>
  <van-card
      v-for="user in userList"
      :desc="user.profile"
      :title="`${user.username} (${user.planetCode})`"
      :thumb="user.avatarUrl"
  >
    <template #tags>
      <van-tag plain type="primary" v-for="tag in user.tags" style="margin-right: 8px; margin-top: 8px">
        {{tag}}
      </van-tag>
    </template>
    <template #footer>
      <van-button size="mini">联系我</van-button>
    </template>
  </van-card>
</template>
```

![image-20230407103444141](http://qiniu.fickler.top/img/image-20230407103444141.png)

![image-20230407103537593](http://qiniu.fickler.top/img/image-20230407103537593.png)

7. 优化一下搜索按钮（太丑了🐶）

```vue
<div style="padding: 12px">
  <van-button block type="primary" @click="doSearchResult">搜索</van-button>
</div>
```

![image-20230407104048005](http://qiniu.fickler.top/img/image-20230407104048005.png)

#### 4. 对接后端接口

> 我们之前已经写了一个根据标签搜索用户的方法，但是在 `controller` 层中还没有增加对应的接口

1. 在 `controller` 层中添加一个按标签搜索用户列表的接口

```java
/**
 * 根据标签搜索用户
 * @param tagNameList 标签列表
 * @return
 */
@GetMapping("/search/tags")
public BaseResponse<List<User>> searchUserByTags(List<String> tagNameList) {
    if (CollectionUtils.isEmpty(tagNameList)) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    List<User> userList = userService.searchUsersByTags(tagNameList);
    return ResultUtils.success(userList);
}
```

#### 附加：Spring启动图标

在 `resources` 文件下，新建一个 `banner.txt` 文件，然后在文件内替换你喜欢的图标即可，或者打广告...🐶

2. 测试一下（使用我们之前的接口文档）

发送空值

![image-20230407111820951](http://qiniu.fickler.top/img/image-20230407111820951.png)

发送一个值

![image-20230407112218691](http://qiniu.fickler.top/img/image-20230407112218691.png)

依旧是不行，我们去给后端换个方法

![image-20230407112348756](http://qiniu.fickler.top/img/image-20230407112348756.png)

再测试一下传空值

![image-20230407112544436](http://qiniu.fickler.top/img/image-20230407112544436.png)

> 爆了一堆的错误信息...
>
> 我们不应该将这一堆的错误信息发送给前端

再修改一下接口，允许传空值

![image-20230407112709784](http://qiniu.fickler.top/img/image-20230407112709784.png)

再测试一下

![image-20230407112836951](http://qiniu.fickler.top/img/image-20230407112836951.png)

> 现在已经按照我们的后端处理，正常抛出错误信息了

正常传入值测试

![image-20230407112946711](http://qiniu.fickler.top/img/image-20230407112946711.png)

#### 5. 前后端对接

1. 安装一下 axios

```shell
npm install axios
```

![image-20230407113951997](http://qiniu.fickler.top/img/image-20230407113951997.png)

![image-20230407114100611](http://qiniu.fickler.top/img/image-20230407114100611.png)

2. 新建一个 `plugins` 文件夹

![image-20230407114201776](http://qiniu.fickler.top/img/image-20230407114201776.png)

3. 在 `plugins` 文件夹下，新建一个 `myAxios.js` 文件

![image-20230407114252648](http://qiniu.fickler.top/img/image-20230407114252648.png)

4. `myAxios` 基础配置

```js
import axios from "axios";

const myAxios = axios.create({
    baseURL: 'http://localhost:8080/api',
});

export default myAxios;
```

我在 baseURL 中填写我们的后端地址，这样在每次接收和向后端发送请求的时候，就不需要重复的加这个前缀了

5. `myAxios` 的请求拦截器

```js
// 添加请求拦截器
myAxios.interceptors.request.use(function (config) {
    console.log("我要发请求了！")
    // 在发送请求之前做些什么
    return config;
}, function (error) {
    // 对请求错误做些什么
    return Promise.reject(error);
});

// 添加响应拦截器
myAxios.interceptors.response.use(function (response) {
    console.log("我接收到请求了！")
    // 2xx 范围内的状态码都会触发该函数。
    // 对响应数据做点什么
    return response;
}, function (error) {
    // 超出 2xx 范围的状态码都会触发该函数。
    // 对响应错误做点什么
    return Promise.reject(error);
});
```

通过添加 axios 的请求拦截器，我们可以在接收到后端请求后做一些事情，也可以在向后端发送请求前做一些事情

6. 添加一下 axios 请求

```tsx
  onMounted(() => {
    // 上述请求也可以按以下方式完成（可选）
    myAxios.get('/user/search/tags', {
      params: {
        tagNameList: tags
      }
    })
        .then(function (response) {
          console.log('/user/search/tags success', response);
          showSuccessToast('请求成功');
        })
        .catch(function (error) {
          console.log('/user/search/tags error', error);
          showFailToast('请求失败');
        })
        .then(function () {
          // 总是会执行
        });
  })
```

7. 测试一下

![image-20230408170147797](http://qiniu.fickler.top/img/image-20230408170147797.png)

请求失败...

跨域问题！！！

#### 6. 解决报错

1. 去后端处理跨域问题

![image-20230408170527394](http://qiniu.fickler.top/img/image-20230408170527394.png)

```java
@CrossOrigin(origins = {"http://127.0.0.1:5173"})
```

后端通过配置 `@CrossOrigin(origins = {"http://127.0.0.1:5173"})` 来只允许这个域名可以向后端发送请求

> 这个只能防前端，而不能防后端，因为跨域是浏览器的问题

2. 再测试一下

![image-20230408170800462](http://qiniu.fickler.top/img/image-20230408170800462.png)

3. 通过标签搜索测试一下

![image-20230408171921931](http://qiniu.fickler.top/img/image-20230408171921931.png)

请求失败了，为什么失败了？

```http
Request URL: http://localhost:8080/api/user/search/tagstagNameList[]=%E7%94%B7&tagNameList[]=%E5%A5%B3
```

后端不认识这个带中括号的东西，我们要将它转换一下

4. 转换一下格式

[axios中get请求传参为数组/参数序列化 - 简书 (jianshu.com)](https://www.jianshu.com/p/656c22a24b69)

```tsx
import qs from 'qs';
export function getMetricList(params) {
  return axios.get(`/xxx/metrics`, {
    params,
    paramsSerializer: params => {
      return qs.stringify(params, { indices: false })
    }
  });
}
```

![image-20230408172758794](http://qiniu.fickler.top/img/image-20230408172758794.png)

5. 再测试一下

请求成功了！

![image-20230408172832854](http://qiniu.fickler.top/img/image-20230408172832854.png)

6. 给数据库添加一些假数据

![image-20230408223440494](http://qiniu.fickler.top/img/image-20230408223440494.png)

7. 前端接收一下响应的数据

```tsx
  onMounted(async () => {
    // 上述请求也可以按以下方式完成（可选）
    const userListData = await myAxios.get('/user/search/tags', {
      params: {
        tagNameList: tags
      },
      paramsSerializer: params => {
        return qs.stringify(params, { indices: false })
      }
    })
        .then(function (response) {
          console.log('/user/search/tags success', response);
          showSuccessToast('请求成功');
          console.log(response);
          return response;
        })
        .catch(function (error) {
          console.log('/user/search/tags error', error);
          showFailToast('请求失败');
        })
    if (userListData) {
      userList.value = userListData;
    }
  })
```

![image-20230409181955901](http://qiniu.fickler.top/img/image-20230409181955901.png)

可以看到，响应得到的数据是在 data 中的 data 中，修改一下前端接收响应的代码

![image-20230409182047514](http://qiniu.fickler.top/img/image-20230409182047514.png)

8. 测试一下

![image-20230409182116401](http://qiniu.fickler.top/img/image-20230409182116401.png)

tags 标签展示错误了，因为我们后端 tags 标签是 json 格式，但是前端将其识别成了字符串，这里我们要转换一下

9. 在前端将将 tags 转换为 json 格式

```tsx
    if (userListData) {
      userListData.forEach(user => {
        if (user.tags) {
          user.tags = JSON.parse(user.tags);
        }
      })
      userList.value = userListData;
    }
```

![image-20230409182758459](http://qiniu.fickler.top/img/image-20230409182758459.png)

10. 添加一个数据为空的提示

![image-20230409183039115](http://qiniu.fickler.top/img/image-20230409183039115.png)

```vue
<van-empty description="描述文字" />
```

![image-20230409183201783](http://qiniu.fickler.top/img/image-20230409183201783.png)

### 二、登录页面

#### 1. 新建登录页面

1. 新建一个登录页面 `UserLoginPage`

![image-20230410102026187](http://qiniu.fickler.top/img/image-20230410102026187.png)

2. 增加一个登录页面的路由

![image-20230410102207689](http://qiniu.fickler.top/img/image-20230410102207689.png)

3. 增加一个登录表单项

![image-20230410102910078](http://qiniu.fickler.top/img/image-20230410102910078.png)

```vue
  <van-form @submit="onSubmit">
    <van-cell-group inset>
      <van-field
          v-model="username"
          name="用户名"
          label="用户名"
          placeholder="用户名"
          :rules="[{ required: true, message: '请填写用户名' }]"
      />
      <van-field
          v-model="password"
          type="password"
          name="密码"
          label="密码"
          placeholder="密码"
          :rules="[{ required: true, message: '请填写密码' }]"
      />
    </van-cell-group>
    <div style="margin: 16px;">
      <van-button round block type="primary" native-type="submit">
        提交
      </van-button>
    </div>
  </van-form>
```

```ts
import {ref} from "vue";

const userAccount = ref('');
const userPassword = ref('');
const onSubmit = (values) => {
  console.log('submit', values);
};
```

4. 修改一下，使其适用后端

```vue
  <van-form @submit="onSubmit">
    <van-cell-group inset>
      <van-field
          v-model="userAccount"
          name="账号"
          label="账号"
          placeholder="请输入账号"
          :rules="[{ required: true, message: '请填写用户名' }]"
      />
      <van-field
          v-model="userPassword"
          type="password"
          name="密码"
          label="密码"
          placeholder="请输入密码"
          :rules="[{ required: true, message: '请填写密码' }]"
      />
    </van-cell-group>
    <div style="margin: 16px;">
      <van-button round block type="primary" native-type="submit">
        提交
      </van-button>
    </div>
  </van-form>
```

#### 2. 编写提交事件

```tsx
const onSubmit = async () => {
  const res = await myAxios.post('/user/login', {
    userAccount: userAccount.value,
    userPassword: userPassword.value,
  })
  console.log(res, "用户登录");
  if (res.code == 0 && res.data) {
    showSuccessToast("登录成功");
    router.replace("/");
  } else {
    showFailToast("登录失败");
  }
};
```

#### 3. 测试

1. 由于我们还没有编写登录页面的入口，所以直接输入地址访问

`http://127.0.0.1:5173/#/user/login`

![image-20230410104309580](http://qiniu.fickler.top/img/image-20230410104309580.png)

显示登录失败，但是已经拿到值了

![image-20230410104416309](http://qiniu.fickler.top/img/image-20230410104416309.png)

2. 修改一下取值

![image-20230410104536449](http://qiniu.fickler.top/img/image-20230410104536449.png)

可以看到，我们要拿的数据在响应 response 中的 data 中的 data

我们直接修改全局响应拦截器取值的地方

![image-20230410104714416](http://qiniu.fickler.top/img/image-20230410104714416.png)

3. 再测试一下

![image-20230410104742221](http://qiniu.fickler.top/img/image-20230410104742221.png)

### 三、用户信息页

#### 1. 将 myAxios,js 修改我 .ts 文件

![image-20230410001745772](http://qiniu.fickler.top/img/image-20230410001745772.png)

#### 2. 获取当前用户登录信息

```tsx
onMounted(async () => {
  const res = await myAxios.get('/user/current');
  if (res.code === 0) {
    user.value = res.data;
    showSuccessToast("获取用户信息成功");
  } else {
    showFailToast("获取用户信息失败");
  }
})
```

#### 3. 测试

![image-20230410112153927](http://qiniu.fickler.top/img/image-20230410112153927.png)

1. 我们添加一个 v-if，如果用户信息存在我们展示，不存在我们就不进行展示了

```vue
<template>
  <div v-if="user">
    <van-cell title="昵称" is-link to="/user/edit" :value="user.username" />
    <van-cell title="账号" :value="user.userAccount" />
    <van-cell title="头像" is-link to="/user/edit">
      <img style="height: 48px" :src="user.avatarUrl" />
    </van-cell>
    <van-cell title="性别" is-link to="/user/edit" :value="user.gender" @click="toEdit('gender', '性别', user.gender)" />
    <van-cell title="电话" is-link to="/user/edit" :value="user.phone" @click="toEdit('phone', '电话', user.phone)" />
    <van-cell title="邮箱" is-link to="/user/edit" :value="user.email" />
    <van-cell title="星球编号" :value="user.planetCode" />
    <van-cell title="注册时间" :value="user.createTime.toISOString()" />
  </div>
</template>
```

2. 再测试一下

![image-20230410112551851](http://qiniu.fickler.top/img/image-20230410112551851.png)

不报错了，但是获取用户信息失败了

![image-20230410112636494](http://qiniu.fickler.top/img/image-20230410112636494.png)

3. 分析失败原因

> 前端向后端发送请求的时候没有携带上 cookie

![image-20230410115045721](http://qiniu.fickler.top/img/image-20230410115045721.png)

4. axios 开启携带 cookie

```tsx
axios.defaults.withCredentials = true; // 请求携带 cookie
```

> **出错了😭**
>
> 1. 配置后出现了跨域问题：[axios 添加 withCredentials = true 后出现了跨域问题_在人间负债^的博客-CSDN博客](https://blog.csdn.net/qq_52354698/article/details/130059079?spm=1001.2014.3001.5501)
>
> 2. 前端设置了携带 cookie 后，浏览器依旧不能携带 cookie：

5. 再测试一下

![image-20230410143909793](http://qiniu.fickler.top/img/image-20230410143909793.png)

6. 修改一下时间的格式

![image-20230410144206358](http://qiniu.fickler.top/img/image-20230410144206358.png)

![image-20230410144949748](http://qiniu.fickler.top/img/image-20230410144949748.png)

### 四、用户修改页面

#### 1. 后端用户个人信息修改接口

1. 编写获取当前用户信息的方法

```java
@Override
public User getLoginUser(HttpServletRequest request) {
    if (request == null) {
        return null;
    }
    Object userObj = request.getSession().getAttribute(USER_LOGIN_STATE);
    if (userObj == null) {
        throw new BusinessException(ErrorCode.NO_AUTH);
    }
    return (User) userObj;
}
```

2. 将之前的判断用户是否为管理员抽象为一个公共方法

这里再重写一个判断是否为管理员的方法

```java
    /**
     * 是否为管理员
     * @param request 用户登录状态
     * @return
     */
    @Override
    public boolean isAdmin(HttpServletRequest request) {
        Object userObj = request.getSession().getAttribute(USER_LOGIN_STATE);
        User user = (User) userObj;
        return user != null && user.getUserRole() == UserConstant.ADMIN_ROLE;
    }

    /**
     * 是否为管理员
     * @param loginUser 用户登录状态
     * @return
     */
    @Override
    public boolean isAdmin(User loginUser) {
        return loginUser != null && loginUser.getUserRole() == UserConstant.ADMIN_ROLE;
    }
```

3. 编写用户个人信息修改 `service` 方法

```java
    /**
     * 更新用户信息
     * @param user 用户信息
     * @return
     */
    Integer updateUser(User user, User loginUser);
```

4. 编写用户个人信息修改 `serviceimpl` 接口

```java
    @Override
    public Integer updateUser(User user, User loginUser) {
        long userId = user.getId();
        if (userId <= 0) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        // 如果是管理员，允许更新任意用户
        // 如果不是管理员，只允许更新当前信息
        if (!isAdmin(loginUser) && userId != loginUser.getId()) {
            throw new BusinessException(ErrorCode.NO_AUTH);
        }
        User oldUser = userMapper.selectById(userId);
        if (oldUser == null) {
            throw new BusinessException(ErrorCode.NULL_ERROR);
        }
        return userMapper.updateById(user);
    }
```

5. 编写用户个人信息修改 `controller` 层方法

```java
    /**
     * 更新用户信息
     * @param user 用户信息
     * @param request 用户登录状态
     * @return
     */
    @PostMapping("/update")
    public BaseResponse<Integer> updateUser(@RequestBody User user, HttpServletRequest request) {
        // 校验参数是否为空
        if (user == null) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        User loginUser = userService.getLoginUser(request);
        int result = userService.updateUser(user, loginUser);
        return ResultUtils.success(result);
    }
```

#### 2. 将获取当前用户抽取为公共方法

1. 新建一个 `service` 文件夹

![image-20230410150548799](http://qiniu.fickler.top/img/image-20230410150548799.png)

> 我们在该文件夹下定义一些向后端发送请求的方法

2. 在 `service` 文件夹下新建一个 `user.ts` 文件

![image-20230410150947911](http://qiniu.fickler.top/img/image-20230410150947911.png)

3. 编写方法

```tsx
import myAxios from "../plugins/myAxios";

export const getCurrentUser = async () => {
    return await myAxios.get('/user/current');
}
```

### 3. 将用户登录信息缓存在前端

1. 新建一个 `states` 文件夹

![image-20230411000127746](http://qiniu.fickler.top/img/image-20230411000127746.png)

2. 在 `states` 文件夹下新建一个 `user.ts` 文件

![image-20230411000218822](http://qiniu.fickler.top/img/image-20230411000218822.png)

3. 编写缓存逻辑

```tsx
import {UserType} from "../models/user";

let currentUser : UserType;

const setCurrentUserState = (user : UserType) => {
    currentUser = user;
}

const getCurrentUserState = () : UserType => {
    return currentUser;
}

export {
    setCurrentUserState,
    getCurrentUserState,
}
```

4. 修改之前的的获取当前用户信息的代码

```tsx
import myAxios from "../plugins/myAxios";
import {getCurrentUserState, setCurrentUserState} from "../states/user";

export const getCurrentUser = async () => {
    const currentUser = getCurrentUserState();
    if (currentUser) {
        return currentUser;
    }
    // 不存在则从远程获取
    const res = await myAxios.get('/user/current');
    if (res.code === 0) {
        setCurrentUserState(res.data);
        return res.data;
    }
    return null;
}
```

#### 4. 前端对接一下

1. 编写更新请求 axios

```tsx
const onSubmit = async () => {

  const currentUser = await getCurrentUser();

  if (!currentUser) {
    showFailToast("用户未登录");
    return;
  }

  const res = await myAxios.post('/user/update', {
    'id': currentUser.id,
    [editUser.value.editKey]: editUser.value.currentValue,
  })
  if (res.data > 0 && res.code === 0 ) {
    showSuccessToast("修改成功！");
    router.back();
  } else {
    showFailToast("修改错误！");
  }
};
```

2. 测试一下

![image-20230411002133000](http://qiniu.fickler.top/img/image-20230411002133000.png)

获取用户信息失败

分析可知，我们返回的就是 `.data` 数据了，所以需要将之前的代码修改一下

3. 修改历史代码

![image-20230411002312989](http://qiniu.fickler.top/img/image-20230411002312989.png)

4. 再测试一下

![image-20230411002328639](http://qiniu.fickler.top/img/image-20230411002328639.png)

5. 测试一下修改用户信息

![image-20230411004624578](http://qiniu.fickler.top/img/image-20230411004624578.png)

修改成功，按时用户信息页并没有更新，为什么？

> 因为我们将用户一开始登录的信息存到了缓存中，用户更新信息后，缓存中的信息并没有及时的更新

6. 每次更新，我们重新从后端获取信息，并更新到缓存中

```tsx
const onSubmit = async () => {

  const currentUser = await getCurrentUser();

  if (!currentUser) {
    showFailToast("用户未登录");
    return;
  }

  const res = await myAxios.post('/user/update', {
    'id': currentUser.id,
    [editUser.value.editKey]: editUser.value.currentValue,
  })
  if (res.data > 0 && res.code === 0 ) {
    showSuccessToast("修改成功！");
    const updateUser = await myAxios.get('/user/current');
    if (updateUser.code === 0) {
      setCurrentUserState(updateUser.data);
    }
    router.back();
  } else {
    showFailToast("修改错误！");
  }
};
```

7. 再测试一下

修改成功，并且在个人信息页面更新了信息

![image-20230411005538242](http://qiniu.fickler.top/img/image-20230411005538242.png)

### 五、主页面

#### 1. 修改主页面的展示

1. 主页面的展示和搜索结果页面相似，我们直接将搜索结果页面的代码复制过来

![image-20230411082444992](http://qiniu.fickler.top/img/image-20230411082444992.png)

2. 修改部分地方

![image-20230411082647713](http://qiniu.fickler.top/img/image-20230411082647713.png)

#### 2. 开发后端接口

在后端 `controller` 层中添加方法

```java
    /**
     * 首页推荐
     * @param request 用户登录信息
     * @return
     */
    @GetMapping("/recommend")
    public BaseResponse<List<User>> recommendUsers(HttpServletRequest request) {
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        List<User> userList = userService.list(queryWrapper);
        List<User> result = userList.stream().map(user -> userService.getSafetyUser(user)).collect(Collectors.toList());
        return ResultUtils.success(result);
    }
```

#### 3. 测试效果

1. 回到页面查看效果

![image-20230411083436201](http://qiniu.fickler.top/img/image-20230411083436201.png)

2. 可以正常拿到数据，但是展示的时候有个小 bug，最后一个用户展示不完全

![image-20230411083523283](http://qiniu.fickler.top/img/image-20230411083523283.png)

3. 修改一下布局

```css
#content {
  padding-bottom: 50px;
}
```

![image-20230411083947484](http://qiniu.fickler.top/img/image-20230411083947484.png)

#### 4. 优化

我们在搜索结果页面和主页面都使用到了 `van-card` 这个组件，且十分的相似，因此我们可以将这个组件抽取为一个公共组件

1. 在 `components` 文件夹下新建 `UserCardList` 组件

![image-20230411084951706](http://qiniu.fickler.top/img/image-20230411084951706.png)

2. 编写公共组件

```vue
<template>
  <van-card
      v-for="user in props.userList"
      :desc="user.profile"
      :title="`${user.username} (${user.planetCode})`"
      :thumb="user.avatarUrl"
  >
    <template #tags>
      <van-tag plain type="primary" v-for="tag in user.tags" style="margin-right: 8px; margin-top: 8px">
        {{tag}}
      </van-tag>
    </template>
    <template #footer>
      <van-button size="mini">联系我</van-button>
    </template>
  </van-card>
</template>

<script setup lang="ts">

import {UserType} from "../models/user";

interface UserCardListProps {
  userList: UserType[];
}

const props = defineProps<UserCardListProps>();

</script>

<style scoped>

</style>
```

3. 将之前 `index` 和 `searchresult` 页面中的卡片组件替换成公共组件

![image-20230411085524408](http://qiniu.fickler.top/img/image-20230411085524408.png)

## 分布式session登录

种 session 的时候注意范围，cookie.domian

```yaml
    session:
      cookie:
        domain: 
```

![image-20230409191958011](http://qiniu.fickler.top/img/image-20230409191958011.png)

比如两个域名：

aaa.yuipi.com

bbb.yupi.com

如果要共享 cookie，可以种一个更高层的公共域名，比如 yupi.com

**为什么服务器 A 登录后，请求发到服务器 B，不认识该用户？**

用户在 A 登录，所以 session （用户登录信息）存在了 A 上

结果请求 B 时，B 没有用户信息，所以不认识

![image.png](http://qiniu.fickler.top/img/1669261508769-827a7a9d-0154-4ba8-835e-5532469c96a6.png)

解决方案：**共享存储**，而不是把数据放到单台服务器的内存中

![image.png](http://qiniu.fickler.top/img/1669261508796-2a7e4371-9ad7-466a-9e8b-533fb6679221.png)

### session 共享实现 Redis

如何共享存储？

1. Redis（基于内存的 K / V 数据库）【此处使用 Redis：因为用户信息读取 / 是否登录的判断及其**频繁**，Redis 基于内存，读写性能很高，简单的数据单机 qps 5w - 10w】
2. MySQL
3. 文件服务器 each

#### 1. 下载安装 redis

官网：[Redis](https://redis.io/)

Redis 5.0.14 下载：

链接：https://pan.baidu.com/s/1XcsAIrdeesQAyQU2lE3cOg

提取码：vkoi 

redis 管理工具 quick redis：[QuickOfficial - QuickRedis (quick123.net)](https://quick123.net/)

#### 2. 整合 redis

1. 引入 redis，能够操作 redis

> redis 的版本一定要和 springboot 的版本一致

```xml
  <!-- redis -->
        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
            <version>2.6.4</version>
        </dependency>
```

2. redis 配置

```yaml
#redis
redis:
  port: 6379
  host: localhost
  database: 0
```

3. 引入 spring-session 和 redis 的整合，使得自动将 session 存储到 redis 中

```xml
 <!-- session-data-redis -->
        <!-- https://mvnrepository.com/artifact/org.springframework.session/spring-session-data-redis -->
        <dependency>
            <groupId>org.springframework.session</groupId>
            <artifactId>spring-session-data-redis</artifactId>
            <version>2.6.3</version>
        </dependency>
```

4. 修改 session 的配置

> 存储配置 spring.session.store-type
>
> 默认是 none，表示存储在单台服务器
>
> store-type: redis，表示从 redis 读写 session

```yaml
  session:
    timeout: 86400
    store-type: redis
```

#### 3. 测试

1. 使用 quickredis 连接 redis

![image-20230409201837638](http://qiniu.fickler.top/img/image-20230409201837638.png)

2. 登录测试一下

![image-20230409201930065](http://qiniu.fickler.top/img/image-20230409201930065.png)

3. 去 quickredis 中查看一下

> 可以看到成功将 cookie 存储到 redis 中了
>
> 看不懂存的什么？正常，因为这是 java 序列化之后存储的

![image-20230409202016076](http://qiniu.fickler.top/img/image-20230409202016076.png)

4. 测试一下是否可以获取当前登录态

![image-20230409202129604](http://qiniu.fickler.top/img/image-20230409202129604.png)



## 模拟千万用户

### 一、数据导入

#### 1. 可视化界面

![image-20230411091059903](http://qiniu.fickler.top/img/image-20230411091059903.png)

#### 2. sql语句

```sql
insert into MY_TABLE (id, first_name, last_name, birth) values (10001, 'Georgi', 'Facello', 'M');
insert into MY_TABLE (id, first_name, last_name, birth) values (10002, 'Bezalel', 'Simmel', 'F');
insert into MY_TABLE (id, first_name, last_name, birth) values (10003, 'Parto', 'Bamford', 'M');
insert into MY_TABLE (id, first_name, last_name, birth) values (10004, 'Chirstian', 'Koblick', 'M');
insert into MY_TABLE (id, first_name, last_name, birth) values (10005, 'Kyoichi', 'Maliniak', 'M');
insert into MY_TABLE (id, first_name, last_name, birth) values (10006, 'Anneke', 'Preusig', 'F');
insert into MY_TABLE (id, first_name, last_name, birth) values (10007, 'Tzvetan', 'Zielinski', 'F');
insert into MY_TABLE (id, first_name, last_name, birth) values (10008, 'Saniya', 'Kalloufi', 'M');
insert into MY_TABLE (id, first_name, last_name, birth) values (10009, 'Sumant', 'Peac', 'F');
insert into MY_TABLE (id, first_name, last_name, birth) values (10010, 'Duangkaew', 'Piveteau', 'F');

```

#### 2. 写程序

for 循环，建议分批，不要一把梭哈（可以用接口控制）**要保证可控**

### 二、定时任务

#### 1. 开启定时任务

直接使用 springboot 注解开始定时任务

```java
@EnableScheduling
```

![image-20230411094542832](http://qiniu.fickler.top/img/image-20230411094542832.png)

#### 2. 编写一次性任务

1. 新建一个 `InsertUser` 方法

![image-20230411094716936](http://qiniu.fickler.top/img/image-20230411094716936.png)

2. 添加 `Component` 注解

![image-20230411094822923](http://qiniu.fickler.top/img/image-20230411094822923.png)

3. 编写相关代码

```java
package com.example.usercenterbackendmaster.easyExcel;

import com.example.usercenterbackendmaster.mapper.UserMapper;
import com.example.usercenterbackendmaster.model.domain.User;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import org.springframework.util.StopWatch;

import javax.annotation.Resource;

/**
 * @author dell
 * @date 2023/4/11 9:47
 */

@Component
public class InsertUsers {

    @Resource
    private UserMapper userMapper;

    @Scheduled(initialDelay = 5000,fixedRate = Long.MAX_VALUE )
    public void doInsertUser() {
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        final int INSERT_NUM = 1000;
        for (int i = 0; i < INSERT_NUM; i++) {
            User user = new User();
            user.setUsername("假用户");
            user.setUserAccount("fakeUser");
            user.setAvatarUrl("https://p.qqan.com/up/2021-8/16280413188390471.jpg");
            user.setProfile("一条咸鱼");
            user.setGender(0);
            user.setUserPassword("12345678");
            user.setPhone("123456789108");
            user.setEmail("2586844575@qq.com");
            user.setUserStatus(0);
            user.setUserRole(0);
            user.setPlanetCode("931");
            user.setTags("[]");
            userMapper.insert(user);
        }
        stopWatch.stop();
        System.out.println( stopWatch.getLastTaskTimeMillis());

    }

}
```

### 三、数据插入

新建单元测试 `InsertUserTest.java`，并将刚刚的爱慕复制过来

> **用户插入单元测试，注意打包时要删掉欧哲忽略，不然打包一次就插入一次！！！**

![image-20230411101507338](http://qiniu.fickler.top/img/image-20230411101507338.png)

#### 1. for循环插入

```java
    /**
     * for循环插入
     */
    @Test
    public void doInsertUser1() {
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        final int INSERT_NUM = 1000;
        for (int i = 0; i < INSERT_NUM; i++) {
            User user = new User();
            user.setUsername("假用户");
            user.setUserAccount("fakeUser");
            user.setAvatarUrl("https://p.qqan.com/up/2021-8/16280413188390471.jpg");
            user.setProfile("一条咸鱼");
            user.setGender(0);
            user.setUserPassword("12345678");
            user.setPhone("123456789108");
            user.setEmail("2586844575@qq.com");
            user.setUserStatus(0);
            user.setUserRole(0);
            user.setPlanetCode("931");
            user.setTags("[]");
            userMapper.insert(user);
        }
        stopWatch.stop();
        System.out.println( stopWatch.getLastTaskTimeMillis());

    }
```

![image-20230411102059975](http://qiniu.fickler.top/img/image-20230411102059975.png)

for 循环插入数据的问题

1. 每次插入数据都要建立和释放数据库链接
2. for 循环是绝对线性的

#### 2. 批量插入

> 解决了**每次插入数据都要建立和释放数据库链接**

mybatis-plus 帮我们实现了批量插入

```java
    /**
     * 批量插入
     */
    @Test
    public void doInsertUser2() {
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        final int INSERT_NUM = 1000;
        List<User> userList = new ArrayList<>();
        for (int i = 0; i < INSERT_NUM; i++) {
            User user = new User();
            user.setUsername("假用户");
            user.setUserAccount("fakeUser");
            user.setAvatarUrl("https://p.qqan.com/up/2021-8/16280413188390471.jpg");
            user.setProfile("一条咸鱼");
            user.setGender(0);
            user.setUserPassword("12345678");
            user.setPhone("123456789108");
            user.setEmail("2586844575@qq.com");
            user.setUserStatus(0);
            user.setUserRole(0);
            user.setPlanetCode("931");
            user.setTags("[]");
            userList.add(user);
        }
        userService.saveBatch(userList);
        stopWatch.stop();
        System.out.println( stopWatch.getLastTaskTimeMillis());

    }
```

> 10个为一批进行插入，每插入10个建立和断开一次链接

![image-20230411103023043](http://qiniu.fickler.top/img/image-20230411103023043.png)

#### 3. 并发插入

> 解决了**for循环是绝对线性的**



并发插入（这里数据量是100000）

并发要注意执行的先后顺序无所谓，不要用到非并发类的集合

```java
private ExecutorService executorService = new ThreadPoolExecutor(16, 1000, 10000, TimeUnit.MINUTES, new ArrayBlockingQueue<>(10000));
```

// CPU 密集型：分配的核心线程数 = CPU - 1

// IO 密集型：分配的核心线程数可以大于 CPU 核数

```java
	    //线程设置
    private ExecutorService executorService = new ThreadPoolExecutor(16, 1000, 10000, TimeUnit.MINUTES, new ArrayBlockingQueue<>(10000));


	/**
     * 并发批量插入
     */
    @Test
    public void doInsertUser3() {
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        final int INSERT_NUM = 100000;
        // 分十组
        int j = 0;
        //批量插入数据的大小
        int batchSize = 5000;
        List<CompletableFuture<Void>> futureList = new ArrayList<>();
        // i 要根据数据量和插入批量来计算需要循环的次数。（鱼皮这里直接取了个值，会有问题,我这里随便写的）
        for (int i = 0; i < INSERT_NUM/batchSize; i++) {
            List<User> userList = new ArrayList<>();
            while (true){
                j++;
                User user = new User();
                user.setUsername("假用户");
                user.setUserAccount("fakeUser");
                user.setAvatarUrl("https://p.qqan.com/up/2021-8/16280413188390471.jpg");
                user.setProfile("一条咸鱼");
                user.setGender(0);
                user.setUserPassword("12345678");
                user.setPhone("123456789108");
                user.setEmail("2586844575@qq.com");
                user.setUserStatus(0);
                user.setUserRole(0);
                user.setPlanetCode("931");
                user.setTags("[]");
                userList.add(user);
                if (j % batchSize == 0 ){
                    break;
                }
            }
            //异步执行
            CompletableFuture<Void> future = CompletableFuture.runAsync(() ->{
                System.out.println("ThreadName：" + Thread.currentThread().getName());
                userService.saveBatch(userList,batchSize);
            },executorService);
            futureList.add(future);
        }
        CompletableFuture.allOf(futureList.toArray(new CompletableFuture[]{})).join();

        stopWatch.stop();
        System.out.println( stopWatch.getLastTaskTimeMillis());

    }
```

![image-20230411104155464](http://qiniu.fickler.top/img/image-20230411104155464.png)



### 四、分页查询

#### 1. 重启项目

刷新前端页面，查询时间 9s，且查询完后，并没有在页面上展示出来（因为数据量太大了）

![image-20230411110947803](http://qiniu.fickler.top/img/image-20230411110947803.png)

直接崩溃掉了....

![image-20230411111943162](http://qiniu.fickler.top/img/image-20230411111943162.png)

#### 2. 使用分页查询

[插件主体 | MyBatis-Plus (baomidou.com)](https://baomidou.com/pages/2976a3/#spring-boot)

1. 添加 mybatis-plus 分页的拦截器

```java
@Configuration
@MapperScan("scan.your.mapper.package")
public class MybatisPlusConfig {

    /**
     * 新的分页插件,一缓和二缓遵循mybatis的规则,需要设置 MybatisConfiguration#useDeprecatedExecutor = false 避免缓存出现问题(该属性会在旧插件移除后一同移除)
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.H2));
        return interceptor;
    }

    @Bean
    public ConfigurationCustomizer configurationCustomizer() {
        return configuration -> configuration.setUseDeprecatedExecutor(false);
    }
}
```

2. 复制到我们的 `config` 文件夹下

```java
package com.example.usercenterbackendmaster.config;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.autoconfigure.ConfigurationCustomizer;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@MapperScan("com.example.usercenterbackendmaster.mapper")
public class MybatisPlusConfig {

    /**
     * 新的分页插件,一缓和二缓遵循mybatis的规则,需要设置 MybatisConfiguration#useDeprecatedExecutor = false 避免缓存出现问题(该属性会在旧插件移除后一同移除)
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return interceptor;
    }

}
```

![image-20230411111305125](http://qiniu.fickler.top/img/image-20230411111305125.png)

3. 修改 `controller` 层的 `recommend` 方法（改为分页查询）

```java
/**
 * 首页推荐（分页查询）
 * @param request 用户登录信息
 * @return
 */
@GetMapping("/recommend")
public BaseResponse<Page<User>> recommendUsers(long pageSize, long pageNum, HttpServletRequest request) {
    QueryWrapper<User> queryWrapper = new QueryWrapper<>();
    Page<User> userList = userService.page(new Page<>(pageNum, pageSize), queryWrapper);
    return ResultUtils.success(userList);
}
```

4. 对应的前端也进行修改

![image-20230411111726467](http://qiniu.fickler.top/img/image-20230411111726467.png)

5. 运行测试

![image-20230411112011404](http://qiniu.fickler.top/img/image-20230411112011404.png)

## 缓存迅速查询

### 一、数据查询满怎么办？

用缓存：提前把数据取出来保存好（通常保存到读写更快的介质，比如内存），就可以更快的读写。

#### 1. 缓存的实现

- Redis（分布式缓存）
- memcached（分布式）
- Etcd（云原生架构的一个分布式存储，**存储配置**，扩容能力）
- ehcache（单机）
- 本地缓存（Java 内存 Map）
- Caffeine（Java 内存缓存，高性能）
- Google Guava

#### 2. Redis

> NoSQL 数据库

key-value 存储系统（区别与 MySql，redis 存储的是键值对）

**Redis 数据结构**

String 字符串类型：name: “yupi”

List 列表：names: [“yupi”, “dogyupi”, “yupi”]

Set 集合：names: [“yupi”, “dogyupi”]（值不能重复）

Hash 哈希：nameAge: {“yupi”: 1, “dogyupi”: 2}

Zset 集合：names: { yupi - 9, dogyupi - 12} （适合做排行榜）



bloomfilter（布隆过滤器，主要从大量的数据中快速过滤值，比如邮件黑名单拦截）

geo（计算地理位置）

hyperloglog（pv / uv）

pub / sub（发布订阅，类似消息队列）

BitMap（1000100101010100100101010101）

### 二、Java里的实现方式

#### 1. 分类

- **Spring Data Redis（推荐）**

- **Spring Data**
  - 通用的数据访问框架，定义了一组增删改查的接口，mysql、redis、jps...
- Jedis
  - 独立于 spring 操作 redis 的 java 客户端，要配合 jedis Pool 使用
- Lettuce
  - **高阶**的操作 Redis 的 Java 客户端
  - 异步、连接池
- Redisson
  - 分布式操作 Redis 的 Java 客户端，让你像在本地的集合一样操作 redis（分布式 redis 数据网格）

#### 2. 对比

1. 如果你用的是 spring，并且没有过多的定制化要求，可以使用 Spring Data Redis，最方便
2. 如果你用的不是 Spring，并且追求简单，并且没有过高的性能要求，可以用 Jedis + Jedis Pool
3. 如果你的项目不是 Spring，并且追求高性能、高定制化，可以用 Lettuce，支持异步、连接池
4. 如果你的项目是分布式的，需要用到一些分布式的特性（比如分布式锁、分布式集合），推荐用 redisson

### 三、Redis整合测试

#### 1. 引入

1. xml 依赖

```xml
       <!-- redis -->
        <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
            <version>2.6.4</version>
        </dependency>
```

2. yaml 配置

```yaml
  #redis
  redis:
    port: 6379
    host: localhost
    database: 0
```

#### 2. 测试

1. 新建一个测试类 `RedisTest.java`

![image-20230411164053701](http://qiniu.fickler.top/img/image-20230411164053701.png)

2. 编写测试类代码

```java
package com.example.usercenterbackendmaster;

import com.example.usercenterbackendmaster.model.domain.User;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.ValueOperations;

import javax.annotation.Resource;

/**
 * @author dell
 * @date 2023/4/11 16:40
 */

@SpringBootTest
public class RedisTest {

    @Resource
    private RedisTemplate redisTemplate;

    @Test
    void test() {
        ValueOperations valueOperations = redisTemplate.opsForValue();
        // 增
        valueOperations.set("shayuString", "fish");
        valueOperations.set("shayuInt", 1);
        valueOperations.set("shayuDouble", 2.0);
        User user = new User();
        user.setId(1L);
        user.setUsername("shayu");
        valueOperations.set("shayuUser", user);

        // 查
        Object shayu = valueOperations.get("shayuString");
        Assertions.assertTrue("fish".equals((String) shayu));
        shayu = valueOperations.get("shayuInt");
        Assertions.assertTrue(1 == (Integer) shayu);
        shayu = valueOperations.get("shayuDouble");
        Assertions.assertTrue(2.0 == (Double) shayu);
        System.out.println(valueOperations.get("shayuUser"));
        valueOperations.set("shayuString", "fish");

        //删
//        redisTemplate.delete("shayuString");
    }

}
```

3. 配置序列化

```java
package com.example.usercenterbackendmaster.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializer;

@Configuration
public class RedisTemplateConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
        //创建RedisTemplate对象
        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();
       //设置连接工厂
        redisTemplate.setConnectionFactory(connectionFactory);
        //设置Key的序列化
        redisTemplate.setKeySerializer(RedisSerializer.string());

        //创建Json序列化工具
        GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer();
        //设置Value的序列化
        redisTemplate.setValueSerializer(jsonRedisSerializer);

        return redisTemplate;
    }
}
```

4. 进入 QuickRedis 查看

![image-20230411171604977](http://qiniu.fickler.top/img/image-20230411171604977.png)

### 四、数据缓存

#### 1. 设计缓存key

不同用户看到的数据不同

`systemId:moduleId:func:options`（不要和别人冲突）

`matchup:user:recommend:userId`

**redis 内存不能无限增加，一定要设置过期时间！！！**

#### 2. 修改主页推荐接口

```java
    /**
     * 首页推荐（分页查询）
     * @param request 用户登录信息
     * @return
     */
    @GetMapping("/recommend")
    public BaseResponse<Page<User>> recommendUsers(long pageSize, long pageNum, HttpServletRequest request) {
        User loginUser = userService.getLoginUser(request);
        String redisKey = String.format("matchup:user:recommend%s", loginUser.getId());
        ValueOperations valueOperations = redisTemplate.opsForValue();
        // 如果有缓存，直接读取
        Page<User> userPage = (Page<User>) valueOperations.get(redisKey);
        if (userPage != null) {
            return ResultUtils.success(userPage);
        }
        // 无缓存，查数据库
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        userPage = userService.page(new Page<>(pageNum, pageSize), queryWrapper);
        // 写缓存，10s过期
        try {
            valueOperations.set(redisKey, userPage, 30000, TimeUnit.MILLISECONDS);
        } catch (Exception e) {
            log.error("redis set key error", e);
        }
        return ResultUtils.success(userPage);
    }
```

#### 3. 测试一下

1. 刷新主页面，查看第一次加载时间

![image-20230412115946611](http://qiniu.fickler.top/img/image-20230412115946611.png)

2. 再次刷新，查看时间

![image-20230412120004545](http://qiniu.fickler.top/img/image-20230412120004545.png)

很明显，有一个质的提升

3. 去 quickredis 中查看一下 redis 缓存

![image-20230412120110454](http://qiniu.fickler.top/img/image-20230412120110454.png)

### 五、缓存预热

**问题：**第一个用户访问还是很慢，例如双十一时，大量用户第一次访问，都要读数据库，会直接崩掉，因此缓存预热可以一定程度上保护数据库

**缓存预热的优点：**

1. 解决上面的问题，可以让用户始终访问很快

**缺点：**

1. 增加开发成本（额外的开发，设计）
2. 预热的时机和时间，如果错了，可能缓存的数据不对
3. 需要占用空间

#### 1. 怎么缓存预热

1. 定时触发
2. 模拟触发（手动触发）

**实现**

用定时任务，每天刷新所有用户的推荐列表

注意点：

1. 缓存预热的意义（新增少，总用户多）
2. 缓存的空间不能太大，要预留其他缓存的空间
3. 缓存数据的周期（一天一次）

#### 2. 定时任务实现

> 1. Spring Scheduler（springboot 默认整合了）
> 2. Quartz（独立于 spring 存在的定时任务框架）
> 3. XXL-Job 之类的分布式任务调度平台
>
> 第一种方式：
>
> 1. 主类开启 `@EnableScheduling`
> 2. 给要定时执行的方法添加 `@EnableScheduling ` 注解，指定 corn 表达式或执行频率

1. 新建一个 `job` 文件夹

![image-20230412222207023](http://qiniu.fickler.top/img/image-20230412222207023.png)

2. 在该文件夹下新建一个 `PreCacheJob` 文件

![image-20230412222427243](http://qiniu.fickler.top/img/image-20230412222427243.png)

3. corn 表达式

[在线Cron表达式生成器 (qqe2.com)](https://cron.qqe2.com/)

4. 编写代码

```java
package com.example.usercenterbackendmaster.job;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.example.usercenterbackendmaster.mapper.UserMapper;
import com.example.usercenterbackendmaster.model.domain.User;
import com.example.usercenterbackendmaster.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * @author dell
 * @date 2023/4/12 22:24
 */

@Component
@Slf4j
public class PreCacheJob {

    @Resource
    private UserService userService;

    @Resource
    private RedisTemplate<String, Object> redisTemplate;

    // 动态用户
    private List<Long> mainUserList = Arrays.asList(1L);

    @Scheduled(cron = "0 47 22 * * * ")
    public void doCacheRecommendUser() {
        for (Long userId : mainUserList) {
            QueryWrapper<User> queryWrapper = new QueryWrapper<>();
            Page<User> userPage = userService.page(new Page<>(1, 20), queryWrapper);
            String redisKey = String.format("matchup:user:recommend%s", userId);
            ValueOperations<String, Object> valueOperations = redisTemplate.opsForValue();
            try {
                valueOperations.set(redisKey, userPage, 30000, TimeUnit.MILLISECONDS);
            } catch (Exception e) {
                log.error("redis set key error", e);
            }
        }
    }

}
```

5. 测试一下

![image-20230412224732261](http://qiniu.fickler.top/img/image-20230412224732261.png)

执行完使用 quickredis 查看是否添加了缓存

![image-20230412224905844](http://qiniu.fickler.top/img/image-20230412224905844.png)

## 锁和分布式锁

### 一、背景

我们上次实现了缓存预热，但是缓存是存在一台服务器上，那如果项目是部署在多台服务器上呢？

![image-20230413084533553](http://qiniu.fickler.top/img/image-20230413084533553.png)

#### 1. 控制定时任务的执行（为啥？）

1. 浪费资源，想象 10000 台服务器同时 “打鸣”
2. 脏数据，比如重复插入

#### 2. 控制定时任务在同一时间只有 1 个服务器执行（怎么做？）

1. 分离定时任务程序和主程序，只在 1 个服务器运行定时任务。成本太大

2. **写死配置**，每个服务器都执行定时任务，但是只有 ip 符合配置的服务器才真实执行业务逻辑，其他的直接返回。成本最低。但是我们的 ip 可能不是不固定的，把 ip 写的太死了

3. **动态配置**，配置是可以轻松的、很方便地更新的，但是只有 ip 符合配置的服务器才真实执行业务逻辑。

   - 数据库
   - Redis
   - 配置中心（Nacos、Apollo、Spring Cloud Config）

   问题：服务器多了、IP 不可控还是很麻烦，还是要人工修改

4. **分布式锁**，只有抢到锁的服务器才能执行业务逻辑。

   坏处：增加成本

   好处：不用手动配置，多少个服务器都一样

### 二、锁

有限资源的情况下，控制同一时间（段）只有某些线程（用户/服务器）能访问到资源。

Java 实现锁：synchronized 关键字、并发包的类

问题：只对单个 JVM 有效

### 三、分布式锁

#### 1. 为什么需要分布式锁

1. 有限资源的情况下，控制同一时间（段）只有某些线程（用户/服务器）能访问到资源。
2. 单个锁只对单个 JVM 有效

[【分布式锁】三种分布式锁的实现【原创】_分布式锁的三种实现方式_jiandanokok的博客-CSDN博客](https://blog.csdn.net/jiandanokok/article/details/114296755?ops_request_misc=%7B%22request%5Fid%22%3A%22167189130116782425179973%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=167189130116782425179973&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114296755-null-null.142^v68^control,201^v4^add_ask,213^v2^t3_control2&utm_term=分布式锁&spm=1018.2226.3001.4187)

[什么是分布式锁？几种分布式锁分别是怎么实现的？_Java后端架构猛猛的博客-CSDN博客](https://blog.csdn.net/m0_67645544/article/details/124768505?ops_request_misc=%7B%22request%5Fid%22%3A%22167189130116782425179973%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=167189130116782425179973&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-124768505-null-null.142^v68^control,201^v4^add_ask,213^v2^t3_control2&utm_term=分布式锁&spm=1018.2226.3001.4187)

#### 2. 分布式锁实现的关键

##### (1) 抢锁机制

怎么保证同一时间只有 1 个服务器能抢到锁？

**核心思想**就是：先来的人把数据改成自己的标识（服务器ip）后来的人发现标识已经存在，就抢锁失败，继续等待。

等先来的人执行方法结束，把标识清空，其他人继续抢锁。

MySQL数据库：`select for update` 行级锁（最简单）

（乐观锁）

✔️Redis实现：内不吃你数据库，读写速度快。支持 **setnx**、lua 脚本，比较方便我们实现分布式锁。

> **setnx**：set if not exists 如果不存在，则设置；只有设置成功才会返回 true，否则返回 false。
>
> ![image-20230413092552642](http://qiniu.fickler.top/img/image-20230413092552642.png)

Zookeeper实现

##### (2) 注意事项

1. 用完锁要释放

2. **锁一定要加过期时间**（防止服务器挂掉，锁不被释放掉）

3. 如果方法执行时间过长，锁提前过期了，

   问题：

   - 这样还是会存在多个方法同时执行的情况
   - 连锁效应：释放掉别人的锁

   解决方案：

   - 续期

   ```java
   boolean end = false;
   
   //线程
   new Thread(() -> {
       //判断状态
       if (!end)}{
           续期
       })
   
       end = true;
   ```

   

4. 释放锁的时候，有可能先判断出是自己的锁，但这时锁过期了，最好还释放了别人的锁

```shell
// 原子操作
if(get lock == A) {
    // set lock B
    del lock
}
```

Redis + lua 脚本

5. Redis 如果是集群（而不是只有一个 Redis），如果分布式锁的数据不同步怎么办？

Redis + lua 脚本实现

[Redisson--红锁(Redlock)--使用/原理_IT利刃出鞘的博客-CSDN博客](https://blog.csdn.net/feiying0canglang/article/details/113258494)

### 四、Redisson实现分布式锁

#### 1. Redisson概述

Java 客户端，数据网格

实现了很多 Java 里支持的 API 和数据结构

Redisson 是一个 java 操作 Redis 的客户端，**提供了大量的分布式数据集来简化对 Redis 的操作和使用，可以让开发者像使用本地集合一样使用 Redis，完全感知不到 Redis 的存在。**

[redisson/redisson: Redisson - Easy Redis Java client with features of In-Memory Data Grid. Over 50 Redis based Java objects and services: Set, Multimap, SortedSet, Map, List, Queue, Deque, Semaphore, Lock, AtomicLong, Map Reduce, Publish / Subscribe, Bloom filter, Spring Cache, Tomcat, Scheduler, JCache API, Hibernate, MyBatis, RPC, local cache ... (github.com)](https://github.com/redisson/redisson)

> 1. spring boot starter 引入（不推荐，版本迭代太快，容易冲突）
>
> [redisson/redisson-spring-boot-starter at master · redisson/redisson (github.com)](https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter)
>
> 2. 直接引入

#### 2. Quick start

1. 添加依赖

```xml
        <!-- https://github.com/redisson/redisson#quick-start -->
        <dependency>
            <groupId>org.redisson</groupId>
            <artifactId>redisson</artifactId>
            <version>3.19.1</version>
        </dependency>
```

2. 编写 `RedissonConfig` 文件

```java
package com.example.usercenterbackendmaster.config;

import lombok.Data;
import org.redisson.Redisson;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

/**
 * @author dell
 * @date 2023/4/13 10:24
 * Redisson 配置
 */

@Configuration
@ConfigurationProperties(prefix = "spring.redis")
@Data
public class RedissonConfig {

    private String host;
    private String port;

    @Bean
    public RedissonClient redissonClient() {
        // 1.快速创建配置
        Config config = new Config();
        String redisAddress = String.format("redis://%s:%s", host, port);
        // useSingleServer(): 使用单个 redis
        // useClusterServers(): 使用集群 redis
        config.useSingleServer().setAddress(redisAddress).setDatabase(3);
        // 2. 创建实例
        RedissonClient redissonClient = Redisson.create(config);
        return redissonClient;
    }

}
```

3. 测试

```java
package com.example.usercenterbackendmaster;

import org.junit.jupiter.api.Test;
import org.redisson.api.RList;
import org.redisson.api.RMap;
import org.redisson.api.RedissonClient;
import org.springframework.boot.test.context.SpringBootTest;

import javax.annotation.Resource;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * @author dell
 * @date 2023/4/13 10:47
 */

@SpringBootTest
public class RedissonTest {

    @Resource
    private RedissonClient redissonClient;

    @Test
    void test() {
        // list，数据存在本地 JVM 内存中
        List<String> list = new ArrayList<>();
        list.add("yupi");
        System.out.println("list:" + list.get(0));

        list.remove(0);

        // 数据存在 redis 的内存中
        RList<String> rList = redissonClient.getList("test-list");
        rList.add("yupi");
        System.out.println("rlist:" + rList.get(0));
        rList.remove(0);

        // map
        Map<String, Integer> map = new HashMap<>();
        map.put("yupi", 10);
        map.get("yupi");

        RMap<Object, Object> map1 = redissonClient.getMap("test-map");

        // set

        // stack


    }

}

```

#### 3. 分布式锁实现

1. waitTime 设置为 0，只抢一次，抢不到就放弃
2. 注意释放锁要卸载 finally 中

```java
package com.example.usercenterbackendmaster.job;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.example.usercenterbackendmaster.mapper.UserMapper;
import com.example.usercenterbackendmaster.model.domain.User;
import com.example.usercenterbackendmaster.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.redisson.api.RLock;
import org.redisson.api.RedissonClient;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * @author dell
 * @date 2023/4/12 22:24
 */

@Component
@Slf4j
public class PreCacheJob {

    @Resource
    private UserService userService;

    @Resource
    private RedisTemplate<String, Object> redisTemplate;

    @Resource
    private RedissonClient redissonClient;

    // 动态用户
    private List<Long> mainUserList = Arrays.asList(1L);

    @Scheduled(cron = "0 47 22 * * * ")
    public void doCacheRecommendUser() {
        RLock lock = redissonClient.getLock("matchup:precachejob:docache:lock");
        try {
            // 只有一个线程能获取到锁
            if (lock.tryLock(0, 30000, TimeUnit.MILLISECONDS)) {
                for (Long userId : mainUserList) {
                    QueryWrapper<User> queryWrapper = new QueryWrapper<>();
                    Page<User> userPage = userService.page(new Page<>(1, 20), queryWrapper);
                    String redisKey = String.format("matchup:user:recommend%s", userId);
                    ValueOperations<String, Object> valueOperations = redisTemplate.opsForValue();
                    try {
                        valueOperations.set(redisKey, userPage, 30000, TimeUnit.MILLISECONDS);
                    } catch (Exception e) {
                        log.error("redis set key error", e);
                    }
                }
            }
        } catch (InterruptedException e) {
            log.error("doCacheRecommendUser error", e);
        } finally {
            // 只能释放自己的锁
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }

}
```

#### 4. 测试

测试一下分布式，三个服务程序争抢锁

（提醒：我们这里是用定时任务触发抢锁，所以定时任务时间先设定好，大概延后几分钟就行，下面的操作包括	设定定时任务时间---打包---启动三个服务---到时间抢锁其中一个服务抢到锁控制台回馈）

在使用Java命令设置端口启动项目。

```
java -jar .\user-center-backend-0.0.1-SNAPSHOT.jar --server.port=8080
```

（8081端口）；开启三个服务。

![image-20230413195945296](http://qiniu.fickler.top/img/image-20230413195945296.png)

第三个程序抢到了锁

![image-20230413201126040](http://qiniu.fickler.top/img/image-20230413201126040.png)

#### 5. 看门狗机制（逾期问题）

> redisson 默认集成了看门狗机制，只需要将 unit 时间指定为 -1 即可
>
> ![image-20230413203725236](http://qiniu.fickler.top/img/image-20230413203725236.png)

开启一个监听线程，如果方法还没执行完，就帮你重置 redis 锁的过期时间。

原理：

1. 监听当前线程，默认过期时间是 30 秒，每 10 秒续期一次（补到 30 秒）
2. 如果线程挂掉（注意 debug 模式下断点也会被当成服务器宕机），则不会续期

[Redisson 分布式锁的watch dog自动续期机制_redisson 续期_zhifeng687的博客-CSDN博客](https://blog.csdn.net/qq_26222859/article/details/79645203)

### 思考

Redisson 和 spring-data-redis 的区别？

[redission_小白要变大牛的博客-CSDN博客](https://blog.csdn.net/hnhroot/article/details/126296921?ops_request_misc=%7B%22request%5Fid%22%3A%22167498413116800180663057%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=167498413116800180663057&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-126296921-null-null.142^v71^one_line,201^v4^add_ask&utm_term=Redission的&spm=1018.2226.3001.4187)

[spring-data-redis概述及用法_spring data redis_jsxllht的博客-CSDN博客](https://blog.csdn.net/weixin_56219549/article/details/119484442?ops_request_misc=&request_id=&biz_id=102&utm_term=spring-data-redis和Redission的&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-119484442.142^v71^one_line,201^v4^add_ask&spm=1018.2226.3001.4187)

## 组队功能开发

### 一、需求分析

用户可以**创建**一个队伍，设置队伍人数、队伍名称（标题）、描述、超时时间

1. 队长、剩余的人数
2. 聊天？
3. 公开或 private 或加密
4. 用户创建队伍最多 5 个

展示队伍列表，根据名称搜索队伍，信息流中不展示已过期的队伍

修改队伍信息

用户可以加入队伍（其他人、未满、未过期），允许加入多个队伍，但是要有个上限

是否需要队长同意？筛选审批？

用户可以退出队伍（如果队长退出，权限转移给第二早加入的用户 ---- 先来后到）

队长可以解散队伍

分享队伍 => 邀请其他用户加入队伍

业务流程：

1. 生成分享链接（分享二维码）
2. 用户访问链接，可以点击加入

队伍人满后发送消息通知

### 二、数据库表设计

#### 1. 队伍表

队伍表 team

字段：

- id 主键 bigint（最简单、连续，放 url 上比较简短，但缺点是爬虫）
- name 队伍名称
- description 描述
- maxNum 最大人数
- expireTime 过期时间
- userId 创建人 id
- status 0 - 公开，1 - 私有，2 - 加密
- password 密码
- createTime 创建时间
- updateTime 更新时间
- isDelete 是否删除

```mysql
create table team
(
  id           bigint auto_increment comment 'id'
  primary key,
  name   varchar(256)                   not null comment '队伍名称',
  description varchar(1024)                      null comment '描述',
  maxNum    int      default 1                 not null comment '最大人数',
  expireTime    datetime  null comment '过期时间',
  userId            bigint comment '用户id',
  status    int      default 0                 not null comment '0 - 公开，1 - 私有，2 - 加密',
  password varchar(512)                       null comment '密码',

  createTime   datetime default CURRENT_TIMESTAMP null comment '创建时间',
  updateTime   datetime default CURRENT_TIMESTAMP null on update CURRENT_TIMESTAMP,
  isDelete     tinyint  default 0                 not null comment '是否删除'
)
comment '队伍';
```

#### 2. 用户-队伍表

两个关系：

1. 用户加了哪些队伍？
2. 队伍有哪些用户？



方式：

1. 建立用户 - 队伍关系表 teamId userId（便于修改，查询性能高一点，可以选择这个，不用全表遍历）
2. 用户表补充已加入的队伍字段，队伍表补充已加入的用户字段（便于查询，不用写多对多的代码，可以直接根据队伍查用户、根据用户查队伍）



用户 - 队伍表 user_team

字段：

- id 主键
- userId 用户 id
- teamId 队伍 id
- joinTime 加入时间
- createTime 创建时间
- updateTime 更新时间
- isDelete 是否删除

```mysql
create table user_team
(
    id           bigint auto_increment comment 'id'
        primary key,
    userId            bigint comment '用户id',
    teamId            bigint comment '队伍id',
    joinTime datetime  null comment '加入时间',
    createTime   datetime default CURRENT_TIMESTAMP null comment '创建时间',
    updateTime   datetime default CURRENT_TIMESTAMP null on update CURRENT_TIMESTAMP,
    isDelete     tinyint  default 0                 not null comment '是否删除'
)
    comment '用户队伍关系';
```

#### 3. 使用mybatis-plus生成代码

1. team表

![image-20230413221051069](http://qiniu.fickler.top/img/image-20230413221051069.png)

2. user_team表

![image-20230413222250887](http://qiniu.fickler.top/img/image-20230413222250887.png)

> 将生成好的代码移动到对应的文件目录下
>
> 不要忘记给逻辑删除字段添加 `@TableLogic` 注解

### 三、队伍controller接口

```java
package com.example.usercenterbackendmaster.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 队伍接口
 * @author dell
 * @date 2023/4/14 8:31
 */

@RestController
@RequestMapping("/team")
@CrossOrigin(origins = {"http://127.0.0.1:5173"}, allowCredentials = "true")
@Slf4j
public class TeamController {



}
```

#### 1. 增删改查

```java
package com.example.usercenterbackendmaster.controller;

import com.example.usercenterbackendmaster.common.BaseResponse;
import com.example.usercenterbackendmaster.common.ErrorCode;
import com.example.usercenterbackendmaster.common.ResultUtils;
import com.example.usercenterbackendmaster.exception.BusinessException;
import com.example.usercenterbackendmaster.model.domain.Team;
import com.example.usercenterbackendmaster.service.TeamService;
import com.example.usercenterbackendmaster.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.*;

import javax.annotation.Resource;

/**
 * 队伍接口
 * @author dell
 * @date 2023/4/14 8:31
 */

@RestController
@RequestMapping("/team")
@CrossOrigin(origins = {"http://127.0.0.1:5173"}, allowCredentials = "true")
@Slf4j
public class TeamController {

    @Resource
    private UserService userService;

    @Resource
    private TeamService teamService;

    /**
     * 添加队伍
     * @param team 队伍信息
     * @return
     */
    @PostMapping("/add")
    public BaseResponse<Long> addTeam(@RequestBody Team team) {
        if (team == null) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        boolean save = teamService.save(team);
        if (!save) {
            throw new BusinessException(ErrorCode.SYSTEM_ERROR, "插入失败");
        }
        return ResultUtils.success(team.getId());
    }

    @PostMapping("/delete")
    public BaseResponse<Boolean> deleteTeam(@RequestBody long id) {
        if (id <= 0) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        boolean result = teamService.removeById(id);
        if (!result) {
            throw new BusinessException(ErrorCode.SYSTEM_ERROR, "删除失败");
        }
        return ResultUtils.success(true);
    }

    @PostMapping("/update")
    public BaseResponse<Boolean> updateTeam(@RequestBody Team team) {
        if (team == null) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        boolean result = teamService.updateById(team);
        if (!result) {
            throw new BusinessException(ErrorCode.SYSTEM_ERROR, "更新失败");
        }
        return ResultUtils.success(true);
    }

    @GetMapping("/get")
    public BaseResponse<Team> getTeamById(long id) {
        if (id <= 0) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        Team team = teamService.getById(id);
        if (team == null) {
            throw new BusinessException(ErrorCode.NULL_ERROR);
        }
        return ResultUtils.success(team);
    }

}
```

#### 2. 新建一个队伍请求参数包装类`TeamQuery`

> **为什么需要请求参数包装类？**
>
> 1. 请求参数名称 / 类型和实体类不一样
> 2. 有一些参数用不到，如果要自动生成接口文档，会增加理解成本
> 3. 多个实体类映射
>
> **为什么需要包装类？**
>
> 可能有些字段需要隐藏，不能返回给前端
>
> 或者有些字段某些方法是不关心的

```java
package com.example.usercenterbackendmaster.model.domain.dto;

import lombok.Data;

import java.util.List;

/**
 * 队伍查询封装类
 * @author dell
 * @date 2023/4/15 21:36
 */

@Data
public class TeamQuery {
    /**
     * id
     */
    private Long id;

    /**
     * id 列表
     */
    private List<Long> idList;

    /**
     * 搜索关键词（同时对队伍名称和描述搜索）
     */
    private String searchText;

    /**
     * 队伍名称
     */
    private String name;

    /**
     * 描述
     */
    private String description;

    /**
     * 最大人数
     */
    private Integer maxNum;

    /**
     * 用户id
     */
    private Long userId;

    /**
     * 0 - 公开，1 - 私有，2 - 加密
     */
    private Integer status;

}

```

#### 3. 编写 list 全量查询

```java
    @GetMapping("/list")
    public BaseResponse<List<Team>> listTeams(TeamQuery teamQuery) {
        if (teamQuery == null) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        Team team = new Team();
        BeanUtils.copyProperties(team, teamQuery);
        QueryWrapper<Team> queryWrapper = new QueryWrapper<>(team);
        List<Team> teamList = teamService.list(queryWrapper);
        return ResultUtils.success(teamList);
    }
```

#### 4. 新建一个分页请求实体类 `PageRequest`

```java
package com.example.usercenterbackendmaster.common;

import lombok.Data;

import java.io.Serializable;

/**
 * 通用的分页请求参数
 * @author dell
 * @date 2023/4/15 22:02
 */

@Data
public class PageRequest implements Serializable {

    private static final long serialVersionUID = 5191795669627260710L;
    
    /**
     * 页面大小
     */
    protected int pageSize;

    /**
     * 当前是第几页
     */
    protected int pageNum;

}
```

#### 5. 让之前的队伍请求包装类继承这个分页实体类

![image-20230415220717030](http://qiniu.fickler.top/img/image-20230415220717030.png)

#### 6. 编写分页查询

```java
    @GetMapping("/list/page")
    public BaseResponse<Page<Team>> listTeamsByPage(TeamQuery teamQuery) {
        if (teamQuery == null) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        Team team = new Team();
        BeanUtils.copyProperties(team, teamQuery);
        Page<Team> page = new Page<>(teamQuery.getPageNum(), teamQuery.getPageSize());
        QueryWrapper<Team> queryWrapper = new QueryWrapper<>(team);
        Page<Team> resultPage = teamService.page(page, queryWrapper);
        return ResultUtils.success(resultPage);
    }
```

#### 7. 测试一下

添加队伍

![image-20230415222103979](http://qiniu.fickler.top/img/image-20230415222103979.png)

查询队伍

![](http://qiniu.fickler.top/img/image-20230415222103979-1681568498206-6.png)

删除队伍

![image-20230415222222164](http://qiniu.fickler.top/img/image-20230415222222164.png)

### 四、接口系统设计

#### 1. 创建队伍

> 用户可以 **创建** 一个队伍，设置队伍的人数、队伍名称（标题）、描述、超时时间 
>
> 队长、剩余的人数
>
> 聊天？
>
> 公开 或 private 或加密
>
> 信息流中不展示已过期的队伍
>
> **创建队伍细化逻辑**
>
> 1. 请求参数是否为空？
> 2. 是否登录，为登录不允许创建
> 3. 校验信息
>    1. 队伍人数 >1 且 <= 20
>    2. 队伍标题 <= 20
>    3. 描述 <= 512
>    4. status 是否公开（int）不传默认为 0（公开）
>    5. 如果 status 是加密状态，一定要有密码，且密码 <= 32
>    6. 超时时间 > 当前时间
>    7. 校验用户最多创建 5 个队伍
> 4. 插入队伍信息到队伍表
> 5. 插入用户 => 队伍关系到关系表

1. 在 `service` 层中新加方法

```java
    /**
     * 创建队伍
     * @param team 队伍信息
     * @param loginUser 当前用户
     * @return
     */
    long addTeam(Team team, User loginUser);
```

2. 添加一个队伍状态的枚举类`TeamStatusEnum`

```java
package com.example.usercenterbackendmaster.model.domain.enums;

/**
 * 队伍状态枚举类
 * @author dell
 * @date 2023/4/15 23:17
 */
public enum TeamStatusEnum {

    PUBLIC(0, "公开"),
    PRIVATE(1, "私有"),
    SECRET(2, "加密");

    private int value;

    private String text;

    public static TeamStatusEnum getEnumByValue(Integer value) {
        if (value == null) {
            return null;
        }
        TeamStatusEnum[] values = TeamStatusEnum.values();
        for (TeamStatusEnum teamStatusEnum : values) {
            if (teamStatusEnum.getValue() == value) {
                return teamStatusEnum;
            }
        }
        return null;
    }

    TeamStatusEnum(int value, String text) {
        this.value = value;
        this.text = text;
    }

    public int getValue() {
        return value;
    }

    public void setValue(int value) {
        this.value = value;
    }

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }
}

```

3. 在 `serviceimpl` 中编写具体的逻辑代码

```java
package com.example.usercenterbackendmaster.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.example.usercenterbackendmaster.common.ErrorCode;
import com.example.usercenterbackendmaster.exception.BusinessException;
import com.example.usercenterbackendmaster.model.domain.Team;
import com.example.usercenterbackendmaster.model.domain.User;
import com.example.usercenterbackendmaster.model.domain.UserTeam;
import com.example.usercenterbackendmaster.model.domain.enums.TeamStatusEnum;
import com.example.usercenterbackendmaster.service.TeamService;
import com.example.usercenterbackendmaster.mapper.TeamMapper;
import com.example.usercenterbackendmaster.service.UserTeamService;
import org.apache.commons.lang3.StringUtils;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;
import java.util.Date;
import java.util.Optional;

/**
* @author dell
* @description 针对表【team(队伍)】的数据库操作Service实现
* @createDate 2023-04-13 22:10:55
*/
@Service
public class TeamServiceImpl extends ServiceImpl<TeamMapper, Team>
    implements TeamService{

    @Resource
    UserTeamService userTeamService;

    @Transactional(rollbackFor = Exception.class)
    @Override
    public long addTeam(Team team, User loginUser) {

        // 1. 请求参数是否为空？
        if (team == null) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        // 2. 是否登录，为登录不允许创建
        if (loginUser == null) {
            throw new BusinessException(ErrorCode.NOT_LOGIN);
        }
        final long userId = loginUser.getId();
        // 3. 校验信息
        //   1. 队伍人数 >1 且 <= 20
        int maxNum = Optional.ofNullable(team.getMaxNum()).orElse(0);
        if (maxNum < 1 || maxNum > 20) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "队伍人数不满足要求");
        }
        //   2. 队伍标题 <= 20
        String name = team.getName();
        if (StringUtils.isBlank(name) || name.length() > 20) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "队伍标题不符合要求");
        }
        //   3. 描述 <= 512
        String description = team.getDescription();
        if (StringUtils.isNotBlank(description) && description.length() > 512) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "队伍描述过长");
        }
        //   4. status 是否公开（int）不传默认为 0（公开）
        int status = Optional.ofNullable(team.getStatus()).orElse(0);
        TeamStatusEnum statusEnum = TeamStatusEnum.getEnumByValue(status);
        if (statusEnum == null) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "队伍状态不符合要求");
        }
        //   5. 如果 status 是加密状态，一定要有密码，且密码 <= 32
        String password = team.getPassword();
        if (TeamStatusEnum.SECRET.equals(statusEnum)) {
            if (StringUtils.isBlank(password) || password.length() > 32) {
                throw new BusinessException(ErrorCode.PARAMS_ERROR, "密码设置不正确");
            }
        }
        //   6. 超时时间 > 当前时间
        Date expireTime = team.getExpireTime();
        if (new Date().after(expireTime)) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "超时时间 > 当前时间");
        }
        //   7. 校验用户最多创建 5 个队伍
        // todo 有bug，同一时刻可能创建大量队伍（枷锁）
        QueryWrapper<Team> queryWrapper = new QueryWrapper<>();
        queryWrapper.eq("userId", userId);
        long hasTeamNum = this.count(queryWrapper);
        if (hasTeamNum >= 5) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "最多创建5个队伍");
        }
        //4. 插入队伍信息到队伍表
        team.setId(null);
        team.setUserId(userId);
        boolean result = this.save(team);
        Long teamId = team.getId();
        if (!result || teamId == null) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "创建队伍失败");
        }
        //5. 插入用户 => 队伍关系到关系表
        UserTeam userTeam = new UserTeam();
        userTeam.setTeamId(teamId);
        userTeam.setUserId(userId);
        userTeam.setJoinTime(new Date());
        result = userTeamService.save(userTeam);
        if (!result) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "创建队伍失败");
        }
        return teamId;
    }
}
```

> **事务注解**
>
> **@Transactional(rollbackFor = Exception.class)**
>
> 要么数据操作都成功，要么都失败

4. 修改之前的 `controller` 层代码

```java
    /**
     * 添加队伍
     * @param team 队伍信息
     * @return
     */
    @PostMapping("/add")
    public BaseResponse<Long> addTeam(@RequestBody Team team, HttpServletRequest request) {
        if (team == null) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        User loginUser = userService.getLoginUser(request);
        long teamId = teamService.addTeam(team, loginUser);
        return ResultUtils.success(teamId);
    }
```

5. 新建一个队伍请求包装类

```java
package com.example.usercenterbackendmaster.model.domain.request;

import lombok.Data;

import java.io.Serializable;
import java.util.Date;

/**
 * 添加队伍请求体
 * @author dell
 * @date 2023/4/15 23:46
 */

@Data
public class TeamAddRequest implements Serializable {

    private static final long serialVersionUID = 2837038760247351066L;

    /**
     * 队伍名称
     */
    private String name;

    /**
     * 描述
     */
    private String description;

    /**
     * 最大人数
     */
    private Integer maxNum;

    /**
     * 过期时间
     */
    private Date expireTime;

    /**
     * 用户id
     */
    private Long userId;

    /**
     * 0 - 公开，1 - 私有，2 - 加密
     */
    private Integer status;

    /**
     * 密码
     */
    private String password;

}

```

6. 再修改一下 `controller` 层代码

```java
    /**
     * 添加队伍
     * @param teamAddRequest 队伍信息
     * @return
     */
    @PostMapping("/add")
    public BaseResponse<Long> addTeam(@RequestBody TeamAddRequest teamAddRequest, HttpServletRequest request) {
        if (teamAddRequest == null) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        User loginUser = userService.getLoginUser(request);
        Team team = new Team();
        BeanUtils.copyProperties(teamAddRequest, team);
        long teamId = teamService.addTeam(team, loginUser);
        return ResultUtils.success(teamId);
    }
```

7. 测试一下

正常创建

![image-20230416001302662](http://qiniu.fickler.top/img/image-20230416001302662.png)

![image-20230416001350100](http://qiniu.fickler.top/img/image-20230416001350100.png)

超过 5 个小队

![image-20230416001330601](http://qiniu.fickler.top/img/image-20230416001330601.png)

#### 2. 查询队伍列表

> 分页展示队伍列表，根据名称、最大人数等搜索队伍，信息流中不展示已过期的队伍
>
> **查询队伍列表细化逻辑**
>
> 1. 从请求参数中取出队伍名称，如果存在则作为查询条件
> 2. 不展示已过期的队伍（根据过期时间筛选）
> 3. 可以通过某个**关键词**同时对名称和描述查询
> 4. **只有管理员才能查看加密还有非公开的队伍**
> 5. 关联以加入队伍的用户信息
> 6. **关联查询已加入队伍的用户信息（可能会很耗费性能，建议自己写 SQL 的方式实现）**

1. 新建一个 `vo` 文件夹（vo：view object 返回给前端的信息封装类）

![image-20230416103450193](http://qiniu.fickler.top/img/image-20230416103450193.png)

2. 在 `vo` 文件夹下新加一个 `UserVO`

> 脱敏一下用户的敏感信息

```java
package com.example.usercenterbackendmaster.model.vo;

import lombok.Data;

import java.io.Serializable;
import java.util.Date;

/**
 * 用户包装类（脱敏）
 * @author dell
 * @date 2023/4/16 10:37
 */
@Data
public class UserVO implements Serializable {

    private static final long serialVersionUID = 6529810572038811394L;

    /**
     * id
     */
    private long id;

    /**
     * 用户昵称
     */
    private String username;

    /**
     * 账号
     */
    private String userAccount;

    /**
     * 用户头像
     */
    private String avatarUrl;

    /**
     * 性别
     */
    private Integer gender;

    /**
     * 电话
     */
    private String phone;

    /**
     * 邮箱
     */
    private String email;

    /**
     * 标签列表 json
     */
    private String tags;

    /**
     * 状态 0 - 正常
     */
    private Integer userStatus;

    /**
     * 创建时间
     */
    private Date createTime;

    /**
     * 更新时间
     */
    private Date updateTime;

    /**
     * 用户角色 0 - 普通用户 1 - 管理员
     */
    private Integer userRole;

    /**
     * 星球编号
     */
    private String planetCode;

}

```

3. 再新建一个 `TeamUserVo` 的封装类

```java
package com.example.usercenterbackendmaster.model.vo;

import lombok.Data;

import java.io.Serializable;
import java.util.Date;
import java.util.List;

/**
 * 队伍和用户信息封装类
 * @author dell
 * @date 2023/4/16 10:35
 */

@Data
public class TeamUserVO implements Serializable {

    private static final long serialVersionUID = 3386506051707015003L;

    /**
     * id
     */
    private Long id;

    /**
     * 队伍名称
     */
    private String name;

    /**
     * 描述
     */
    private String description;

    /**
     * 最大人数
     */
    private Integer maxNum;

    /**
     * 过期时间
     */
    private Date expireTime;

    /**
     * 用户id
     */
    private Long userId;

    /**
     * 0 - 公开，1 - 私有，2 - 加密
     */
    private Integer status;

    /**
     * 创建时间
     */
    private Date createTime;

    /**
     * 更新时间
     */
    private Date updateTime;

    /**
     * 入队用户列表
     */
    List<UserVO> userList;

}

```

4. 在 `service` 层添加 `listTeams` 方法

```java
    /**
     * 搜索队伍
     * @param teamQuery 队伍信息
     * @return
     */
    List<TeamUserVO> listTeams(TeamQuery teamQuery);
```

5. 在 `serviceimpl` 中实现该接口

```mysql
        // 关联查询用户信息
        // 1. 自己写sql
        // 查询队伍和创建人的信息
        // select * from team t left join user u on t.userId = u.id
        // 查询队伍和加入队伍成员的信息
        // select * from team t left join user_team ut on t.id = ut.teamId left join user u on ut.userId = u.id
```

修改队伍和用户信息封装类

![image-20230416223734177](http://qiniu.fickler.top/img/image-20230416223734177.png)

```java
    @Override
    public List<TeamUserVO> listTeams(TeamQuery teamQuery) {
        QueryWrapper<Team> queryWrapper = new QueryWrapper<>();
        if (teamQuery != null) {
            Long id = teamQuery.getId();
            if (id != null && id > 0) {
                queryWrapper.eq("id", id);
            }
            String name = teamQuery.getName();
            if (StringUtils.isNotBlank(name)) {
                queryWrapper.like("name", name);
            }
            String description = teamQuery.getDescription();
            if (StringUtils.isNotBlank(description)) {
                queryWrapper.like("description", description);
            }
            Integer maxNum = teamQuery.getMaxNum();
            // 查询最大人数相等的
            if (maxNum != null && maxNum > 0) {
                queryWrapper.eq("maxNum", maxNum);
            }
            Long userId = teamQuery.getUserId();
            // 根据创建人来查询
            if (userId != null && userId > 0) {
                queryWrapper.eq("userId", userId);
            }
            Integer status = teamQuery.getStatus();
            if (status != null && status > -1) {
                queryWrapper.eq("status", status);
            }
        }
        List<Team> teamList = this.list(queryWrapper);
        if (CollectionUtils.isEmpty(teamList)) {
            return new ArrayList<>();
        }
        List<TeamUserVO> teamUserVOList = new ArrayList<>();
        // 关联查询创建人的用户信息
        for (Team team : teamList) {
            Long userId = team.getUserId();
            if (userId == null) {
                continue;
            }
            User user = userService.getById(userId);
            TeamUserVO teamUserVO = new TeamUserVO();
            BeanUtils.copyProperties(team, teamUserVO);
            // 脱敏用户信息
            UserVO userVO = new UserVO();
            BeanUtils.copyProperties(user, userVO);
            teamUserVO.setCreateUser(userVO);
            teamUserVOList.add(teamUserVO);
        }
        return teamUserVOList;
    }
}
```

6. 补充业务逻辑：不展示已过期的队伍

```java
        // 不展示已过期的队伍
        // expireTime is not null or expireTime > now()
        queryWrapper.and(qw -> qw.gt("expireTime", new Date()).or().isNotNull("expireTime"));
```

7. 补充业务逻辑： 可以通过某个**关键词**同时对名称和描述查询

在 `TeamQuery` 中新添加一个搜索词

```java
/**
 * 搜索关键词（同时对队伍名称和描述搜索）
 */
private String searchText;
```

```java
String searchText = teamQuery.getSearchText();
if (StringUtils.isNotBlank(searchText)) {
    queryWrapper.and(qw -> qw.like("name", searchText).or().like("description", searchText));
}
```

8. 补充业务逻辑：**只有管理员才能查看加密还有非公开的队伍**

补充传递信息 `loginUser`

```java
Integer status = teamQuery.getStatus();
TeamStatusEnum statusEnum = TeamStatusEnum.getEnumByValue(status);
if (statusEnum == null) {
    statusEnum = TeamStatusEnum.PUBLIC;
}
if (!isAdmin && !statusEnum.equals(TeamStatusEnum.PUBLIC)) {
    throw new BusinessException(ErrorCode.NO_AUTH);
}
queryWrapper.eq("status", statusEnum.getValue());
```

9. 修改 `controller` 层方法

```java
@GetMapping("/list")
public BaseResponse<List<TeamUserVO>> listTeams(TeamQuery teamQuery, HttpServletRequest request) {
    if (teamQuery == null) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    boolean isAdmin = userService.isAdmin(request);
    List<TeamUserVO> teamList = teamService.listTeams(teamQuery, isAdmin);
    return ResultUtils.success(teamList);
}
```

10. 测试一下

![image-20230416235425113](http://qiniu.fickler.top/img/image-20230416235425113.png)

#### 3. 修改队伍信息

> 1. 判断请求参数是否为空
> 2. 查询队伍是否存在
> 3. 只有管理员或队伍的创建者可以修改
> 4. 如果用户传入的新值和老值一致，就不用 update 了（可降低数据库使用次数）
> 5. 如果队伍状态改为加密，**必须要有密码**
> 6. 更新成功

1. 封装一个修改队伍信息请求体

```java
package com.example.usercenterbackendmaster.model.request;

import lombok.Data;

import java.io.Serializable;
import java.util.Date;

/**
 * 修改队伍信息请求体
 * @author dell
 * @date 2023/4/15 23:46
 */

@Data
public class TeamUpdateRequest implements Serializable {

    private static final long serialVersionUID = 2837038760247351066L;

    /**
     * id
     */
    private Long id;

    /**
     * 队伍名称
     */
    private String name;

    /**
     * 描述
     */
    private String description;

    /**
     * 过期时间
     */
    private Date expireTime;

    /**
     * 0 - 公开，1 - 私有，2 - 加密
     */
    private Integer status;

    /**
     * 密码
     */
    private String password;

}

```

2. 在 `service` 层添加方法

```java
    /**
     * 更新队伍
     * @param teamUpdateRequest 更新队伍的信息
     * @param loginUser 登录用户
     * @return
     */
    boolean updateTeam(TeamUpdateRequest teamUpdateRequest, User loginUser);
```

3. 在 `serviceimpl` 层实现接口

```java
    @Override
    public boolean updateTeam(TeamUpdateRequest teamUpdateRequest, User loginUser) {
        if (teamUpdateRequest == null) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        Long id = teamUpdateRequest.getId();
        if (id == null || id <= 0 ) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        Team oldTeam = this.getById(id);
        if (oldTeam == null) {
            throw new BusinessException(ErrorCode.NULL_ERROR);
        }
        // 只有队伍创建者或管理员可以修改
        if (oldTeam.getUserId() != loginUser.getId() && !userService.isAdmin(loginUser)) {
            throw new BusinessException(ErrorCode.NO_AUTH);
        }
        Team updateTeam = new Team();
        BeanUtils.copyProperties(teamUpdateRequest, updateTeam);
        boolean result = this.updateById(updateTeam);
        return result;
    }
```

4. 修改 `controller` 层的代码

```java
@PostMapping("/update")
public BaseResponse<Boolean> updateTeam(@RequestBody TeamUpdateRequest teamUpdateRequest, HttpServletRequest request) {
    if (teamUpdateRequest == null) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    User loginUser = userService.getLoginUser(request);
    boolean result = teamService.updateTeam(teamUpdateRequest, loginUser);
    if (!result) {
        throw new BusinessException(ErrorCode.SYSTEM_ERROR, "更新失败");
    }
    return ResultUtils.success(true);
}
```

5. 测试一下

![image-20230417085356976](http://qiniu.fickler.top/img/image-20230417085356976.png)

![image-20230417085418997](http://qiniu.fickler.top/img/image-20230417085418997.png)

6. 补充逻辑

> 如果队伍状态改为加密，**必须要有密码**

```java
TeamStatusEnum statusEnum = TeamStatusEnum.getEnumByValue(teamUpdateRequest.getStatus());
if (statusEnum.equals(TeamStatusEnum.PRIVATE)) {
    if (StringUtils.isNotBlank(teamUpdateRequest.getPassword())) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR, "加密房间必须设置密码");
    }
}
```

#### 4. 用户可以加入队伍

> 其他人、未满、未过期，允许加入多个队伍，但是要有上限
>
> **用户可以加入队伍细化逻辑**
>
> 1. 用户最多加入 5 个队伍
> 2. 队伍必须存在，只能加入未满、未过期的队伍
> 3. 不能加入自己的队伍，不能重复加入已加入的队伍（幂等性）
> 4. 禁止加入私有的队伍
> 5. 如果加入的队伍是未加密的，必须密码匹配
> 6. 修改队伍信息，补充人数
> 7. 新增队伍-用户关联信息

1. 新封装一个加入队伍信息的请求体

```java
package com.example.usercenterbackendmaster.model.request;

import lombok.Data;

import java.io.Serializable;

/**
 * 加入队伍信息请求体
 * @author dell
 * @date 2023/4/15 23:46
 */

@Data
public class TeamJoinRequest implements Serializable {

    private static final long serialVersionUID = 2837038760247351066L;

    /**
     * id
     */
    private Long id;

    /**
     * 密码
     */
    private String password;

}
```

2. 在 `service` 中添加加入队伍方法

```java
/**
 * 加入队伍
 * @param teamJoinRequest 加入队伍的信息
 * @param loginUser 登录用户
 * @return
 */
boolean joinTeam(TeamJoinRequest teamJoinRequest, User loginUser);
```

3. 在 `serviceimpl` 中实现接口

```java
@Override
public boolean joinTeam(TeamJoinRequest teamJoinRequest, User loginUser) {
    if (teamJoinRequest == null) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    Long teamId = teamJoinRequest.getTeamId();
    if (teamId == null || teamId < 0) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    Team team = this.getById(teamId);
    if (team == null) {
        throw new BusinessException(ErrorCode.NULL_ERROR, "队伍不存在");
    }
    Date expireTime = team.getExpireTime();
    if (expireTime != null && expireTime.before(new Date())) {
        throw new BusinessException(ErrorCode.NULL_ERROR, "队伍已过期");
    }
    Integer status = team.getStatus();
    TeamStatusEnum teamStatusEnum = TeamStatusEnum.getEnumByValue(status);
    if (TeamStatusEnum.PRIVATE.equals(teamStatusEnum)) {
        throw new BusinessException(ErrorCode.NULL_ERROR, "禁止加入私有队伍");
    }
    String password = teamJoinRequest.getPassword();
    if (TeamStatusEnum.SECRET.equals(teamStatusEnum)) {
        if (StringUtils.isBlank(password) || !password.equals(team.getPassword())) {
            throw new BusinessException(ErrorCode.NULL_ERROR, "密码错误");
        }
    }
    // 该用户已加入队伍的数量
    long userId = loginUser.getId();
    QueryWrapper<UserTeam> userTeamQueryWrapper = new QueryWrapper<>();
    userTeamQueryWrapper.eq("userId", userId);
    long hasJoinNum = userTeamService.count(userTeamQueryWrapper);
    if (hasJoinNum > 5) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR, "最多创建和加入5个队伍");
    }
    // 不能重复加入已加入的队伍
    userTeamQueryWrapper = new QueryWrapper<>();
    userTeamQueryWrapper.eq("userId", userId);
    userTeamQueryWrapper.eq("teamId", teamId);
    long hasUserJoinTeam = userTeamService.count(userTeamQueryWrapper);
    if (hasUserJoinTeam > 0) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR, "用户已加入该队伍");
    }
    // 已加入队伍的人数
    userTeamQueryWrapper = new QueryWrapper<>();
    userTeamQueryWrapper.eq("teamId", teamId);
    long teamHasJoinNum = userTeamService.count(userTeamQueryWrapper);
    if (teamHasJoinNum > team.getMaxNum()) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR, "队伍已满");
    }
    // 修改队伍信息
    UserTeam userTeam = new UserTeam();
    userTeam.setUserId(userId);
    userTeam.setTeamId(teamId);
    userTeam.setJoinTime(new Date());
    return userTeamService.save(userTeam);
}
```

4. 修改 `controller` 的方法

```java
    @PostMapping("/join")
    public BaseResponse<Boolean> joinTeam(@RequestBody TeamJoinRequest teamJoinRequest, HttpServletRequest request) {
        if (teamJoinRequest == null) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        User loginUser = userService.getLoginUser(request);
        boolean result = teamService.joinTeam(teamJoinRequest, loginUser);
        return ResultUtils.success(result);
    }
```

5. 测试一下

![image-20230417150335471](http://qiniu.fickler.top/img/image-20230417150335471.png)

#### 5. 用户可以退出队伍

> 请求参数：队伍 id
>
> 1. 校验请求参数
> 2. 校验队伍是否存在
> 3. 校验我是否已加入队伍
> 4. 如果队伍
>    1. 只剩一人，队伍解散
>    2. 还有其他人
>       1. 如果是队长退出队伍，权限转移给第二早加入的用户 ---- 先来后到只用去 id 最小的 2 条数据
>       2. 非队长，自己退出队伍

1. 新建一个退出队伍请求体

![image-20230418101724925](http://qiniu.fickler.top/img/image-20230418101724925.png)

```java
package com.example.usercenterbackendmaster.model.request;

import lombok.Data;

import java.io.Serializable;

/**
 * 加入队伍信息请求体
 * @author dell
 * @date 2023/4/15 23:46
 */

@Data
public class TeamQuitRequest implements Serializable {

    private static final long serialVersionUID = 2837038760247351066L;

    /**
     * id
     */
    private Long teamId;

}
```

2. 将之前的查询队伍人数抽取出一个公共方法

```java
/**
 * 查询队伍人数
 * @param teamId 队伍id
 * @return
 */
private long countTeamUserByTeamId(long teamId) {
    QueryWrapper<UserTeam> userTeamQueryWrapper = new QueryWrapper<>();
    userTeamQueryWrapper.eq("teamId", teamId);
    return userTeamService.count(userTeamQueryWrapper);
}
```

3. 在 `service` 层添加退出队伍方法

```java
/**
 * 退出队伍
 * @param teamQuitRequest 退出队伍的信息
 * @param loginUser 登录用户
 * @return
 */
boolean quitTeam(TeamQuitRequest teamQuitRequest, User loginUser);
```

4. 在 `serviceimpl` 层实现接口

```java
@Override
public boolean quitTeam(TeamQuitRequest teamQuitRequest, User loginUser) {
    if (teamQuitRequest == null) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    Long teamId = teamQuitRequest.getTeamId();
    if (teamId == null || teamId <= 0) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    Team team = this.getById(teamId);
    if (team == null) {
        throw new BusinessException(ErrorCode.NULL_ERROR, "队伍不存在");
    }
    Long userId = loginUser.getId();
    UserTeam queryUserTeam = new UserTeam();
    queryUserTeam.setUserId(userId);
    queryUserTeam.setTeamId(teamId);
    QueryWrapper<UserTeam> queryWrapper = new QueryWrapper<>(queryUserTeam);
    long count = userTeamService.count(queryWrapper);
    if (count == 0) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR, "未加入队伍");
    }
    long teamHasJoinNum = this.countTeamUserByTeamId(teamId);
    // 队伍只剩一人，解散
    if (teamHasJoinNum == 1) {
        // 删除队伍
        this.removeById(teamId);
    } else {
        // 是否为队长
        if (team.getUserId() == userId) {
            // 把队伍转移给最早加入的用户
            // 1. 查询所有已加入队伍的所有用户和加入时间
            QueryWrapper<UserTeam> userTeamQueryWrapper = new QueryWrapper<>();
            userTeamQueryWrapper.eq("teamId", teamId);
            userTeamQueryWrapper.last("order by id asc limit 2");
            List<UserTeam> userTeamList = userTeamService.list(userTeamQueryWrapper);
            if (CollectionUtils.isEmpty(userTeamList) || userTeamList.size() <= 1) {
                throw new BusinessException(ErrorCode.SYSTEM_ERROR);
            }
            UserTeam nextUserTeam = userTeamList.get(1);
            Long nextTeamLeaderId = nextUserTeam.getUserId();
            // 更新当前队伍的队长
            Team updateTeam = new Team();
            updateTeam.setId(teamId);
            updateTeam.setUserId(nextTeamLeaderId);
            boolean result = this.updateById(updateTeam);
            if (!result) {
                throw new BusinessException(ErrorCode.SYSTEM_ERROR, "更新队长失败");
            }
        }
    }
    // 移除关联
    return userTeamService.remove(queryWrapper);
}
```

5. 在 `controller` 层修改方法

```java
@PostMapping("/quit")
public BaseResponse<Boolean> quitTeam(@RequestBody TeamQuitRequest teamQuitRequest, HttpServletRequest request) {
    if (teamQuitRequest == null) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    User loginUser = userService.getLoginUser(request);
    boolean result = teamService.quitTeam(teamQuitRequest, loginUser);
    return ResultUtils.success(result);
}
```

6. 测试一下

队长退出，让位给最早加入的队员

![image-20230418111720623](http://qiniu.fickler.top/img/image-20230418111720623.png)

![image-20230418111737833](http://qiniu.fickler.top/img/image-20230418111737833.png)

![image-20230418114819891](http://qiniu.fickler.top/img/image-20230418114819891.png)

对内只有一人，队长退出

![image-20230418114945340](http://qiniu.fickler.top/img/image-20230418114945340.png)

![image-20230418115002796](http://qiniu.fickler.top/img/image-20230418115002796.png)

![image-20230418115018394](http://qiniu.fickler.top/img/image-20230418115018394.png)

#### 6. 队长可以解散队伍

> 请求参数：队伍id
>
> 业务流程：
>
> 1. 校验请求参数
> 2. 校验队伍是否存在
> 3. 校验登录用户是不是队伍的队长
> 4. 移除所有加入队伍的关联信息
> 5. 删除队伍

1. 将之前的判断队伍是否存在抽取成公共方法

```java
/**
 * 根据 id 获取队伍信息
 * @param teamId 队伍id
 * @return
 */
private Team getTeamById(Long teamId) {
    if (teamId == null || teamId <= 0) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    Team team = this.getById(teamId);
    if (team == null) {
        throw new BusinessException(ErrorCode.NULL_ERROR, "队伍不存在");
    }
    return team;
}
```

2. 给之前的错误状态码添加一个新的状态

```java
FORBIDDEN(403101, "禁止操作", ""),
```

3. 在 `service` 层中添加解散队伍方法

```java
/**
 * 删除（解散）用户
 * @param id 队伍id
 * @param loginUser 登录用户
 * @return
 */
boolean deleteTeam(long id, User loginUser);
```

4. 在 `serviceimpl` 中实现接口

**注意添加事务注解**

```java
@Override
@Transactional(rollbackFor = Exception.class)
public boolean deleteTeam(long id, User loginUser) {
    // 校验队伍是否存在
    Team team = getTeamById(id);
    Long teamId = team.getId();
    // 校验登录是否是队长
    if (team.getUserId() != loginUser.getId()) {
        throw new BusinessException(ErrorCode.NO_AUTH, "无访问权限");
    }
    // 删除队伍关联信息
    QueryWrapper<UserTeam> userTeamQueryWrapper = new QueryWrapper<>();
    userTeamQueryWrapper.eq("teamId", teamId);
    boolean result = userTeamService.remove(userTeamQueryWrapper);
    if (!result) {
        throw new BusinessException(ErrorCode.SYSTEM_ERROR, "删除队伍关联信息失败");
    }
    // 删除队伍
    return this.removeById(teamId);
}
```

5. 在 `controller` 层中添加方法

```java
@PostMapping("/delete")
public BaseResponse<Boolean> deleteTeam(@RequestBody long id, HttpServletRequest request) {
    if (id <= 0) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    User loginUser = userService.getLoginUser(request);
    boolean result = teamService.deleteTeam(id, loginUser);
    if (!result) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR, "删除失败");
    }
    return ResultUtils.success(result);
}
```

6. 测试一下

![image-20230418234513659](http://qiniu.fickler.top/img/image-20230418234513659.png)

![image-20230418234529426](http://qiniu.fickler.top/img/image-20230418234529426.png)

![image-20230418234544230](http://qiniu.fickler.top/img/image-20230418234544230.png)

#### 7. 获取当前用户加入的队伍

1. 在 `controller` 层添加方法

```java
    /**
     * 获取当前用户加入的队伍
     * @param teamQuery 队伍查询信息
     * @param request 用户登录信息
     * @return
     */
    @GetMapping("/list/my/join")
    public BaseResponse<List<TeamUserVO>> listMyJoinTeams(TeamQuery teamQuery, HttpServletRequest request) {
        if (teamQuery == null) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        User loginUser = userService.getLoginUser(request);
        QueryWrapper<UserTeam> queryWrapper = new QueryWrapper<>();
        queryWrapper.eq("userId", loginUser.getId());
        List<UserTeam> userTeamList = userTeamService.list(queryWrapper);
        // 取出不重复的队伍 id
        //teamId userId
        //1,2
        //1,3
        //2,3
        //result
        //1=> 2,3
        //2=> 3
        Map<Long, List<UserTeam>> listMap = userTeamList.stream()
                .collect(Collectors.groupingBy(UserTeam::getTeamId));
        List<Long> idList = new ArrayList<>(listMap.keySet());
        teamQuery.setIdList(idList);
        List<TeamUserVO> teamList = teamService.listTeams(teamQuery, true);
        return ResultUtils.success(teamList);
    }
```

2. 测试一下

![image-20230420161114541](http://qiniu.fickler.top/img/image-20230420161114541.png)

#### 8. 获取当前用户创建的队伍

1. 在 `controller` 层添加方法

```java
    /**
     * 获取当前用户创建的队伍
     * @param teamQuery 队伍查询信息
     * @param request 用户登录信息
     * @return
     */
    @GetMapping("/list/my/create")
    public BaseResponse<List<TeamUserVO>> listMyCreateTeams(TeamQuery teamQuery, HttpServletRequest request) {
        if (teamQuery == null) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        User loginUser = userService.getLoginUser(request);
        teamQuery.setUserId(loginUser.getId());
        List<TeamUserVO> teamList = teamService.listTeams(teamQuery, true);
        return ResultUtils.success(teamList);
    }
```

2. 测试一下

![image-20230420160058199](http://qiniu.fickler.top/img/image-20230420160058199.png)

## 前端

### 一、创建队伍页面

#### 1. 添加创建入队伍页面

1. 新建一个加入队伍页面

![image-20230419084222876](http://qiniu.fickler.top/img/image-20230419084222876.png)

2. 增加对应的路由

![image-20230419084415958](http://qiniu.fickler.top/img/image-20230419084415958.png)

#### 2. 在队伍页面添加跳转加入队伍页面的入口

![image-20230419085701204](http://qiniu.fickler.top/img/image-20230419085701204.png)

#### 3. 开发创建队伍页面

```vue
<template>
  <div id="teamAddPage">
    <van-form @submit="onSubmit">
      <van-cell-group inset>
        <van-field
            v-model="addTeamData.name"
            name="name"
            label="队伍名"
            placeholder="请输入队伍名"
            :rules="[{ required: true, message: '请填写队伍名' }]"
        />
        <van-field
            v-model="addTeamData.description"
            rows="4"
            autosize
            label="队伍描述"
            type="textarea"
            placeholder="请输入队伍描述"
        />
        <van-field
            is-link
            readonly
            name="datetimePicker"
            label="过期时间"
            :placeholder="addTeamData.expireTime ?? '点击选择过期时间'"
            @click="showPicker = true"
        />
        <van-popup v-model:show="showPicker" position="bottom">
          <van-datetime-picker
              v-model="addTeamData.expireTime"
              @confirm="showPicker = false"
              type="datetime"
              title="请选择过期时间"
              :min-date="minDate"
          />
        </van-popup>
        <van-field name="stepper" label="最大人数">
          <template #input>
            <van-stepper v-model="addTeamData.maxNum" max="10" min="3" />
          </template>
        </van-field>
        <van-field name="radio" label="队伍状态">
          <template #input>
            <van-radio-group v-model="addTeamData.status" direction="horizontal">
              <van-radio name="0">公开</van-radio>
              <van-radio name="1">私有</van-radio>
              <van-radio name="2">加密</van-radio>
            </van-radio-group>
          </template>
        </van-field>
        <van-field
            v-if="addTeamData.status === '2'"
            v-model="addTeamData.password"
            type="password"
            name="密码"
            label="队伍密码"
            placeholder="请输入队伍密码"
            :rules="[{ required: true, message: '请填写队伍密码' }]"
        />
      </van-cell-group>
      <div style="margin: 16px;">
        <van-button round block type="primary" native-type="submit">
          提交
        </van-button>
      </div>
    </van-form>
    {{
      addTeamData
    }}
  </div>
</template>

<script setup>

import {ref} from "vue";
import {useRouter} from "vue-router";
import myAxios from "../plugins/myAxios.ts";
import {Toast} from "vant";

const router = useRouter();

const initFormData = {
  "name": "",
  "description": "",
  "expireTime": null,
  "maxNum": 3,
  "password": "",
  "status": 0
}

const addTeamData = ref({...initFormData});

// 展示日期选择器
const showPicker = ref(false);
const minDate = new Date();

//提交
const onSubmit = async () => {
  const postData = {
    ...addTeamData.value,
    status: Number(addTeamData.value.status)
  }
  //todo 前端数据校验
  const res = await myAxios.post("/team/add",postData);
  if (res?.code === 0 && res.data){
    Toast.success("添加成功");
    router.push({
      path:'/team',
      replace:true,
    });
  }else {
    Toast.fail("添加失败");
  }
}

</script>

<style scoped>

</style>
```

#### 4. 测试一下

![image-20230419110254523](http://qiniu.fickler.top/img/image-20230419110254523.png)

![image-20230419110408335](http://qiniu.fickler.top/img/image-20230419110408335.png)

![image-20230419110424157](http://qiniu.fickler.top/img/image-20230419110424157.png)

### 二、队伍表单

#### 1. 新添加一个队伍的类型定义

```tsx
import {UserType} from "./user";

/**
 * 队伍类别
 */
export type TeamType = {
    id: number;
    username:string;
    name: string;
    description: string;
    expireTime?: Date;
    maxNum: number;
    password?: string,
    // todo 定义枚举值类型，更规范
    status: number;
    createTime: Date;
    updateTime: Date;
    createUser?: UserType;
};
```

#### 2. 先封装一个队伍卡片列表

```vue
<template>
  <van-card
      v-for="team in props.teamList"
      :desc="team.description"
      :title="`${team.name}`"
      :price="'最大人数: ' + team.maxNum"
  >
    <template #tags>
      <van-tag plain type="primary" style="margin-right: 8px; margin-top: 8px">
        {{team.status}}
      </van-tag>
    </template>
    <template #footer>
      <van-button size="mini">联系我</van-button>
    </template>
  </van-card>
</template>

<script setup lang="ts">

import {TeamType} from "../models/team";

interface TeamCardListProps {
  teamList: TeamType[];
}

const props = defineProps<TeamCardListProps>();

</script>

<style scoped>

</style>
```

#### 3. 测试并修改

1. 在队伍页面引入队伍卡片组件

![image-20230419113422237](http://qiniu.fickler.top/img/image-20230419113422237.png)

```tsx
// 在页面加载时只触发一下
onMounted(async () => {
  const res = await myAxios.get("/team/list");
  if (res?.code === 0) {
    teamList.value = res.data;
  } else {
    Toast.fail("加载队伍失败，请刷新重试")
  }
})
```

2. 查看效果

![image-20230419113458468](http://qiniu.fickler.top/img/image-20230419113458468.png)

> 可以看到我们的标签代表的是队伍的状态，但是展示的 0 1 数字，我们要将其改为对应的状态

3. 新建一个枚举

![image-20230419113745486](http://qiniu.fickler.top/img/image-20230419113745486.png)

![image-20230419113910371](http://qiniu.fickler.top/img/image-20230419113910371.png)

4. 修改细节的展示地方

```vue
<template #bottom>
  <div>
    {{'最大人数' + team.maxNum}}
  </div>
  <div>
    {{'过期时间' + team.expireTime}}
  </div>
  <div>
    {{'创建时间' + team.createTime}}
  </div>
</template>
<template #footer>
  <van-button size="mini" plain type="primary" @click="doJoinTeam(team.id)">加入队伍</van-button>
</template>
```

![image-20230419114130729](http://qiniu.fickler.top/img/image-20230419114130729.png)

5. 增加一张小队的图片

![image-20230419114712971](http://qiniu.fickler.top/img/image-20230419114712971.png)

```css
<style scoped>
#teamCardList :deep(.van-image__img){
  height: 128px;
  object-fit: unset;
}
</style>
```

![image-20230419114739294](http://qiniu.fickler.top/img/image-20230419114739294.png)

#### 4. 用户加入队伍

```tsx
//队伍列表加入队伍
const doJoinTeam = async(id: number) =>{
  const res = await myAxios.post("/team/join",{
    teamId : id
  });
  //@ts-ignore
  if (res?.code === 0){
    Toast.success("加入成功")
  }else {
    //@ts-ignore
    Toast.fail("加入失败" + (res.description ? `， ${res.description} `:''));
  }
}
```

![image-20230419115816290](http://qiniu.fickler.top/img/image-20230419115816290.png)

### 三、搜索队伍

#### 1. 添加一个搜索框

![image-20230419225539460](http://qiniu.fickler.top/img/image-20230419225539460.png)

![image-20230419225554961](http://qiniu.fickler.top/img/image-20230419225554961.png)

#### 2. 为搜索框绑定搜索事件

```vue
<van-search v-model="searchText" placeholder="搜索队伍" @search="onSearch" />
```

```tsx
const listTeam = async (val = '') => {
  const res = await myAxios.get("/team/list", {
    params: {
      searchText: val,
      pageNum: 1,
    }
  });
  if (res?.code === 0) {
    teamList.value = res.data;
  } else {
    Toast.fail("加载队伍失败，请刷新重试")
  }
}

// 在页面加载时只触发一下
onMounted(  () => {
  listTeam();
})

const onSearch = (val) => {
  listTeam(val);
};
```

### 四、更新队伍

> 仅队伍创始人可见

#### 1. 添加一个更新队伍的按钮

```vue
<van-button v-if="team.userId == currentUser?.id" size="mini" plain type="primary" >更新队伍</van-button>
```

```tsx
const currentUser = ref();
// 获取用户信息
onMounted(async () => {
  currentUser.value = await getCurrentUser();
})
```

#### 2. 绑定更新事件

> 点击更新后，跳转到更新页面

```vue
<van-button v-if="team.userId == currentUser?.id" size="mini" plain type="primary" @click="doUpdateTeam(team.id)">更新队伍</van-button>
```

```tsx
// 更新队伍
const doUpdateTeam = (id: number) => {
  router.push({
    path: '/team/update',
    query:{
      id,
    }
  })
}
```

#### 3. 增加一个更新队伍页面

> 类似于添加队伍页面

1. 复制页面

![image-20230420084924251](http://qiniu.fickler.top/img/image-20230420084924251.png)

2. 给页面添加对应的路由

![image-20230420085049620](http://qiniu.fickler.top/img/image-20230420085049620.png)

3. 修改更新页面

```vue
<template>
  <div id="teamAddPage">
    <van-form @submit="onSubmit">
      <van-cell-group inset>
        <van-field
            v-model="addTeamData.name"
            name="name"
            label="队伍名"
            placeholder="请输入队伍名"
            :rules="[{ required: true, message: '请填写队伍名' }]"
        />
        <van-field
            v-model="addTeamData.description"
            rows="4"
            autosize
            label="队伍描述"
            type="textarea"
            placeholder="请输入队伍描述"
        />
        <van-field
            is-link
            readonly
            name="datetimePicker"
            label="过期时间"
            :placeholder="addTeamData.expireTime ?? '点击选择过期时间'"
            @click="showPicker = true"
        />
        <van-popup v-model:show="showPicker" position="bottom">
          <van-datetime-picker
              v-model="addTeamData.expireTime"
              @confirm="showPicker = false"
              type="datetime"
              title="请选择过期时间"
              :min-date="minDate"
          />
        </van-popup>
        <van-field name="radio" label="队伍状态">
          <template #input>
            <van-radio-group v-model="addTeamData.status" direction="horizontal">
              <van-radio name="0">公开</van-radio>
              <van-radio name="1">私有</van-radio>
              <van-radio name="2">加密</van-radio>
            </van-radio-group>
          </template>
        </van-field>
        <van-field
            v-if="addTeamData.status === '2'"
            v-model="addTeamData.password"
            type="password"
            name="密码"
            label="队伍密码"
            placeholder="请输入队伍密码"
            :rules="[{ required: true, message: '请填写队伍密码' }]"
        />
      </van-cell-group>
      <div style="margin: 16px;">
        <van-button round block type="primary" native-type="submit">
          提交
        </van-button>
      </div>
    </van-form>
    {{
      addTeamData
    }}
  </div>
</template>

<script setup>

import {onMounted, ref} from "vue";
import {useRoute, useRouter} from "vue-router";
import myAxios from "../plugins/myAxios.ts";
import {Toast} from "vant";

const router = useRouter();
const route = useRoute();

const addTeamData = ref({});

// 展示日期选择器
const showPicker = ref(false);
const minDate = new Date();

const id = route.query.id;
// 获取之前的队伍信息
onMounted(async () => {
  if (id < 0) {
    Toast.fail("加载队伍失败，请重试");
    return;
  }
  const res = await myAxios.get("/team/get", {
    params: {
      id,
    }
  });
  if (res?.code === 0) {
    addTeamData.value = res.data;
  } else {
    Toast.fail("加载队伍失败，请重试");
  }
})

//提交
const onSubmit = async () => {
  const postData = {
    ...addTeamData.value,
    status: Number(addTeamData.value.status)
  }
  //todo 前端数据校验
  const res = await myAxios.post("/team/update", postData);
  if (res?.code === 0 && res.data){
    Toast.success("更新成功");
    router.push({
      path: '/team',
      replace: true,
    });
  }else {
    Toast.fail("更新成功");
  }
}

</script>

<style scoped>

</style>
```

![image-20230420091158151](http://qiniu.fickler.top/img/image-20230420091158151.png)

#### 4. 测试

![image-20230420091240056](http://qiniu.fickler.top/img/image-20230420091240056.png)

### 五、修改前端布局

#### 1. 修改之前的页面

1. 将之前的 `UserPage` 修改为 `UserUpdatePage`

![image-20230420162542787](http://qiniu.fickler.top/img/image-20230420162542787.png)

2. 重新复制出来一个 `UserPage` 页面

![image-20230420164302464](http://qiniu.fickler.top/img/image-20230420164302464.png)

#### 2. 新增页面

1. 新增一个 `UserTeamJoinPage` 页面

![image-20230420164417320](http://qiniu.fickler.top/img/image-20230420164417320.png)

2. 新增一个 `UserTeamCreatePage` 页面

![image-20230420164406819](http://qiniu.fickler.top/img/image-20230420164406819.png)

3. 添加对应的路由信息

![image-20230420164459584](http://qiniu.fickler.top/img/image-20230420164459584.png)

> 这里不知道为啥引入的时候报错了，但是可以正常访问，就先使用 `// @ts-ignore` 注解忽视这个问题吧

### 六、查看个人已加入队伍

#### 1. 增加跳转链接

```vue
<van-cell title="我加入的队伍" is-link to="/user/team/join" />
```

#### 2. 查看个人已加入队伍页面

```vue
<template>
  <div id="teamPage">
    <van-search v-model="searchText" placeholder="搜索队伍" @search="onSearch" />
    <team-card-list :team-list="teamList" />
    <van-empty v-if="teamList?.length < 1" description="结果为空" />
  </div>
</template>

<script setup>

import {useRouter} from "vue-router";
import TeamCardList from "../components/TeamCardList.vue";
import {onMounted, ref} from "vue";
import myAxios from "../plugins/myAxios.ts";
import {Toast} from "vant";

const router = useRouter()
const searchText = ref('')

const doJoinTeam = () => {
  router.push({
    path: "/team/add"
  })
}

const teamList = ref([]);

const listTeam = async (val = '') => {
  const res = await myAxios.get("/team/list/my/join", {
    params: {
      searchText: val,
      pageNum: 1,
    }
  });
  if (res?.code === 0) {
    teamList.value = res.data;
  } else {
    Toast.fail("加载队伍失败，请刷新重试")
  }
}

// 在页面加载时只触发一下
onMounted(  () => {
  listTeam();
})

const onSearch = (val) => {
  listTeam(val);
};

</script>

<style scoped>

</style>
```

#### 3. 测试

![image-20230420170511372](http://qiniu.fickler.top/img/image-20230420170511372.png)

### 七、退出队伍

#### 1. 添加退出队伍按钮

```vue
<van-button size="mini" plain type="primary" @click="doQuitTeam(team.id)">退出队伍</van-button>
```

![image-20230420170839379](http://qiniu.fickler.top/img/image-20230420170839379.png)

#### 2. 给按钮绑定事件

```tsx
/**
 * 退出队伍
 * @param id
 */
const doQuitTeam = async (id: number) => {
  const res = await myAxios.post("/team/quit",{
    teamId : id
  });
  //@ts-ignore
  if (res?.code === 0){
    Toast.success("操作成功")
  }else {
    //@ts-ignore
    Toast.fail("操作失败" + (res.description ? `， ${res.description} `:''));
  }
}
```

#### 3. 测试

![image-20230420173254250](http://qiniu.fickler.top/img/image-20230420173254250.png)

> 成功退出后，页面没有刷新，不会重新查询数据进行渲染

### 八、解散队伍

#### 1. 添加解散队伍按钮

```vue
<van-button v-if="team.userId == currentUser?.id" size="mini" plain type="primary" @click="doDeleteTeam(team.id)">解散队伍</van-button>
```

![image-20230420173424552](http://qiniu.fickler.top/img/image-20230420173424552.png)

#### 2. 给按钮绑定事件

```tsx
/**
 * 解散队伍
 * @param id
 */
const doDeleteTeam = async (id: number) => {
  const res = await myAxios.post("/team/delete",{
     id,
  });
  //@ts-ignore
  if (res?.code === 0){
    Toast.success("操作成功")
  }else {
    //@ts-ignore
    Toast.fail("操作成功" + (res.description ? `， ${res.description} `:''));
  }
}
```

#### 3. 修改后端代码

我们之前的后端接口接收的参数类型是 long 类型

![image-20230420172512689](http://qiniu.fickler.top/img/image-20230420172512689.png)

重新封装一个统一的 `deleteRequest`

```java
package com.example.usercenterbackendmaster.common;

import java.io.Serializable;

/**
 * 通用的删除请求参数
 * @author dell
 * @date 2023/4/20 17:26
 */

@Data
public class DeleteRequest implements Serializable {
    
    private static final long serialVersionUID = 6279862015050484265L;

    private long id;

}
```

修改之前的代码

```java
@PostMapping("/delete")
public BaseResponse<Boolean> deleteTeam(@RequestBody DeleteRequest deleteRequest, HttpServletRequest request) {
    if (deleteRequest == null || deleteRequest.getId() <= 0) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    long id = deleteRequest.getId();
    User loginUser = userService.getLoginUser(request);
    boolean result = teamService.deleteTeam(id, loginUser);
    if (!result) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR, "删除失败");
    }
    return ResultUtils.success(result);
}
```

#### 4. 测试

![image-20230420173730046](http://qiniu.fickler.top/img/image-20230420173730046.png)

## 随机匹配

### 一、随机匹配

> 为了帮大家更快的发现和自己兴趣相同的朋友

**匹配 1 个还是匹配多个？**

答：匹配多个，并且按照匹配的相似度从高到低排序

**怎么匹配？（根据什么匹配）**

答：标签 tags

还可以根据 user_team 匹配加入相同队伍的用户

本质：找到有相似标签的用户

举例：

用户 A：[Java, 大一, 男]

用户 B：[Java, 大二, 男]

用户 C：[Python, 大二, 女]

用户 D：[Java, 大一, 女]

#### 1. 怎么匹配

1. 找到有共同标签最多的用户（TopN）
2. 共同标签越多，分数越高，越排在前面
3. 如果没有匹配的用户，随机推荐几个（降级方案）

**编辑距离算法**：[详解编辑距离算法-Levenshtein Distance_BoCong-Deng的博客-CSDN博客](https://blog.csdn.net/DBC_121/article/details/104198838)

最小编辑距离：字符串 1 通过最少多少次增删改字符的操作可以变成字符串 2

**余弦相似度算法**：[java算法（1）——余弦相似度计算字符串相似率_余弦相似度js_阿舒带你学编程的博客-CSDN博客](https://blog.csdn.net/m0_55613022/article/details/125683937)（如果需要带权重计算，比如学什么方向最重要，性别相对次要）

```java
public int minDistance(String word1, String word2){
    int n = word1.length();
    int m = word2.length();
 
    if(n * m == 0)
        return n + m;
 
    int[][] d = new int[n + 1][m + 1];
    for (int i = 0; i < n + 1; i++){
        d[i][0] = i;
    }
 
    for (int j = 0; j < m + 1; j++){
            d[0][j] = j;
    }
 
    for (int i = 1; i < n + 1; i++){
        for (int j = 1; j < m + 1; j++){
            int left = d[i - 1][j] + 1;
            int down = d[i][j - 1] + 1;
            int left_down = d[i - 1][j - 1];
            if (word1.charAt(i - 1) != word2.charAt(j - 1))
                left_down += 1;
            d[i][j] = Math.min(left, Math.min(down, left_down));
        }
    }
    return d[n][m];
}
```

#### 2. 怎么对所有用户匹配，取Top

直接取出所有用户，依次和当前用户计算分数，取 TOP N（54 秒）

优化方法：

1.  切忌不要在数据量大的时候循环输出日志（取消掉日志后 20 秒） 
2.  Map 存了所有的分数信息，占用内存
   解决：维护一个固定长度的有序集合（sortedSet），只保留分数最高的几个用户（时间换空间）
   e.g.【3, 4, 5, 6, 7】取 TOP 5，id 为 1 的用户就不用放进去了 
3.  细节：剔除自己 √ 
4.  尽量只查需要的数据： 

1. 1. 过滤掉标签为空的用户 √

   2. 根据部分标签取用户（前提是能区分出来哪个标签比较重要）

   3. 只查需要的数据（比如 id 和 tags） √（7.0s）

   4. 1.  提前查？（定时任务） 

1. 1. 提前把所有用户给缓存（不适用于经常更新的数据）
   2. 提前运算出来结果，缓存（针对一些重点用户，提前缓存）

### 二、匹配算法

#### 1. 距离算法工具类

```java
package com.example.usercenterbackendmaster.utils;

import java.util.List;

/**
 * 算法工具类
 *
 * @author dell
 * @date 2023/4/21 8:39
 */
public class AlgorithmUtils {

    /**
     * 编辑距离算法（用于计算最相似的两组标签）
     * 原理：https://blog.csdn.net/DBC_121/article/details/104198838
     * @param tagList1
     * @param tagList2
     * @return
     */
    public static int minDistance(List<String> tagList1, List<String> tagList2) {
        int n = tagList1.size();
        int m = tagList2.size();

        if (n * m == 0) {
            return n + m;
        }

        int[][] d = new int[n + 1][m + 1];
        for (int i = 0; i < n + 1; i++) {
            d[i][0] = i;
        }

        for (int j = 0; j < m + 1; j++) {
            d[0][j] = j;
        }

        for (int i = 1; i < n + 1; i++) {
            for (int j = 1; j < m + 1; j++) {
                int left = d[i - 1][j] + 1;
                int down = d[i][j - 1] + 1;
                int left_down = d[i - 1][j - 1];
                if (!tagList1.get(i - 1).equals(tagList2.get(j - 1))) {
                    left_down += 1;
                }
                d[i][j] = Math.min(left, Math.min(down, left_down));
            }
        }
        return d[n][m];
    }

    /**
     * 编辑距离算法（用于计算最相似的两个字符串）
     * 原理：https://blog.csdn.net/DBC_121/article/details/104198838
     * @param word1
     * @param word2
     * @return
     */
    public static int minDistance(String word1, String word2) {
        int n = word1.length();
        int m = word2.length();

        if (n * m == 0) {
            return n + m;
        }

        int[][] d = new int[n + 1][m + 1];
        for (int i = 0; i < n + 1; i++) {
            d[i][0] = i;
        }

        for (int j = 0; j < m + 1; j++) {
            d[0][j] = j;
        }

        for (int i = 1; i < n + 1; i++) {
            for (int j = 1; j < m + 1; j++) {
                int left = d[i - 1][j] + 1;
                int down = d[i][j - 1] + 1;
                int left_down = d[i - 1][j - 1];
                if (word1.charAt(i - 1) != word2.charAt(j - 1)) {
                    left_down += 1;
                }
                d[i][j] = Math.min(left, Math.min(down, left_down));
            }
        }
        return d[n][m];
    }

}
```

#### 2. 测试距离算法

```java
package com.example.usercenterbackendmaster.utils;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

/**
 * @author dell
 * @date 2023/4/21 8:45
 */

@SpringBootTest
class AlgorithmUtilsTest {

    @Test
    void testCompareTags() {
        List<String> tagList1 = Arrays.asList("Java", "大一", "男");
        List<String> tagList2 = Arrays.asList("Java", "大一", "女");
        List<String> tagList3 = Arrays.asList("Python", "大二", "女");
        // 1
        int score1 = AlgorithmUtils.minDistance(tagList1, tagList2);
        // 3
        int score2 = AlgorithmUtils.minDistance(tagList1, tagList3);
        System.out.println(score1);
        System.out.println(score2);
    }

}
```

![image-20230421085907196](http://qiniu.fickler.top/img/image-20230421085907196.png)

### 三、匹配算法实现

#### 1. 实现距离匹配算法

1. 在 `controller` 层新增匹配用户方法

```java
/**
 * 获取匹配用户
 * @param num 推荐数据量
 * @param request 用户登录信息
 * @return
 */
@GetMapping("/match")
public BaseResponse<List<User>> matchUsers (long num, HttpServletRequest request) {
    if (num <= 0 || num > 20) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    User loginUser = userService.getLoginUser(request);
    return ResultUtils.success(userService.matchUsers(num, loginUser));
}
```

2. 在 `service` 层添加方法

```java
/**
 * 匹配用户
 * @param num 匹配数量
 * @param loginUser 用户登录
 * @return
 */
List<User> matchUsers(long num, User loginUser);
```

3. 在 `serviceimpl` 层实现该接口

```java
/**
 * 匹配用户
 * @param num 匹配数量
 * @param loginUser 用户登录
 * @return
 */
@Override
public List<User> matchUsers(long num, User loginUser) {
    List<User> userList = this.list();
    String tags = loginUser.getTags();
    Gson gson = new Gson();
    List<String> tagList = gson.fromJson(tags, new TypeToken<List<String>>() {
    }.getType());
    System.out.println(tagList);
    // 用户列表的下表 => 相似度
    SortedMap<Integer, Long> indexDistanceMap = new TreeMap<>();
    for (int i = 0; i <userList.size(); i++) {
        User user = userList.get(i);
        String userTags = user.getTags();
        //无标签的
        if (StringUtils.isBlank(userTags)){
            continue;
        }
        List<String> userTagList = gson.fromJson(userTags, new TypeToken<List<String>>() {
        }.getType());
        //计算分数
        long distance = AlgorithmUtils.minDistance(tagList, userTagList);
        indexDistanceMap.put(i,distance);
    }
    //下面这个是打印前num个的id和分数
    List<User> userListVo = new ArrayList<>();
    int i = 0;
    for (Map.Entry<Integer,Long> entry : indexDistanceMap.entrySet()){
        if (i > num){
            break;
        }
        User user = userList.get(entry.getKey());
        System.out.println(user.getId() + ":" + entry.getKey() + ":" + entry.getValue());
        userListVo.add(user);
        i++;
    }
    return userListVo;
}
```

#### 2. 测试

![image-20230421225452576](http://qiniu.fickler.top/img/image-20230421225452576.png)

### 四、优化匹配算法

#### 1. 优化算法

1. 剔除自己 
2. 过滤掉标签为空的用户 
3. 只查需要的数据（比如 id 和 tags）

```java
/**
 * 匹配用户
 *
 * @param num       匹配数量
 * @param loginUser 用户登录
 * @return
 */
@Override
public List<User> matchUsers(long num, User loginUser) {
    QueryWrapper<User> queryWrapper = new QueryWrapper<>();
    queryWrapper.isNotNull("tags");
    queryWrapper.select("id", "tags");
    List<User> userList = this.list(queryWrapper);
    String tags = loginUser.getTags();
    Gson gson = new Gson();
    List<String> tagList = gson.fromJson(tags, new TypeToken<List<String>>() {
    }.getType());
    // 用户列表的下表 => 相似度'
    List<Pair<User, Long>> list = new ArrayList<>();
    // 依次计算当前用户和所有用户的相似度
    for (int i = 0; i < userList.size(); i++) {
        User user = userList.get(i);
        String userTags = user.getTags();
        //无标签的 或当前用户为自己
        if (StringUtils.isBlank(userTags) || user.getId() == loginUser.getId()) {
            continue;
        }
        List<String> userTagList = gson.fromJson(userTags, new TypeToken<List<String>>() {
        }.getType());
        //计算分数
        long distance = AlgorithmUtils.minDistance(tagList, userTagList);
        list.add(new Pair<>(user, distance));
    }
    //按编辑距离有小到大排序
    List<Pair<User, Long>> topUserPairList = list.stream()
            .sorted((a, b) -> (int) (a.getValue() - b.getValue()))
            .limit(num)
            .collect(Collectors.toList());
    //有顺序的userID列表
    List<Long> userListVo = topUserPairList.stream().map(pari -> pari.getKey().getId()).collect(Collectors.toList());

    //根据id查询user完整信息
    QueryWrapper<User> userQueryWrapper = new QueryWrapper<>();
    userQueryWrapper.in("id", userListVo);
    Map<Long, List<User>> userIdUserListMap = this.list(userQueryWrapper).stream()
            .map(user -> getSafetyUser(user))
            .collect(Collectors.groupingBy(User::getId));

    // 因为上面查询打乱了顺序，这里根据上面有序的userID列表赋值
    List<User> finalUserList = new ArrayList<>();
    for (Long userId : userListVo) {
        finalUserList.add(userIdUserListMap.get(userId).get(0));
    }
    return finalUserList;
}
```

#### 2. 测试

![image-20230422090621229](http://qiniu.fickler.top/img/image-20230422090621229.png)

## 前端优化

### 一、添加匹配功能和加载骨架屏特效

#### 1. 添加用户匹配开关

```vue
<van-cell center title="心动模式">
  <template #right-icon>
    <van-switch v-model="isMatchMode" size="24" />
  </template>
</van-cell>
```

默认是关闭状态

```tsx
const isMatchMode = ref<Boolean>(false);
```

![image-20230422095822988](http://qiniu.fickler.top/img/image-20230422095822988.png)

#### 2. 添加匹配事件

```tsx
const loadData = async () => {
  let userListData;
  // 心动模式
  if (isMatchMode.value) {
    const num = 10;
    userListData = await myAxios.get('/user/match', {
      params: {
        num,
      },
    })
        .then(function (response) {
          console.log('/user/match success', response);
          Toast.success('请求成功');
          console.log(response);
          return response?.data;
        })
        .catch(function (error) {
          console.log('/user/match error', error);
          Toast.fail('请求失败');
        })
    // 普通模式
  } else {
    userListData = await myAxios.get('/user/recommend', {
      params: {
        pageSize: 8,
        pageNum: 1,
      },
    })
        .then(function (response) {
          console.log('/user/recommend success', response);
          Toast.success('请求成功');
          console.log(response);
          return response?.data?.records;
        })
        .catch(function (error) {
          console.log('/user/recommend error', error);
          Toast.fail('请求失败');
        })
  }
  if (userListData) {
    userListData.forEach(user => {
      if (user.tags) {
        user.tags = JSON.parse(user.tags);
      }
    })
    userList.value = userListData;
  }
}
```

#### 4. 添加watchEffect事件

`watchEffect` 会在按钮点击一次触发一次

```tsx
watchEffect(() => {
  loadData();
})
```

> vue3 的语法

#### 5. 测试

![image-20230422095851433](http://qiniu.fickler.top/img/image-20230422095851433.png)

![image-20230422101711239](http://qiniu.fickler.top/img/image-20230422101711239.png)

#### 6. 添加骨架屏特效

![image-20230423101330322](http://qiniu.fickler.top/img/image-20230423101330322.png)

![image-20230423102035156](http://qiniu.fickler.top/img/image-20230423102035156.png)

![image-20230423102537927](http://qiniu.fickler.top/img/image-20230423102537927.png)

### 二、队伍操作按钮

仅加入队伍和创建队伍的人能看到队伍操作按钮（listTeam 接口要能获取我加入的队伍状态） 

方案 1：前端查询我加入了哪些队伍列表，然后判断每个队伍 id 是否在列表中（前端要多发一次请求）

方案 2：在后端去做上述事情（推荐）

```java
@GetMapping("/list")
public BaseResponse<List<TeamUserVO>> listTeams(TeamQuery teamQuery, HttpServletRequest request) {
    if (teamQuery == null) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    boolean isAdmin = userService.isAdmin(request);
    List<TeamUserVO> teamList = teamService.listTeams(teamQuery, isAdmin);
    // 判断当前用户是否已加入队伍
    List<Long> teamIdList = teamList.stream().map(TeamUserVO::getId).collect(Collectors.toList());
    QueryWrapper<UserTeam> userTeamQueryWrapper = new QueryWrapper<>();
    try {
        User loginUser = userService.getLoginUser(request);
        userTeamQueryWrapper.eq("userId", loginUser.getId());
        userTeamQueryWrapper.in("teamId", teamIdList);
        List<UserTeam> userTeamList = userTeamService.list(userTeamQueryWrapper);
        // 已加入队伍的id集合
        Set<Long> hasJoinTeamIdSet = userTeamList.stream().map(UserTeam::getTeamId).collect(Collectors.toSet());
        teamList.forEach(team -> {
            boolean hasJoin = hasJoinTeamIdSet.contains(team.getId());
            team.setHasJoin(hasJoin);
        });
    } catch (Exception e) {

    }
    return ResultUtils.success(teamList);
}
```

#### 1. 加入队伍 

> 仅非队伍创建人、且未加入队伍的人可见

```vue
<van-button v-if="team.userId !== currentUser?.id && !team.hasJoin" size="mini" plain type="primary" @click="doJoinTeam(team.id)">加入队伍</van-button>
```

#### 2. 更新队伍

> 仅创建人可见

```vue
<van-button v-if="team.userId === currentUser?.id" size="mini" plain type="primary" @click="doUpdateTeam(team.id)">更新队伍</van-button>
```

#### 3. 解散队伍

> 仅创建人可见

```vue
<van-button v-if="team.userId === currentUser?.id" size="mini" plain type="primary" @click="doDeleteTeam(team.id)">解散队伍</van-button>
```

#### 4. 退出队伍

> 创建人不可见，仅已加入队伍的人可见

```vue
<van-button v-if="team.userId !== currentUser?.id && team.hasJoin" size="mini" plain type="primary" @click="doQuitTeam(team.id)">退出队伍</van-button>
```

#### 5. 测试

![image-20230423112530607](http://qiniu.fickler.top/img/image-20230423112530607.png)

### 三、前端导航栏标题

**解决办法：**使用 `router.beforeEach`，根据要跳转页面的 `url` 路径 匹配 `config/routes` 配置的 `title` 字段

> 不要写死！！！

#### 1. 在之前的路由上添加title字段

![image-20230423113458571](http://qiniu.fickler.top/img/image-20230423113458571.png)

#### 2. 在BasicLayout里增加根据路由切换标题

![image-20230423114449536](http://qiniu.fickler.top/img/image-20230423114449536.png)

```tsx
const DEFAULT_TITLE = '伙伴匹配';
const title = ref(DEFAULT_TITLE);

/**
 * 根据路由切换标题
 */
router.beforeEach((to, from) => {
  const toPath = to.path;
  const route = routes.find((route) => {
    return toPath == route.path;
  })
  title.value = route?.title ?? DEFAULT_TITLE;
})
```

#### 3. 测试

![image-20230423114333754](http://qiniu.fickler.top/img/image-20230423114333754.png)

### 四、强制登录，自动跳转到登录页面

**解决办法：**

1. 在哪个页面没有登录就在哪个页面进行登录
2. axios 全局配置响应拦截、并且添加重定向

#### 1. 在响应拦截器中添加拦截

```tsx
// 未登录跳转到登录页面
if (response?.data?.code === 40100) {
    window.location.href = '/user/login';
}
```

![image-20230423151134787](http://qiniu.fickler.top/img/image-20230423151134787.png)

> 因为使用的 web 哈希路由所以会出现 `#`
>
> ![image-20230423151302129](http://qiniu.fickler.top/img/image-20230423151302129.png)

改为常规的服务器

![image-20230423151315762](http://qiniu.fickler.top/img/image-20230423151315762.png)

![image-20230423151352756](http://qiniu.fickler.top/img/image-20230423151352756.png)

#### 2. 登录成功后跳转到之前的页面

当前我们登录成功后，是直接返回到首页，正常的逻辑应该是跳转到之前的页面

**解决办法：**

在登录页面的 url 后面拼接上当前页面的地址，登录成功后跳转到当前页面（url 后面拼接的地址）

![image-20230423152103598](http://qiniu.fickler.top/img/image-20230423152103598.png)

1. 在 url 后面拼接上当前页面的地址

```tsx
// 未登录跳转到登录页面
if (response?.data?.code === 40100) {
    const redirectUrl = window.location.href;
    window.location.href = `/user/login?redirectUrl=${redirectUrl}`;
}
```

2. 在当前页面取到后面拼接的地址

![image-20230423152728929](http://qiniu.fickler.top/img/image-20230423152728929.png)

3. 测试一下

![image-20230423152804532](http://qiniu.fickler.top/img/image-20230423152804532.png)

### 五、修改队伍页面加入队伍按钮

#### 1. 将之前的doJoinTeam全局修改为toAddTeam

![image-20230423153512641](http://qiniu.fickler.top/img/image-20230423153512641.png)

#### 2. 修改按钮样式

1. 按钮样式

```vue
<van-button class="add-button" type="primary" icon="plus" @click="toAddTeam"/>
```

2. 引入 css 文件

```css
.add-button {
    position: fixed;
    bottom: 60px;
    width: 50px;
    right: 12px;
    height: 50px;
    border-radius: 50%;
    /*置于最上层*/
    z-index: 1;
}
```

![image-20230423154328404](http://qiniu.fickler.top/img/image-20230423154328404.png)

### 六、区分公开和加密房间

#### 1. 在前端区分公开和加密房间

1. 添加tab标签栏，区分公开和加密

![image-20230423160642007](http://qiniu.fickler.top/img/image-20230423160642007.png)

2. 绑定切换查询状态

```tsx
/**
 * 切换查询状态
 * @param name
 */
const onTabChange = (name) => {
  // 查公开
  if (name === 'public') {
    listTeam(searchText.value, 0);
  } else {
    // 查加密
    listTeam(searchText.value, 2);
  }
}
```

3. 增加查询队伍传递的参数

> status：状态

```tsx
const listTeam = async (val = '', status = 0) => {
  const res = await myAxios.get("/team/list", {
    params: {
      searchText: val,
      pageNum: 1,
      status,
    }
  });
  if (res?.code === 0) {
    teamList.value = res.data;
  } else {
    Toast.fail("加载队伍失败，请刷新重试")
  }
}
```

#### 2. 修改后端

> 只有管理员可以查看加密队伍

```java
if (!isAdmin && statusEnum.equals(TeamStatusEnum.PRIVATE)) {
    throw new BusinessException(ErrorCode.NO_AUTH);
}
```

#### 3. 测试

![image-20230423161856260](http://qiniu.fickler.top/img/image-20230423161856260.png)

![image-20230423161910817](http://qiniu.fickler.top/img/image-20230423161910817.png)

### 七、加入有密码的队伍

#### 1. 在teamcardlist页面添加弹出框

![image-20230423170341407](http://qiniu.fickler.top/img/image-20230423170341407.png)

![image-20230423170454487](http://qiniu.fickler.top/img/image-20230423170454487.png)

![image-20230423170520585](http://qiniu.fickler.top/img/image-20230423170520585.png)

```vue
<template>
  <div id="teamCardList">
    <van-card
        v-for="team in props.teamList"
        :desc="team.description"
        thumb="http://qzapp.qlogo.cn/qzapp/101983660/DE2DFA542010DAD2696FC2082D1EE3E7/100"
        :title="`${team.name}`"
    >
      <template #tags>
        <van-tag plain type="primary" style="margin-right: 8px; margin-top: 8px">
          {{
            teamStatusEnum[team.status]
          }}
        </van-tag>
      </template>
      <template #bottom>
        <div>
          {{ '最大人数' + team.maxNum }}
        </div>
        <div>
          {{ '过期时间' + team.expireTime }}
        </div>
        <div>
          {{ '创建时间' + team.createTime }}
        </div>
      </template>
      <template #footer>
        <van-button v-if="team.userId !== currentUser?.id && !team.hasJoin" size="mini" plain type="primary"
                    @click="preJoinTeam(team)">加入队伍
        </van-button>
        <van-button v-if="team.userId === currentUser?.id" size="mini" plain type="primary"
                    @click="doUpdateTeam(team.id)">更新队伍
        </van-button>
        <van-button v-if="team.userId !== currentUser?.id && team.hasJoin" size="mini" plain type="primary"
                    @click="doQuitTeam(team.id)">退出队伍
        </van-button>
        <van-button v-if="team.userId === currentUser?.id" size="mini" plain type="danger"
                    @click="doDeleteTeam(team.id)">解散队伍
        </van-button>
      </template>
    </van-card>
  </div>
  <van-dialog v-model:show="showPasswordDialog" title="请输入密码" show-cancel-button @confirm="doJoinTeam"
              @cancel="doJoinCancel">
    <van-field v-model="password" placeholder="请输入密码"/>
  </van-dialog>
</template>

<script setup lang="ts">

import {TeamType} from "../models/team";
import {teamStatusEnum} from "../constants/team";
import myAxios from "../plugins/myAxios";
import {Dialog, Toast} from "vant";
import {onMounted, ref} from "vue";
import {getCurrentUser} from "../service/user";
import {useRouter} from "vue-router";

const router = useRouter();

interface TeamCardListProps {
  teamList: TeamType[];
}

const props = defineProps<TeamCardListProps>();

const showPasswordDialog = ref(false);
const password = ref('');
const joinTeamId = ref(0);
const currentUser = ref();

const VanDialog = Dialog.Component;

// 获取用户信息
onMounted(async () => {
  currentUser.value = await getCurrentUser();
})

const preJoinTeam = (team: TeamType) => {
  joinTeamId.value = team.id;
  if (team.status === 0) {
    doJoinTeam();
  } else {
    showPasswordDialog.value = true;
  }
}

const doJoinCancel = () => {
  joinTeamId.value = 0;
  password.value = '';
}

/**
 * 加入队伍
 */
const doJoinTeam = async () => {
  if (!joinTeamId.value) {
    return;
  }
  const res = await myAxios.post("/team/join", {
    teamId: joinTeamId.value,
    password: password.value
  });
  //@ts-ignore
  if (res?.code === 0) {
    Toast.success("加入成功");
    doJoinCancel();
  } else {
    //@ts-ignore
    Toast.fail("加入失败" + (res.description ? `， ${res.description} ` : ''));
  }
}

/**
 * 更新队伍
 * @param id
 */
const doUpdateTeam = (id: number) => {
  router.push({
    path: '/team/update',
    query: {
      id,
    }
  })
}

/**
 * 退出队伍
 * @param id
 */
const doQuitTeam = async (id: number) => {
  const res = await myAxios.post("/team/quit", {
    teamId: id
  });
  //@ts-ignore
  if (res?.code === 0) {
    Toast.success("操作成功")
  } else {
    //@ts-ignore
    Toast.fail("操作失败" + (res.description ? `， ${res.description} ` : ''));
  }
}

/**
 * 解散队伍
 * @param id
 */
const doDeleteTeam = async (id: number) => {
  const res = await myAxios.post("/team/delete", {
    id,
  });
  //@ts-ignore
  if (res?.code === 0) {
    Toast.success("操作成功")
  } else {
    //@ts-ignore
    Toast.fail("操作成功" + (res.description ? `， ${res.description} ` : ''));
  }
}

</script>

<style scoped>
#teamCardList :deep(.van-image__img) {
  height: 128px;
  object-fit: unset;
}
</style>
```

#### 2. 测试一下

![image-20230423170137890](http://qiniu.fickler.top/img/image-20230423170137890.png)

### 八、展示已加入队伍人数

#### 1. 后端实现

1. 在`TeamUserVo`封装类中添加字段

![image-20230423171923297](http://qiniu.fickler.top/img/image-20230423171923297.png)

2. 修改listTeam接口

```java
// 3. 查询已加入队伍的人数
QueryWrapper<UserTeam> userTeamJoinQueryWrapper = new QueryWrapper<>();
userTeamJoinQueryWrapper.in("teamId", teamIdList);
List<UserTeam> userTeamList = userTeamService.list(userTeamJoinQueryWrapper);
// 队伍 id => 加入这个队伍的用户列表
Map<Long, List<UserTeam>> teamIdUserTeamList = userTeamList.stream().collect(Collectors.groupingBy(UserTeam::getTeamId));
teamList.forEach(team -> team.setHasJoinNum(teamIdUserTeamList.getOrDefault(team.getId(), new ArrayList<>()).size()));
```

#### 2. 前端展示

1. 将之前的队伍最大人数改为 队伍人数/最大人数

![image-20230423173758408](http://qiniu.fickler.top/img/image-20230423173758408.png)

2. 在之前的team实体类中添加队伍已加入人数字段

![image-20230423173907109](http://qiniu.fickler.top/img/image-20230423173907109.png)

#### 3. 测试

![image-20230423173721461](http://qiniu.fickler.top/img/image-20230423173721461.png)

### 九、重复加入队伍的问题

只要我们点的足够快，就可以在同一时间内往数据库插入多条同样的数据，所以这里我们使用分布式锁（推荐）使用两把锁，一把锁锁队伍，一把锁锁用户（实现较难，不推荐）

**不是很理解加锁，redis也还没有学，后面学了再理解理解**

```java
@Override
public boolean joinTeam(TeamJoinRequest teamJoinRequest, User loginUser) {
    if (teamJoinRequest == null) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    Long teamId = teamJoinRequest.getTeamId();
    if (teamId == null || teamId < 0) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    Team team = getTeamById(teamId);
    Date expireTime = team.getExpireTime();
    if (expireTime != null && expireTime.before(new Date())) {
        throw new BusinessException(ErrorCode.NULL_ERROR, "队伍已过期");
    }
    Integer status = team.getStatus();
    TeamStatusEnum teamStatusEnum = TeamStatusEnum.getEnumByValue(status);
    if (TeamStatusEnum.PRIVATE.equals(teamStatusEnum)) {
        throw new BusinessException(ErrorCode.NULL_ERROR, "禁止加入私有队伍");
    }
    String password = teamJoinRequest.getPassword();
    if (TeamStatusEnum.SECRET.equals(teamStatusEnum)) {
        if (StringUtils.isBlank(password) || !password.equals(team.getPassword())) {
            throw new BusinessException(ErrorCode.NULL_ERROR, "密码错误");
        }
    }
    // 该用户已加入队伍的数量
    long userId = loginUser.getId();
    // 只有一个线程能获取到锁
    RLock lock = redissonClient.getLock("matchup:join_team");
    try {
        // 抢到锁并执行
        while (true) {
            if (lock.tryLock(0,-1, TimeUnit.MILLISECONDS)) {
                System.out.println("getLock: " + Thread.currentThread().getId());
                QueryWrapper<UserTeam> userTeamQueryWrapper = new QueryWrapper<>();
                userTeamQueryWrapper.eq("userId", userId);
                long hasJoinNum = userTeamService.count(userTeamQueryWrapper);
                if (hasJoinNum > 5) {
                    throw new BusinessException(ErrorCode.PARAMS_ERROR, "最多创建和加入5个队伍");
                }
                // 不能重复加入已加入的队伍
                userTeamQueryWrapper = new QueryWrapper<>();
                userTeamQueryWrapper.eq("userId", userId);
                userTeamQueryWrapper.eq("teamId", teamId);
                long hasUserJoinTeam = userTeamService.count(userTeamQueryWrapper);
                if (hasUserJoinTeam > 0) {
                    throw new BusinessException(ErrorCode.PARAMS_ERROR, "用户已加入该队伍");
                }
                // 已加入队伍的人数
                long teamHasJoinNum = this.countTeamUserByTeamId(teamId);
                if (teamHasJoinNum > team.getMaxNum()) {
                    throw new BusinessException(ErrorCode.PARAMS_ERROR, "队伍已满");
                }
                // 修改队伍信息
                UserTeam userTeam = new UserTeam();
                userTeam.setUserId(userId);
                userTeam.setTeamId(teamId);
                userTeam.setJoinTime(new Date());
                return userTeamService.save(userTeam);
            }
        }
    } catch (InterruptedException e) {
        log.error("doCacheRecommendUser error", e);
        return false;
    } finally {
        // 只能释放自己的锁
        if (lock.isHeldByCurrentThread()) {
            System.out.println("unLock: " + Thread.currentThread().getId());
            lock.unlock();
        }
    }
}
```

## 部署上线

### 一、前端部署上线

#### 1. 前端打包

1. 点击 build

![image-20230423230432396](http://qiniu.fickler.top/img/image-20230423230432396-1682262414091-3.png)

2. 报错了

![image-20230423230625652](http://qiniu.fickler.top/img/image-20230423230625652.png)

3. 将 `<script setup>` 替换为 `<script setup lang="ts">`

![image-20230423230915494](http://qiniu.fickler.top/img/image-20230423230915494.png)

4. 再build一次

> 这个报错是因为不符合 ts 标准

![image-20230423231049543](http://qiniu.fickler.top/img/image-20230423231049543.png)

5. 直接使用 `vite build`，不进行tsc校验

![image-20230423231405030](http://qiniu.fickler.top/img/image-20230423231405030.png)

6. 再再 build 一次

![image-20230423231443739](http://qiniu.fickler.top/img/image-20230423231443739.png)

打包成功后会生一个dist文件夹

![image-20230423231614918](http://qiniu.fickler.top/img/image-20230423231614918.png)

#### 2. 使用vercel部署上线

vercel使用：[1分钟上线个人网站？这个工具杀疯了！_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1TV4y1j76t/?vd_source=7bbf2759623907a9489ca0ed493555ee)

1. 下载安装

![image-20230424084215969](http://qiniu.fickler.top/img/image-20230424084215969.png)

2. 部署前端项目

![image-20230424084613181](http://qiniu.fickler.top/img/image-20230424084613181.png)

3. 访问看一下

![image-20230424092500212](http://qiniu.fickler.top/img/image-20230424092500212.png)

> 部署成功，但是后端没有部署，所以访问不了

### 二、后端部署

#### 1. 后端打包

1. 因为微信云托管平台是使用的容器打包构建所以我们要给我们的java项目添加dockerfile文件

```dockerfile
FROM maven:3.5-jdk-8-alpine as builder

# Copy local code to the container image.
WORKDIR /app
COPY pom.xml .
COPY src ./src

# Build a release artifact.
RUN mvn package -DskipTests

# Run the web service on container startup.
CMD ["java","-jar","/app/target/matchup-backend-0.0.1-SNAPSHOT.jar","--spring.profiles.active=prod"]
```

2. **将数据库和redis的地址改为线上的地址**

#### 2. 使用微信云托管

![image-20230424084738693](http://qiniu.fickler.top/img/image-20230424084738693.png)

> 没有数据库和redis，这是没办法部署了，呜呜呜，没钱买

## 简历写法

项目介绍：

基于 vue3 + springboot2 的移动端网站，实现了用户管理、按标签搜索用户、推荐相似用户、组队等功能。

主要工作：

1. 用户登录：使用 Redis 实现分布式 session，解决了集群间登录态同步问题；并使用 Hash 代替 String 来存储用户信息，节约了 xx% 的内存并便于单字段的修改。（需要自己实际测试对比数据，节省内存的原因是不用保存序列化对象信息或者 JSON 的一些额外字符串）
2. 对于项目中复杂的集合处理（比如队伍列表关联已加入队伍的用户），使用 Java8 Stream API 和 Lambda 表达式来简化编码。
3. 使用 Easy Excel 读取收集来的基础用户信息，并通过自定义线程池 + CompletableFuture 并发编程提高批量导入数据库的性能。实测导入 100 万行的时间从 xx 秒缩短至 xx 秒。（需要自己实际测试对比数据）
4. 使用 Redis 缓存首页高频访问的用户信息列表，将接口响应时长从 xx 秒缩短至 xx 秒。并且通过自定义 Redis 序列化器来解决数据乱码、空间浪费的问题。
5. 为解决首次访问系统的用户主页加载过慢的问题，使用 Spring Scheduler 定时任务来实现缓存预热，并通过分布式锁保证多机部署定时任务不会重复执行。
6. 为解决同一用户重复加入队伍、入队人数超限的问题，使用 Redisson 分布式锁来实现操作互斥，保证了接口幂等性。
7. 使用编辑距离算法实现了根据标签匹配最相似用户的功能，并通过优先队列来减少 TOP N 运算过程中的内存占用。
8. 自主编写 Dockerfile，并通过第三方容器托管平台实现自动化镜像构建及容器部署，提高部署上线效率。
9. 使用 Knife4j + Swagger 自动生成后端接口文档，并通过编写 ApiOperation 等注解补充接口注释，避免了人工编写维护文档的麻烦。
10. 前端使用 Vant UI 组件库，并封装了全局通用的 Layout 组件，是主页、搜索页、组队页布局一直，并减少重复代码。
11. 基于 Vue Router 全局路由收尾实现了根据不同页面来动态切换导航栏标题，并通过在全局路由配置文件扩展 title 字段来减少无意义的 if else 代码。
