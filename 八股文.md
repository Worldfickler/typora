# 1. JDK、JRE、JVM分别是什么？有什么区别？

1. JDK 是 Java 开发包，包含了编写、编译、调试和运行 Java 程序所需要的所有工具，它由 JRE 和一些其他工具组成，如编译工具 javac、java API、调试工具等。
2. JRE 是 Java 运行时环境，包括 Java 虚拟机（JVM）和 Java 标准类库（Java API）。它提供了在计算机上运行 Java 程序所需要的最小环境。
3. JVM 是 Java 虚拟机，是 Java 的运行环境。JVM 负责将 Java 代码解释或编译成本地机器代码，并在运行时提供必要的环境支持，比如内存管理、垃圾回收、安全性等。JVM 的主要功能是将 Java 代码转换为可以在计算机上运行的机器码，并负责程序的执行。

他们之间的区别可以总结为：

- JDK 是 Java 开发的工具包，主要用于开发 Java 程序。
- JRE 是 Java 运行时环境，用于在计算机上运行 Java 程序。
- JVM 是 Java 虚拟机，是 Java 程序运行的环境。负责将 Java 代码转换为可以在计算机上运行的机器码，并提供必要的环境支持。【JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或个人都可以开发自己专属的 JVM】

JDK = JRE + 其他开发工具（java.exe、javac.exe、javaw.exe）

JRE = JVM + 核心类库（Java API）



# 2. Java 访问修饰符 public、protected、default、private 的区别？

在 Java 中，访问修饰符是指控制类、接口、方法、属性等成员的访问范围。Java 提供了四种访问修饰符，分别是 public、protected、default、private。

- public：可以被任何的类或者对象访问。
- protected：可以被当前类、子类和同一个包中的类访问。
- default：可以被当前类和同一个包中的类访问。
- private：只能被定义该成员的类访问，其它类无法访问。

![image-20240322102211166](http://qiniu.fickler.top/img/image-20240322102211166.png)



# 3. 数据的基本类型和包装类型的区别？

- 基本类型直接存储数据值，在栈上分配内存，占用固定的内存空间。
- 包装类型是对象动态分配内存，在堆上创建，包含额外的信息，比如方法和字段，同时也占用更多的内存空间。

Java 中提供了自动装箱和拆箱的功能，使得基本数据类型和包装类型之间的转换更为方便。



# 4. 静态代码块的执行？

static 静态代码块是类初始化的一部分，它会在类首次被加载到 JVM 的时候执行，也就是当类被首次主动使用时，静态代码块会被执行，后续无论创建多少该类的实例或访问该类的静态代码块，该静态代码块都不会再执行了。

类主动使用的情况：

1. 创建类的实例（即使用`new`关键字）。
2. 访问类的静态字段或调用静态方法。
3. 使用`Class.forName()`方法加载类。
4. 如果类有一个父类，并且这个父类还没有被初始化，那么父类的静态代码块会首先执行。

```java
public class MyClass {  
    static {  
        // 这是一个静态代码块  
        System.out.println("静态代码块被执行了");  
        // 可以在这里初始化静态变量或执行其他初始化代码  
    }  
      
    public static void main(String[] args) {  
        // 当MyClass首次被主动使用时，静态代码块会被执行  
        System.out.println("main方法开始执行");  
        MyClass obj = new MyClass(); // 创建实例不会再次执行静态代码块  
        System.out.println("main方法结束执行");  
    }  
}
```

输出结果：

```
静态代码块被执行了  
main方法开始执行  
main方法结束执行
```



# 5. 面向对象的三大特征？

1. 封装：为了提高代码的安全性，隐藏对象的内部细节，封装将对象内部的状态（字段、属性）隐藏起来，并通过定义公共的方法（接口）来操作对象，外部代码只需要知道如何使用这些方法而无需了解其内部细节。
2. 继承：允许一个类（子类）继承另一个类（父类）的属性和方法。子类可以重用父类的代码，并且可以通过添加新的方法或者重写父类的方法来扩展和改进功能，提高了代码的可重用性和可扩展性。
3. 多态：多态指的是相同的操作或方法可以在不同的对象上产生不同的行为，通过方法的重载和重写实现。提高了代码的灵活性。



# 6. 说一说你对多态的理解？

当把一个子类对象直接赋给父类引用变量时，例如 `Baseclass obj = new Subclass();`，这个 obj 引用变量的编译时类型是 Baseclass，而运行时类型是 Subclass，当运行时调用该引用变量的方法时，其方法行为总是表现出子类方法的行为特征，而不是父类方法的行为特征，这就可能出现：相同类型的变量、调用同一个方法时呈现出多种不同的行为特征，这就是多态。



# 7. 编译时多态和运行时多态的区别？

1. 编译时多态，它是指在编译阶段就能确定调用哪个方法，是通过方法的重载来实现。方法重载是指在同一个类中，可以有多个同名但参数列表（参数个数、类型或顺序）不同的方法。在编译阶段，编译器根据传入的参数类型和数量，确定调用哪个具体的方法。

```java
public class Calculator {  
    public int add(int a, int b) {  
        return a + b;  
    }  
      
    public double add(double a, double b) {  
        return a + b;  
    }  
      
    public static void main(String[] args) {  
        Calculator calculator = new Calculator();  
        int sumInts = calculator.add(1, 2); // 调用 int 类型的 add 方法  
        double sumDoubles = calculator.add(1.0, 2.0); // 调用 double 类型的 add 方法  
    }  
}
```

在这个例子中，`add` 方法被重载了两次，分别接受两个 `int` 类型参数和两个 `double` 类型参数。在 `main` 方法中，根据传入的参数类型，编译器在编译时就能确定调用哪个 `add` 方法，这是编译时多态的一个例子。

2. 运行时多态，根据实际对象的类型来确定调用的方法，是通过方法的重写来实现的。重写是指子类可以提供与父类相同方法名、相同参数列表的方法实现。在运行时，通过对象的实际类型来动态地确定调用哪个类的重写方法。这通常发生在父类引用指向子类对象时。

```java
class Animal {  
    public void makeSound() {  
        System.out.println("The animal makes a sound");  
    }  
}  
  
class Dog extends Animal {  
    @Override  
    public void makeSound() {  
        System.out.println("The dog barks");  
    }  
}  
  
public class Main {  
    public static void main(String[] args) {  
        Animal myPet = new Dog(); // 父类引用指向子类对象  
        myPet.makeSound(); // 输出 "The dog barks"，运行时调用 Dog 类的 makeSound 方法  
    }  
}
```

在这个例子中，`Dog` 类继承了 `Animal` 类，并重写了 `makeSound` 方法。在 `main` 方法中，虽然 `myPet` 被声明为 `Animal` 类型，但实际上它指向的是一个 `Dog` 对象。因此，当调用 `myPet.makeSound()` 时，实际上调用的是 `Dog` 类的 `makeSound` 方法，而不是 `Animal` 类的。这种在运行时根据对象的实际类型确定调用哪个方法的行为，就是运行时多态。



# 8. 接口和抽象类有什么区别？

1. 定义：
   - 接口是一种抽象类型，它定义了一组方法但却没有具体实现的代码。接口中的方法默认是抽象的，且接口中只能包含常量和抽象方法。
   - 抽象类是一个类，可以包含抽象方法和具体方法。抽象方法是没有实现的方法，而具体方法则包含实现代码。抽象类不能直接实例化，通常需要子类继承并实现抽象方法。
2. 继承：
   - 接口支持多继承，一个类可以实现多个接口。
   - Java 中不支持多继承，一个类只能继承一个抽象方法。如果一个类已经继承了一个抽象类了，就不能再继承其他类了。
3. 构造器：
   - 接口不能包含构造器，因为接口不能被实例化。
   - 抽象类可以包含构造器，用于初始化抽象类的实例。
4. 访问修饰符：
   - 接口中的方法默认是 `public abstract` 的。接口中的变量默认是 `public static final`
   - 抽象类中的抽象方法默认是 `protected` 的，具体方法的修饰符可以是 `public`、`protected`、`private`
5. 实现限制：
   - 类可以同时实现多个接口，实现接口的类必须提供接口中定义的所有方法。
   - 一个类只能继承一个抽象类，继承抽象类的子类必须提供抽象类中定义的全部抽象方法的实现。



# 9. 你对 static 关键字有哪些认识？

1. 静态变量

静态变量是被 static 关键字修饰的变量，被类的所有实例共享，无论一个类创建了多少个对象，它们都共享一份静态变量。

2. 静态方法

静态方法是被 static 关键字修饰的方法，可以通过类名调用，而不需要创建类的实例。

3. 静态代码块

静态代码块是被 static 关键字修饰的代码块，它在类加载的时候执行，并且只执行一次。

4. 静态内部类

静态内部类是被 static 关键字修饰的内部类，可以直接访问外部类的所有静态成员（包括私有的），而不能访问非静态成员。



# 10. static 和 final 有什么区别？

- static 修饰成员，该成员是类级别的，而不是实例级别的。静态成员属于类，而不属于类的实例。

```java
public class MyClass {
    static int staticVariable;	// 静态变量
    static void staticMethod() {	// 静态方法
    	// ...
    }
}
int value = MyClass.staticVariable;
MyClass.staticMethod();
```

- 当 final 修饰变量、方法或类时，它表示是不可变的。对于变量，一旦赋值就不能再修改；对于方法，表示该方法不能被子类重写；对于类，表示类不能被继承。

```java
public class Example {
    final int constantValue = 42;	// 不可变的变量
    final void finalMethod() {	// 不可变的方法
        // ...
    }
}
final class FinalClass {	// 不可变的类
    // ...
}
```



# 11. String 的存储原理？

- String 类型是不可变的。
- Java 中用双引号括起来的字符串，例如：“abc”、“def”，都是直接存储在“方法区”的“字符常量池”中的。
- 为什么要把字符串存储在“字符常量池”中呢？
  - 因为字符串在实际开发中使用太频繁
  - 为了提高执行效率，所以把字符串放到了“方法区”的“字符常量池”中了

![image-20240323104151179](http://qiniu.fickler.top/img/image-20240323104151179.png)

![image-20240323104204251](http://qiniu.fickler.top/img/image-20240323104204251.png)



# 12. String 类可以被继承吗？

不能被继承，因为 String 类有 final 修饰符，而 final 修饰的类是不能被继承的。

final 修饰的特点：

1. 修饰类：final 修饰的类不可被继承，是最终类。
2. 修饰方法：表示该方法不能被子类重写。
3. 修饰变量：
   1. 修饰基本数据类型的变量，其数值一旦在初始化之后就不能再更改，称为常量。
   2. 修饰引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。虽然不能再指向其它的对象，但是它指向的对象的内容是可变的。



# 13. String 底层使用的什么类型？

- JDK 1.8 之前，底层使用的是 char 类型的数组。

![image-20240323105146132](http://qiniu.fickler.top/img/image-20240323105146132.png)

- JDK 1.9 以后，底层使用的 byte 类型的数组。

![image-20240323105201816](http://qiniu.fickler.top/img/image-20240323105201816.png)

**String 为什么是不可变的？**

1. 保存字符串的数组被 final 修饰且为私有的，且 String 类没有提供修改这个字符串的方法。
2. String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。



# 14. String、StringBuffer、StringBuilder 的区别？

三者的区别主要集中表示在不可变行、线程安全和性能方面。

1. String（不可变、线程安全）
   - String 是不可变的，一旦创建了字符串对象，其值就不能被修改。对字符串的任何修改都会创建一个新的字符串对象。
   - String 是线程安全的，因为它的不可变性使得多个线程可以同时访问同一个字符串对象而不会发生竞争条件。
   - 由于不可变性，对字符串的任何修改操作都会创建一个新的字符串对象，从而影响性能。
2. StringBuffer（可变、线程安全）
   - StringBuffer 是可变的，它允许在同一对象上进行修改操作，而不创建新的对象。
   - StringBuffer 是线程安全的，它的方法是同步的，即使用了synchronized修饰，可以安全的在多个线程中使用。
   - 由于可变性，StringBuffer 适用于在多线程环境中进行字符串操作，但在单线程环境中，相比于 StringBuilder 会有一些额外的性能开销。
3. StringBuilder（可变、非线程安全）
   - StringBuilder 是可变的，类似于 StringBuffer，允许在同一对象上进行修改操作，而不创建新的对象。
   - StringBuilder 是非线程安全的，它的方法没有同步，因此在多线程环境中使用时要注意同步问题。
   - 由于可变性，StringBuilder 适用于在单线程环境中操作字符串，且性能要好于 StringBuffer。

综合来说，String 适用于不经常修改的情况，StringBuffer 和 StringBuilder 更适用于需要频繁修改字符串的情况，且具体选择取决于是否需要线程安全以及性能的考虑。



# 15. String 类的常见方法有哪些？

![image-20240323111116912](http://qiniu.fickler.top/img/image-20240323111116912.png)



# 16. 字符串拼接的时都发生了什么？

1. 使用 `+` 运算符拼接

```java
String str1 = "hello";
String str2 = "world";
String result = str1 + ", " + str2;
```

上面的例子，字符串的拼接过程可以分为以下几步：

- 创建两个字符串常量：`"hello"` 和 `"world"`。它们被存储在字符串常量池中。
- 执行第一次拼接：``str1 + ", "`，这将创建一个新的字符串对象 `"hello, "`，并将其存储在字符串常量池中。
- 执行第二次拼接：`(str1 + ", ") + str2`，这将创建另一个新的字符串对象 `"hello, world"`，并将其存储在字符串常量池中。
- 将结果引用赋给 result。

如果拼接的都是字符串直接量，则在编译时编译器会将其直接优化为一个完整的字符串，和你直接写一个完整的字符串是一样的，所以效率非常高。

如果拼接的字符串中包含变量，则在编译时编译器采用 StringBuilder 对其进行优化，即自动创建 StringBuilder 实例并调用其 append() 方法，将这些字符串拼接在一起，效率也很高。但如果这个拼接操作是在循环中执行的，那么每次循环编译器都会创建一个 StringBuilder 实例，再去拼接字符串，相当于执行了 `new StringBuilder().append(str)`，所以此时效率很低。

2. 使用 `concat()`

```java
String str1 = "hello";
String str2 = "world";
String result = str1.concat(", ").concat(str2);
```

`concat()` 方法在每次调用时都会创建一个新的字符串对象，而不修改原有的字符串对象。

3. 使用 `StringBuilder、StringBuffer`

```java
StringBuilder stringBuilder = new StringBuilder();
stringBuilder.append("hello");
stringBuilder.append(" ");
stringBuilder.append("world");
String result = stringBuilder.toString();
```

StringBuilder 对象可以通过 append() 方法多次追加字符串。这样的操作是在同一个可变对象上进行的，不会产生大量的中间字符串对象。最后，通过 toString() 方法将 StringBuilder 对象转换为不可变的字符串对象。



# 17. new String(“abc”) 和 String a = “abc” 的区别？

- 使用 `new String("abc")` 会在堆内存中创建一个新的字符串对象，即使字符串常量池中已经存在相同的字符串。
- 使用 `String a = "abc"` 会检查字符串常量池中是否存在值为 “abc” 的字符串。如果存在，直接引用该字符串，如果不存在，则在常量池中创建一个新的字符串。

通常推荐使用 `String a = "abc"` 这种方式，它更符合字符串的常用特性，并且避免了额外对象的创建。



# 18. Object 类常见方法有哪些？

![image-20240323171848695](http://qiniu.fickler.top/img/image-20240323171848695.png)



# 19. == 和 equals() 的区别？

1. `==` 操作符比较的是对象的引用，即两个对象是否指向内存中的相同位置。如果两个引用指向相同的对象，则返回 true，否则返回 false，通常用于比较基础数据类型和对象的引用。
2. `equals()` 方法用于比较对象的内容。默认情况下，`equals()` 方法在 object 类中实现的比较对象的引用，但很多类都重写了这个方法，提供了对内容的比较。

```java
String str1 = new String("hello");
String str2 = new String("hello");
System.out.println(str1 == str2);	// false 不同的引用
System.out.println(str1.equals(str2));	// true 重写了 equals 方法，比较内容
```



# 20. Exception 和 Error 有什么区别？

Exception 和 Error 都是派生自 Throwable 类的子类。

1. Exception 类及其子类主要用于表示程序可以处理的异常情况。异常可以分为可检查异常（CheckedException）和不可检查异常（UncheckedException）。程序员可以选择捕获并处理异常，也可以通过在方法签名中使用 throws 关键字声明方法可能抛出的异常。
2. Error 类及其子类通常表示虚拟机无法恢复的严重错误。错误不应该由应用程序捕获并处理，错误通常表示虚拟机或系统本身的问题。



# 21. finally 总是会被执行吗？

一般来说，finally 块都会在 try 或 catch 块执行完毕后被执行，即使发生了异常。然而，有一些情况下 finally 块可能不会执行，主要是在以下情况：

1. 在 try 或 catch 块中调用了 `System.exit()` 会导致 Java 虚拟机（JVM）退出，此时 finally 块中的代码不会执行。

```java
try {
    // 一些代码
    System.exit(0);	// 这会导致 JVM 退出，finally 块不会执行
} finally {
    // 这里的代码不会执行
}
```



2. 在 try 块中发生了死循环：如果在 try 块中发生了无限循环或者其它永远不会结束的操作，finally 块可能无法执行。

```java
try {
    while (true) {
        // 一些代码
    }
} finally {
    // 这里的代码可能无法执行
}
```



# 22. 