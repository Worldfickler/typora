# 学习总结

## day01-Collection

1. HashMap、LinkedHashMap、HashSet、LinkedList、ArrayList 增删改查  
2. 生成一组不重复的随机数（HashSet） 
3. 对一组随机数排序（冒泡排序（ArrayList）、stream 流自带的排序） 
4. 判断一个字符串中的括号是否成对（LinkedList 实现栈进行判断）
5. 统计字符串中每个字符出现的次数（HashMap）（同时按照最先出现的顺序输出LinkedHashMap）



**小问题：**

1. iterator 迭代期间，向集合中插入数据，会发生什么？
2. random 生成一组随机数，优化？
3. 多线程实现统计字符串中每个字符出现的次数？



## day02-Stream、抽象类

### 补day01内容

1. stream 流自带的排序
2. 判断一个字符串中的括号是否成对（LinkedList 实现栈进行判断）
3. 按照最先出现的顺序输出 LinkedHashMap



**小问题：**

1. sorted，默认排序方式？如果指定排序方式？（comparable）
2. 匹配括号是否成对，逻辑错误？

---

### 1. Stream

1. Stream 流创建的三种方式
2. 遍历、匹配（foreach、find、match）
3. 筛选（filter）
4. 聚合（max、min、count）
5. 映射（map、flatMap）：map、flatMap 的区别？
6. 规约（reduce）
7. 收集（collect）
   1. 归集（toList、toSet、toMap）
   2. 统计（count、averaging）
   3. 分组（partitioningBy、groupingBy）：partitioningBy、groupingBy 的区别？
   4. 接合（joining）
   5. 规约（reducing）：与 stream 本身的 reduce 的区别？
8. 排序（sorted）
9. 提取、组合：合并两个流（concat）、去重（distinct）、限制（limit）、跳过（skip）



### 2. 抽象类

1. 韩顺平资料小 demo

2. 抽象类联系内容

   1. 创建基础抽象类 BaseAbstract<T>，提供一个HashMap<String,BaseAbstract<?>>类型的静态属性和T类型的属性供子类使用，同时有两个抽象方法：getKey()，返回值为一个字符串，用于唯一标识子类；getContent() 返回值为T类型。BaseAbstract只有一个公有的有参构造器BaseAbstract()，在构造器中，会调用getKey方法，返回值作为key，将子类对象作为value放入到前面提到的HashMap中

   2. 创建一个类，继承BaseAbstract，实现对应的方法。在BaseAbstract中添加方法，入参为String类型的key，用于获取BaseAbstract中HashMap的对应的value

   3. 最终在main方法中使用（示例）：
      StringBaseAbstract stringBaseAbstract = new StringBaseAbstract();
      BaseAbstract<?> instance = BaseAbstract.getInstance(stringBaseAbstract.getKey());
      System.out.println(instance.getContent());



**小问题：**

1. 泛型 T ？



## day03-接口、lambda 表达式

### 补day02内容

1. 抽象类联系内容



### 1. 接口

1. 接口的基本内容
2. 接口和继承的区别
3. 接口的多态性
   1. 多态参数
   2. 多态数组
   3. 接口存在多态传递现象
4. 接口的实现：设计接口的实现类、使用匿名内部类



### 2. lambda表达式

lambda 四大内置接口

1. Function：接口用来根据一个类型的数据得到另一个类型的数据，这个接口中具有两个泛型（T和R）。前者称为前置条件，后者称为后置条件。
   1. 抽象方法：apply
   2. 默认方法：andThen
   3. 默认方法：compose

2. Consumer：消费一个数据
   1. 抽象方法：accept
   2. 默认方法：andThen
3. Supplier：指定接口的泛型是什么类型，那么接口中的get方法就会生产什么类型的数据

4. Predicate：对某种类型的数据进行判断，从而得到一个boolean值结果。
   1. 抽象方法：test
   2. 默认方法：and、or、negate


**接口/lambda练习**

1. 编写接口Calculate<S,R>，提供方法 calculate(S):R，入参为S类型，返回值为类型R，对入参进行运算，并返回运算结果
2. 编写抽象类CalculateElement<T,R>，实现Calculate接口，含有T类型的属性，提供get和set方法，分别对T类型的属性进行获取和赋值；提供一个customCalculate(Calculate<T,R>):R方法，入参为Calculate接口的实现类，出参为类型R，在方法中调用入参的calculate方法，传入T类型的属性。
3. 编写类IntCalculateElement继承CalculateElement类，实现calculate方法，对入参和基类CalculateElement中的属性进行求和并返回。
4. main方法中，创建IntCalculateElement对象，调用calculate方法和customCalculate方法
main方法中的示例：
IntCalculateElement element = new IntCalculateElement(10);
System.out.println(element.calculate(20));
System.out.println(element.customeCalculate(integer -> integer * 5));



## day04-线程

1. Thread：实际上还是实现了 Runnable 接口
2. Runnable：只有一个 run() 方法
3. Callable：产生结果
   1. Callable 类似于 Runnable，但是 Runnable 不会返回结果，且无法抛出返回错误的异常
   2. Callable 可以解决上述问题，并且 Callable 的返回值可以被 Future 拿到
4. Future：拿到结果（可以拿到异步执行的返回值）
5. ThreadPool：
   1. 创建线程池的两种方法
      1. Executors.xxxThreadPool
      2. new ThreadPoolExecutor
   2. executor() 方法：接收一个 Runnable 实例，并且执行异步操作
   3. submit() 方法：接收一个 Runnable 实例，执行异步操作，并且返回一个 Future 对象，通过返回的 Future 对象，我们可以检查提交的任务是否执行完毕
6. 线程锁
   1. Synchronized
      1. 同步方法
      2. 同步代码块
   2. ReentrantLock
      1. ReentrantLock.lock() 后面必须紧跟在 try 块
      2. ReentrantLock.unlock() 必须放在 finally 中
7. 线程通信
   1. 共享内存
   2. 消息传递



参考资料：https://www.cnblogs.com/eternityz/p/12238767.html


**线程练习：**

1. 使用多线程，计算 1+2+3+...+500000 的和
2. 创建三个线程，对同一个存储结构进行操作，其中一个线程每隔2秒输出存储结构中的内容，其他两个线程向存储结构中加入元素，加入的元素为存储结构中最后一个元素+1，如：存储结构中的元素为[1,2,3,4]，则再加入元素时





知识点
1. Collection（stream toMap、groupBy、parallstream、toList、filter、map、forEach）（泛型T，?）
2. 抽象类（抽象方法、默认方法） （泛型 T extends Xxx , ? extends Xxx）
3. 接口、lambda表达式(Function、Consumer、Predicate、Supplier)
4. Thread、ThreadPool、Future、callable、runnable
5. 反射 (.cast()，isAssignableFrom()，Method,Field,Construction)
参考资料：
https://www.gulixueyuan.com/goods/show/1



