

# 用户中心

完整了解做项目的思路，接触一些企业级的开发技术（尽量少写代码）

目标：学习完后能够轻松的做出管理系统

## 企业做项目流程

需求分析 => 设计（概要设计、详细设计）=> 技术选型 => 初始化项目 / 引入需要的技术 => 写 Demo => 写代码（实现业务逻辑）=> 测试（单元测试）=> 代码提交 / 代码评审 => 部署 => 发布

## 需求分析

1. 登录 / 注册
2. 用户管理（仅管理员可见）对用户的查询或者修改
3. 用户校验（**仅星球用户**）

## 技术选型

前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）

后端：

- Java
- spring（依赖注入框架，帮助你管理 java 对象，集成一些其他内容）
- springmvc（web 框架，提供接口访问，restful 接口等能力）
- mybatis（java 操作数据库的框架，持久层框架，对 jdbc 的封装）
- mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现查询）
- springboot（快速启动 / 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）
- mysql

部署：服务器 / 容器（平台）

## 项目初始化

### 一、前端初始化

#### 1. 下载 node.js

![image-20230309090629528](http://qiniu.user-center.icu/img/image-20230309090629528.png)

最好下载稳定版本，node.js 是一个 JavaScript 的运行环境，它下载的时候会自动安装 npm 包管理，我们这里主要是用 npm 包管理器来拉取项目初始化



#### 2. Ant Design Pro

官网页面：[开箱即用的中台前端/设计解决方案 - Ant Design Pro](https://pro.ant.design/zh-CN/)

![image-20230309091241925](http://qiniu.user-center.icu/img/image-20230309091241925.png)

1. 点击预览可以看到 Ant Design Pro 页面的预览效果

![image-20230309091357240](http://qiniu.user-center.icu/img/image-20230309091357240.png)

2. 在首页点击文档，可以看到 Ant Design Pro 的使用文档

![image-20230309091513313](http://qiniu.user-center.icu/img/image-20230309091513313.png)

#### 3. 初始化 Ant Design Pro

初始化项目，按照文档里面的初始化步骤对项目进行初始化

1. 新建一个文件夹，用来存放代码

![image-20230309091703321](http://qiniu.user-center.icu/img/image-20230309091703321.png)

2. 在地址栏中输入 `cmd` 回车，快速进入命令框

![image-20230309091749981](http://qiniu.user-center.icu/img/image-20230309091749981.png)

3. 输入 `npm i @ant-design/pro-cli -g` 下载相对应的包

出现 `wran` 不代表下载错误，下载速度有点慢，多等待一会~

![image-20230309093031597](http://qiniu.user-center.icu/img/image-20230309093031597.png)

4. 输入 `pro create myapp` 创建项目
   1. 选择 `umi@3` 版本
   2. 选择 `simple` 版本（`simple` 是基础模板）

![image-20230309093309983](http://qiniu.user-center.icu/img/image-20230309093309983.png)

5. 初始化成功后，在刚刚新建的文件夹下会出现一个刚刚初始化的项目文件

![image-20230309093513011](http://qiniu.user-center.icu/img/image-20230309093513011.png)

![image-20230309093553398](http://qiniu.user-center.icu/img/image-20230309093553398.png)



#### 4. 选择开发者工具打开项目

前端的主流开发工具主要就是 webstorm 和 vscod，这里就使用 webstorm 了

![image-20230309093907738](http://qiniu.user-center.icu/img/image-20230309093907738.png)



#### 5. 安装依赖包

官网提供的安装依赖的方式有两种

```
$ cd myapp && tyarn
// 或
$ cd myapp && npm install
```

我没有下载 yarn，因为我也学大数据，在大数据里面有个脚本命令也叫 yarn，同名，系统在识别的时候会冲突，因此这里就使用 `npm install` 来安装依赖包了

在 webstorm 的终端窗口-Terminal 中输入 `npm install` 程序会自动安装项目所需要的全部依赖

>项目是怎么确定需要哪些依赖呢？
>
>在项目中有个文件叫 `package.json`，里面定义了项目所需要的全部依赖以及相对应的版本，在执行 `npm install` 后，程序会自动匹配，并按照 `package.json` 的依赖进行下载
>
>![image-20230309094836383](http://qiniu.user-center.icu/img/image-20230309094836383.png)

下载的时间有点长，多等待一会...

 安装成功

![image-20230312170532141](http://qiniu.user-center.icu/img/image-20230312170532141.png)



#### 6. 启动项目

在`package.json`中找到 start 在左侧点击绿色的运行按钮即可

![image-20230312170749431](http://qiniu.user-center.icu/img/image-20230312170749431.png)

运行成功截图：

![image-20230312170829399](http://qiniu.user-center.icu/img/image-20230312170829399.png)

点击 `localhost:8080`进入页面

![image-20230312170950748](http://qiniu.user-center.icu/img/image-20230312170950748.png)

按照提示，输入用户名和密码

```
用户名：admin
密码：ant.desing
```

进入登录成功的页面

![image-20230312171148553](http://qiniu.user-center.icu/img/image-20230312171148553.png)

>两种启动命令的区别`start`和`start:dev`，`start:dev`比`start`多了一个`MOCK=none`，这是把模拟数据关闭了，因为我们现在还没有后台，所以使用`start:dev`去启动项目登录，会登录失败



#### 7. 安装Umi UI（这个工具可以帮助我们自动生成代码）

1. 停止项目，输入下面的命令，安装 Umi

```
npm add @umijs/preset-ui -D
```

2. 安装成功后，再次启动项目，会发现右下角出现了一个一碗米饭的图标

![image-20230312172614765](http://qiniu.user-center.icu/img/image-20230312172614765.png)

3. 登录进入，页面中有欢迎页面、管理页面、查询表格页面

![image-20230312172727941](http://qiniu.user-center.icu/img/image-20230312172727941.png)

这些页面都是在 `src/pages`页面下

![image-20230312172804361](http://qiniu.user-center.icu/img/image-20230312172804361.png)

4. 点击右下角的米饭图标，添加一个页面

![image-20230312172939627](http://qiniu.user-center.icu/img/image-20230312172939627.png)



5. 修改路由地址和文件地址

![image-20230312173247094](http://qiniu.user-center.icu/img/image-20230312173247094.png)

6. 点击确认后就会开始自动生成页面了

![image-20230312173403609](http://qiniu.user-center.icu/img/image-20230312173403609.png)

网络问题....

没有生成成功....

#### 8. 项目瘦身

我首先减少一些国际化的内容，原因就不用说了...

国际化的代码主要都在 `src/locales`文件夹下

![image-20230312174025904](http://qiniu.user-center.icu/img/image-20230312174025904.png)

1. 在`package.json`中找到`i18n-remove`，项目本身就提供了国际化的移除，并只保留中文

![image-20230312174156091](http://qiniu.user-center.icu/img/image-20230312174156091.png)

2. 点击运行，它会自动帮助我们删除一些国际化的内容

![image-20230312174248211](http://qiniu.user-center.icu/img/image-20230312174248211.png)

#### 9. 项目结构

| 文件夹/文件                                                  | 介绍                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20230312175459652](http://qiniu.user-center.icu/img/image-20230312175459652.png) | 不用管，配置 vscode 的一些插件                               |
| ![image-20230312180536209](http://qiniu.user-center.icu/img/image-20230312180536209.png) | 顾名思义，存储一些配置（比如：本地代理、路由）               |
| ![image-20230312181019008](http://qiniu.user-center.icu/img/image-20230312181019008.png) | 不用管，这个是我们最终部署项目就已经编译好的项目目录         |
| ![image-20230312180546216](http://qiniu.user-center.icu/img/image-20230312180546216.png) | 这个是模拟数据存放的地方，为什么我们没有后台也能登录访问，就是 Ant Design Pro 帮我们指定了一些模拟是假数据 |
| ![image-20230312180753373](http://qiniu.user-center.icu/img/image-20230312180753373.png) | 存放一些静态资源，比如网站的logo图标，视频音频等             |
| ![image-20230312180759361](http://qiniu.user-center.icu/img/image-20230312180759361.png) | 这个就是我们平常写代码时常用的目录                           |
| ![image-20230312180814475](http://qiniu.user-center.icu/img/image-20230312180814475.png) | 存放组件                                                     |
| ![image-20230312180936671](http://qiniu.user-center.icu/img/image-20230312180936671.png) | 测试（可以理解为集成测试，这个可以删掉）                     |
| ![image-20230312180830665](http://qiniu.user-center.icu/img/image-20230312180830665.png) | 存放页面                                                     |
| ![image-20230312180845397](http://qiniu.user-center.icu/img/image-20230312180845397.png) | 国际化组件（这个可以直接删掉，然后重启下项目）               |
| ![image-20230312181141978](http://qiniu.user-center.icu/img/image-20230312181141978.png) | 这个是接口文档工具（不用管，删掉）                           |
| ![image-20230312181201461](http://qiniu.user-center.icu/img/image-20230312181201461.png) | 定义了整个项目用到的一些接口（没用，删掉）                   |
| ![image-20230312181350449](http://qiniu.user-center.icu/img/image-20230312181350449.png) | 项目的入口，整个前端项目的启动都离不开这个文件               |
| ![image-20230312181404540](http://qiniu.user-center.icu/img/image-20230312181404540.png) | 全局样式的代码（和css差不多）                                |
| ![image-20230312181411490](http://qiniu.user-center.icu/img/image-20230312181411490.png) | 全局的脚本文件                                               |
| ![image-20230312181420212](http://qiniu.user-center.icu/img/image-20230312181420212.png) | 前端一些页面的缓存                                           |
| ![image-20230312181426300](http://qiniu.user-center.icu/img/image-20230312181426300.png) | 定义了一些ts的类型（类似c、c++的宏定义）                     |
| ![image-20230312181451824](http://qiniu.user-center.icu/img/image-20230312181451824.png) | 测试（一般情况下，前端不太会用到测试，删掉）                 |
| ![image-20230312181516313](http://qiniu.user-center.icu/img/image-20230312181516313.png) | 编辑器的配置（比如说你这个代码要求空几格，然后编辑器看到会自动的帮你格式化） |
| ![image-20230312181552425](http://qiniu.user-center.icu/img/image-20230312181552425.png) | 美化前端代码的工具                                           |
| ![image-20230312181544302](http://qiniu.user-center.icu/img/image-20230312181544302.png) | 检查js语法                                                   |
| ![image-20230312181726783](http://qiniu.user-center.icu/img/image-20230312181726783.png) | 这个也是测试工具（删掉）                                     |
| <img src="http://qiniu.user-center.icu/img/image-20230312181744599.png" alt="image-20230312181744599" style="zoom:80%;" /> | 检验css语法                                                  |
| ![image-20230312181755299](http://qiniu.user-center.icu/img/image-20230312181755299.png) | 自动化测试工具，帮你在火狐或谷歌自动测试，不用真实的打开浏览器就能测试（用不到，删掉） |

**注意**

删除某个文件的时候，要注意是否在其他地方用到了这个文件，途观用到了也要删除相关的代码



**启动成功！前端的初始化完成！！！**

![image-20230312182324610](http://qiniu.user-center.icu/img/image-20230312182324610.png)

![image-20230312182340266](http://qiniu.user-center.icu/img/image-20230312182340266.png)



### 二、后端初始化

#### 1. 先安装数据库（mysql）

MySQL 的数据库一般用 5.7 版本或者 8.0 版本，因为我两个版本的数据库都下载了，用哪个都可以，但是还是最好选用 5.7 版本的！！！（别问为什么，已经踩过坑了....）



#### 2. 初始化后端项目

1. 第一种方式

去 github 上搜 springboot 模板，使用现成的模板

![image-20230312182953857](http://qiniu.user-center.icu/img/image-20230312182953857.png)

2. 第二种方式

springboot 官方的模板生成器 [Spring Initializr](https://start.spring.io/)

![image-20230312183130599](http://qiniu.user-center.icu/img/image-20230312183130599.png)

3. 直接在 IDEA 开发者工具中生成

![image-20230312184054089](http://qiniu.user-center.icu/img/image-20230312184054089.png)



#### 3. idea连接本地数据库

1. 点击 database

![image-20230312184748762](http://qiniu.user-center.icu/img/image-20230312184748762.png)

2. 添加 mysql

![image-20230312184812192](http://qiniu.user-center.icu/img/image-20230312184812192-16786180995541.png)

3. 测试是否链接成功

![image-20230312184927077](http://qiniu.user-center.icu/img/image-20230312184927077.png)

4. 连接成功后，右边出现已经连接上的数据库

![image-20230312185033338](http://qiniu.user-center.icu/img/image-20230312185033338.png)



#### 4. 引入mybatis-plus

根据官方文档[MyBatis-Plus (baomidou.com)](https://baomidou.com/)，写一个 demo

![image-20230312190451674](http://qiniu.user-center.icu/img/image-20230312190451674.png)



1. 先创建一个数据库

![image-20230312190757237](http://qiniu.user-center.icu/img/image-20230312190757237.png)

2. 在数据库中创建一个表，就按照mybatis-plus的官方案例创建吧

```mysql
DROP TABLE IF EXISTS user;

CREATE TABLE user
(
    id BIGINT(20) NOT NULL COMMENT '主键ID',
    name VARCHAR(30) NULL DEFAULT NULL COMMENT '姓名',
    age INT(11) NULL DEFAULT NULL COMMENT '年龄',
    email VARCHAR(50) NULL DEFAULT NULL COMMENT '邮箱',
    PRIMARY KEY (id)
);
```

3. 插入数据

```mysql
INSERT INTO user (id, name, age, email) VALUES
(1, 'Jone', 18, 'test1@baomidou.com'),
(2, 'Jack', 20, 'test2@baomidou.com'),
(3, 'Tom', 28, 'test3@baomidou.com'),
(4, 'Sandy', 21, 'test4@baomidou.com'),
(5, 'Billie', 24, 'test5@baomidou.com');
```

4. 打开user表，看一下是否成功创建并成功插入数据

![image-20230312191309462](http://qiniu.user-center.icu/img/image-20230312191309462.png)



#### 5. 引入依赖

```xml
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.5.1</version>
        </dependency>
```



#### 6. 添加配置

1. 将 `properties` 修改为 `yml` 格式文件

![image-20230312191820995](http://qiniu.user-center.icu/img/image-20230312191820995.png)

> yml 格式的配置文件支持嵌套

2. 在 `application.yml` 文件中写入项目名和端口号

```yaml
spring:
  application:
    name: user-center-backend-master
server:
  port: 8080
```



![image-20230312192106418](http://qiniu.user-center.icu/img/image-20230312192106418.png)

3. 添加数据库配置

```yaml
spring:
  application:
    name: user-center-backend-master
  # DataSource Config
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/userdatabase
    username: 用户名
    password: 密码
server:
  port: 8080
```



#### 7. 在 Spring Boot 启动类中添加 `@MapperScan` 注解，扫描 Mapper 文件夹

1. 我们现在还没有 Mapper 文件夹，所以先新建一个 Mapper 文件夹

![image-20230312192739117](http://qiniu.user-center.icu/img/image-20230312192739117.png)

2. 添加 `@MapperScan` 注解

```java
@MapperScan("com.example.usercenterbackendmaster.Mapper")
```



```java
@SpringBootApplication
@MapperScan("com.example.usercenterbackendmaster.Mapper")
public class UserCenterBackendMasterApplication {

    public static void main(String[] args) {
        SpringApplication.run(UserCenterBackendMasterApplication.class, args);
    }

}
```



#### 8. 编码

1. 新建一个 `User` 实体类

```java
@Data
public class User {
    private Long id;
    private String name;
    private Integer age;
    private String email;
}
```

2. 新建一个 `UserMapper` 接口

```java
public interface UserMapper extends BaseMapper<User> {

}
```

#### 9. 开始使用

添加测试类，进行功能测试

```java
@SpringBootTest
public class SampleTest {

    @Resource
    private UserMapper userMapper;

    @Test
    public void testSelect() {
        System.out.println(("----- selectAll method test ------"));
        List<User> userList = userMapper.selectList(null);
        Assert.assertEquals(5, userList.size());
        userList.forEach(System.out::println);
    }

}
```

![image-20230312214907796](http://qiniu.user-center.icu/img/image-20230312214907796.png)



## 数据库设计

### 一、表设计

| 字段         | 说明                     | 类型            |
| ------------ | ------------------------ | --------------- |
| id           | 用户id（主键）           | bigint          |
| username     | 昵称                     | varchar         |
| userAccount  | 登录账号                 | varchar         |
| avatarUrl    | 头像                     | varchar         |
| gender       | 性别                     | tinyint         |
| userPassword | 密码                     | varchar         |
| phone        | 电话                     | varchar         |
| email        | 邮箱                     | varchar         |
| userStatus   | 用户状态                 | int（0 - 正常） |
| createTime   | 创建时间（数据插入时间） | datetime        |
| updateTime   | 更新时间（数据更新时间） | datetime        |
| isDelete     | 是否删除0 1（逻辑删除）  | tinyint         |



### 二、建表

1. 删除之前的表

![image-20230312220535856](http://qiniu.user-center.icu/img/image-20230312220535856.png)

2. 使用idea自带的工具建表

![image-20230313140813284](http://qiniu.user-center.icu/img/image-20230313140813284.png)

```mysql
-- auto-generated definition
create table user
(
    id           bigint auto_increment comment '用户id（主键）'
        primary key,
    username     varchar(256)                       null comment '用户昵称',
    userAccount  varchar(256)                       null comment '账号',
    avatarUrl    varchar(1024)                      null comment '用户头像',
    gender       tinyint                            null comment '性别',
    userPassword varchar(512)                       not null comment '密码',
    email        varchar(512)                       null comment '邮箱',
    userStatus   int      default 0                 null comment '状态 0-正常',
    phone        varchar(128)                       null comment '电话',
    creatTime    datetime default CURRENT_TIMESTAMP null comment '创建时间',
    updateTime   datetime default CURRENT_TIMESTAMP null on update CURRENT_TIMESTAMP comment '更新时间',
    isDelete     tinyint  default 0                 not null comment '是否删除'
)
    comment '用户';
```





## 后端开发

### 一、规整项目目录

#### 1. 新建补充目录

1. controller

![image-20230313141822351](http://qiniu.user-center.icu/img/image-20230313141822351.png)

2. service

![image-20230313141902553](http://qiniu.user-center.icu/img/image-20230313141902553.png)

3. utils

![image-20230313141919706](http://qiniu.user-center.icu/img/image-20230313141919706.png)

#### 2. 目录文件说明

| 目录/文件                                                    | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20230313142657039](http://qiniu.user-center.icu/img/image-20230313142657039.png) | 就是请求层或者控制层。这个目录里的所有文件都是专门用来接收请求，不做任何业务处理，只去接收请求。 |
| ![image-20230313142712960](http://qiniu.user-center.icu/img/image-20230313142712960.png) | 专门用来编写业务逻辑。                                       |
| ![image-20230313142722811](http://qiniu.user-center.icu/img/image-20230313142722811.png) | 一个数据访问层，就是这一层的文件，就是专门用于层数据库中去查询数据，去取数据、增删改查之类的。 |
| ![image-20230313142746497](http://qiniu.user-center.icu/img/image-20230313142746497.png) | 定义了数据库的一些和数据库相对应的模型，或者用到的一些封装类。 |
| ![image-20230313142757684](http://qiniu.user-center.icu/img/image-20230313142757684.png) | 存放一些东西，比如说加密、格式转换、日期转换等等。（就是和我们业务关系不大，为了节省我们的操作） |
| ![image-20230313142832386](http://qiniu.user-center.icu/img/image-20230313142832386.png) | 一般写前后端不分离的项目，在static放一些静态文件（没用删掉） |
| ![image-20230313142845973](http://qiniu.user-center.icu/img/image-20230313142845973.png) | 一般写前后端不分离的项目，放页面模板文件（没用删掉）         |

**项目目录截图**

![image-20230313143326263](http://qiniu.user-center.icu/img/image-20230313143326263.png)



### 二、实现基本数据库操作

#### 1. 自动生成器的使用

> MyBatisX 插件，自动根据数据库生成 domain （实体对象）、mapper（操作数据库的对象）、mapper.xml（定义了 mapper 对象和数据库的关联，可以在里面自己写 SQL）、service（包含常用的增删改查）、serviceImpl（具体实现 service）
>
> ![image-20230313144034928](http://qiniu.user-center.icu/img/image-20230313144034928.png)

1. 安装成功后，右键 user 表，会发现多了一个 MyBatisX-Generator（代码生成器）

![image-20230313144143247](http://qiniu.user-center.icu/img/image-20230313144143247.png)

2. 点击下一步

![image-20230313145003199](http://qiniu.user-center.icu/img/image-20230313145003199.png)

3. 选择适合自己的模板，点击完成

![image-20230313145053391](http://qiniu.user-center.icu/img/image-20230313145053391.png)

4. 点击完成后，会在左侧生成相对应的代码

![image-20230313145142589](http://qiniu.user-center.icu/img/image-20230313145142589.png)

5. 将生成的代码，搬运到我们之前建好的文件夹下

![image-20230313145355558](http://qiniu.user-center.icu/img/image-20230313145355558.png)

6. 除了`generator`文件夹外，还会在`resources`下生成一个`UserMapper.xml`文件，这是mybatis-plus要用到的一个配置文件，会和mapper文件夹关联上

![image-20230313145702022](http://qiniu.user-center.icu/img/image-20230313145702022.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.usercenterbackendmaster.mapper.UserMapper">

    <resultMap id="BaseResultMap" type="com.example.usercenterbackendmaster.model.domain.User">
            <id property="id" column="id" jdbcType="BIGINT"/>
            <result property="username" column="username" jdbcType="VARCHAR"/>
            <result property="userAccount" column="userAccount" jdbcType="VARCHAR"/>
            <result property="avatarUrl" column="avatarUrl" jdbcType="VARCHAR"/>
            <result property="gender" column="gender" jdbcType="TINYINT"/>
            <result property="userPassword" column="userPassword" jdbcType="VARCHAR"/>
            <result property="email" column="email" jdbcType="VARCHAR"/>
            <result property="userStatus" column="userStatus" jdbcType="INTEGER"/>
            <result property="phone" column="phone" jdbcType="VARCHAR"/>
            <result property="creatTime" column="creatTime" jdbcType="TIMESTAMP"/>
            <result property="updateTime" column="updateTime" jdbcType="TIMESTAMP"/>
            <result property="isDelete" column="isDelete" jdbcType="TINYINT"/>
    </resultMap>

    <sql id="Base_Column_List">
        id,username,userAccount,
        avatarUrl,gender,userPassword,
        email,userStatus,phone,
        creatTime,updateTime,isDelete
    </sql>
</mapper>

```



#### 2. 测试一下

1. 先给UserService创建一个测试类，把鼠标放在UserServie上，按下alter+enter

![image-20230313151641736](http://qiniu.user-center.icu/img/image-20230313151641736.png)

选择 create test 创建一个测试类

2. 直接生成即可

![image-20230313151653730](http://qiniu.user-center.icu/img/image-20230313151653730.png)

3. 我在生成的测试类中编写测试代码即可

![image-20230313151629972](http://qiniu.user-center.icu/img/image-20230313151629972.png)

**推荐一个插件**

> ![image-20230313150418595](http://qiniu.user-center.icu/img/image-20230313150418595.png)
>
> 这个插件可以一键帮你生成对象的所有 set 方法、生成一个充满假数据的类，充满假数据的对象等等

放到实体类上，按下 alter + enter

![image-20230313150704958](http://qiniu.user-center.icu/img/image-20230313150704958.png)

自己生成了，我们只需要在此基础上修改就可以了，方便了很多！

![image-20230313150743621](http://qiniu.user-center.icu/img/image-20230313150743621.png)

4. 测试代码编写完成

![image-20230313151221077](http://qiniu.user-center.icu/img/image-20230313151221077.png)

```java
package com.example.usercenterbackendmaster.service;

import com.example.usercenterbackendmaster.model.domain.User;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

import javax.annotation.Resource;

import static org.junit.jupiter.api.Assertions.*;

/**
 * @author dell
 * @date 2023/3/13 15:14
 */

@SpringBootTest
class UserServiceTest {

    @Resource
    private UserService userService;

    @Test
    public void testAddUser() {

        User user = new User();
        user.setUsername("test");
        user.setUserAccount("123");
        user.setAvatarUrl("http://qzapp.qlogo.cn/qzapp/101983660/DE2DFA542010DAD2696FC2082D1EE3E7/100");
        user.setGender(0);
        user.setUserPassword("xxx");
        user.setEmail("123");
        user.setPhone("456");

        boolean result = userService.save(user);
        System.out.println(user.getId());
        Assertions.assertTrue(result);
    }

}
```

5. 运行代码

![image-20230314080127932](http://qiniu.user-center.icu/img/image-20230314080127932.png)

报错了，mybatis-plus 默认会将驼峰转换成下划线，所以就出现了在 “字段列表” 中出现未知列 “user_account”，在 application.yml 关闭默认转换

![img](http://qiniu.user-center.icu/img/6f537998930e4b0594de55262d0305f7.png)

**在`application.yml`中添加以下内容**

```yaml
mybatis-plus:
  configuration:
    map-underscore-to-camel-case: false
```

再次运行

![image-20230314080515065](http://qiniu.user-center.icu/img/image-20230314080515065.png)

运行成功，查看一下数据库表中的数据

![image-20230314080545537](http://qiniu.user-center.icu/img/image-20230314080545537.png)



#### 3. 注册逻辑

1. 用户在前端输入账户、密码以及校验码（todo）
2. 后端校验用户的账户、密码、校验码，是否符合要求
   1. 非空
   2. 账户长度不小于4位
   3. 密码长度不小于8位
   4. 账户不能重复
   5. 账户不能包含特殊字符
   6. 密码与校验密码相同
3. 对密码进行加密（密码千万不要直接以明文的方式存储到数据库）
4. 向数据库插入用户数据

#### 4. 编写注册代码

1. 在 UserService 中写一个用户注册的接口

![image-20230314081622340](http://qiniu.user-center.icu/img/image-20230314081622340-1678753000894-1.png)

用户注册需要接收哪些参数：账户、密码、验证密码

```java
long userRegister(String userAccount, String userPassword, String checkPassword);
```

写完后，可以加一下注释

> 在方法上面先输入 '/**' 然后敲一下回车就可以了，这样生成的注释是 java doc 注释

![image-20230314081908498](http://qiniu.user-center.icu/img/image-20230314081908498.png)

```java
package com.example.usercenterbackendmaster.service;

import com.example.usercenterbackendmaster.model.domain.User;
import com.baomidou.mybatisplus.extension.service.IService;

/**
* @author dell
* @description 针对表【user(用户)】的数据库操作Service
* @createDate 2023-03-13 14:51:00
*/
public interface UserService extends IService<User> {

    /**
     * 用户注册
     * @param userAccount 用户账户
     * @param userPassword 用户密码
     * @param checkPassword 验证密码
     * @return 用户id
     */
    long userRegister(String userAccount, String userPassword, String checkPassword);

}

```

2. 实现刚刚写的接口函数

> 鼠标移动到函数名上，按下 alter + enter，然后选择实现方法即可

![image-20230314082146519](http://qiniu.user-center.icu/img/image-20230314082146519.png)

这样 idea 就自动帮助我们实现了刚刚的接口函数，我们只需要在里面添加具体的逻辑代码就可以了

```java
package com.example.usercenterbackendmaster.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.example.usercenterbackendmaster.model.domain.User;
import com.example.usercenterbackendmaster.service.UserService;
import com.example.usercenterbackendmaster.mapper.UserMapper;
import org.springframework.stereotype.Service;

/**
* @author dell
* @description 针对表【user(用户)】的数据库操作Service实现
* @createDate 2023-03-13 14:51:00
*/
@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User>
    implements UserService{

    @Override
    public long userRegister(String userAccount, String userPassword, String checkPassword) {
        return 0;
    }
}

```

3. 先添加一个很好用的库，在 maven 仓库中搜索 `apache commons lang `

![image-20230314084926987](http://qiniu.user-center.icu/img/image-20230314084926987.png)

选择一个用的比较多的版本，添加到 pom.xml 中

```xml
<!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 -->
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
    <version>3.12.0</version>
</dependency>
```

4. 编写 `userRegister` 的代码

```java
package com.example.usercenterbackendmaster.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.example.usercenterbackendmaster.model.domain.User;
import com.example.usercenterbackendmaster.service.UserService;
import com.example.usercenterbackendmaster.mapper.UserMapper;
import org.apache.commons.lang3.StringUtils;
import org.springframework.stereotype.Service;
import org.springframework.util.DigestUtils;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
* @author dell
* @description 针对表【user(用户)】的数据库操作Service实现
* @createDate 2023-03-13 14:51:00
*/
@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User>
    implements UserService{

    @Override
    public long userRegister(String userAccount, String userPassword, String checkPassword) {
        // 1.校验
        if (StringUtils.isAnyBlank(userAccount, userPassword, checkPassword)) {
            return -1;
        }
        if (userAccount.length() < 4) {
            return -1;
        }
        if (userPassword.length() < 8 || checkPassword.length() < 8) {
            return -1;
        }
        // 账户不能包含特殊字符
        String validPattern  = "[`~!@#$%^&*()+=|{}':;',\\\\[\\\\].<>/?~！@#￥%……&*（）——+|{}【】‘；：”“’。，、？]";
        Matcher matcher = Pattern.compile(validPattern).matcher(userAccount);
        if (matcher.find()) {
            return -1;
        }
        // 密码与校验密码相同
        if (!userPassword.equals(checkPassword)) {
            return -1;
        }
        // 账户不能重复
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        queryWrapper.eq("userAccount", userAccount);
        long count = this.count(queryWrapper);
        if (count > 0) {
            return -1;
        }
        // 2.加密
        final String STAL = "fickle";
        String encryptPassword = DigestUtils.md5DigestAsHex((STAL + userPassword).getBytes());
        // 3.插入数据
        User user = new User();
        user.setUserAccount(userAccount);
        user.setUserPassword(encryptPassword);
        boolean saveResult = this.save(user);
        if (!saveResult) {
            return -1;
        }
        return user.getId();
    }
}
```

> 这里的加密是使用的 MD5 + 盐值加密

5. 测试一下

```java
    @Test
    void userRegister() {
        // 密码为空
        String userAccount = "fickle";
        String userPassword = "";
        String checkPassword = "12345678";
        long result = userService.userRegister(userAccount, userPassword, checkPassword);
        Assertions.assertEquals(-1, result);
        // 正确插入
        userPassword = "12345678";
        result = userService.userRegister(userAccount, userPassword, checkPassword);
        Assertions.assertTrue(result > 0);
        // 特殊字符
        userAccount = "fickle**sss";
        result = userService.userRegister(userAccount, userPassword, checkPassword);
        Assertions.assertEquals(-1, result);
        // 账户重复
        userAccount = "fickle";
        result = userService.userRegister(userAccount, userPassword, checkPassword);
        Assertions.assertEquals(-1, result);
    }
```

## 后端登录

### 一、登录接口

接受参数：用户账号、密码（**请求参数很长时不建议用 get**）

请求类型：POST

请求体：JSON 格式的数据

返回值：用户信息（**脱敏**）

### 二、登录逻辑

1. 校验用户的账户、密码是否合法
   1. 非空
   2. 账户长度不小于4位
   3. 密码长度不小于8位
   4. 账户不能包含特殊字符
2. 校验密码是否输入正确，要和数据库中的密文密码去对比
3. 用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露
4. 我们要记录用户的登录态，将其存到服务器上（用后端 springboot 框架封装的 tomcat 去记录 cookie）
5. 返回脱敏后的信息

### 三、如何知道是哪个用户登录了？

1. 连接服务器后，得到一个 session 状态（匿名会话），返回给前端

2. 登录成功后，得到了登录成功的 session，并且给 session 设置一些值（比如用户信息），返回给前端一个设置 cookie 的 “命令”

   **session => cookie**

3. 前端接收到后端的命令后，设置 cookie，保存到浏览器中

4. 前端再次请求后端的时候（相同的域名），在请求头中带上 cookie 去请求

5. 后端拿到前端传过来的 cookie，找到对应的 session

6. 后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）

### 四、简单说明cookie和session

> 首先，cookie 是一种缓存机制，session 是会话机制

**以最常见的登录案例讲解 cookie 的使用过程：**

1. 首先用户在客户端浏览器向服务器首次发起登录请求
2. 登录成功后，服务器会把登录的用户信息设置在 cookie 中，并将 cookie 返回给客户端浏览器
3. 客户端浏览器接收到 cookie 请求后，会把 cookie 保存到本地（可能是内存，也可能是磁盘，看具体使用情况而定）
4. 以后再次访问该 web 应用时，客户端浏览器就会将本地的 cookie 带上，这样服务器就能根据 cookie 获的用户信息了

**同样以登录案例为例子讲解 session 的使用过程：**

1. 首先用户在客户端浏览器发起登录请求
2. 登录成功后，服务器端会把用户信息保存在服务器，并返回一个唯一的 session 标识给客户端浏览器
3. 客户端浏览器会把这个唯一的 session 标识保存起来
4. 以后再次访问 web 应用时，客户端浏览器会把这个唯一的 session 标识带上，这样服务器端就能根据这个唯一的标识找到用户信息

**看到这里可能会引起疑问：把唯一的 session 标识返回给客户端浏览器，保存起来，以后访问时带上，这不就是 cookie 吗？**

> 没错，session 只是一种会话机制，在许多 web 应用中，session 就是通过 cookie 来实现的。也就是说它只是使用了 cookie 的功能，并不是使用 cookie 完成会话保存。与 cookie 在保存客户端保存会话的机制相反，session 通过 cookie 的功能，将会话信息保存到了服务器端。

**session 和 cookie 有什么区别呢？**

> 1. cookie 是浏览器提供的一种缓存机制，它可以用于维持客户端与服务端之间的会话。
> 2. session 是维持客户端与服务端会话的一种机制，它可以通过 cookie 实现，也可以通过别的手段实现。
> 3. 如果通过 cookie 实现会话，那么会话就会保存到客户端浏览器中。
> 4. 而 session 机制提供的会话是保存在服务端的。

**举个小栗子说明 cookie 和 seesion 之间的区别和联系**

假如一个咖啡店有喝五杯赠一杯咖啡的优惠，但是一-次性消费5杯咖啡的客人很少，这时就需要某种方式来记录某位顾客的消费数量。无外乎下面的几种方案:

1. 该店的店员很厉害，能记住每位顾客的消费数量，只要顾客一走进咖啡店， 店员就知道该怎么对待了。这种做法就是协议本身支持状态。但是http协议本身是无状态的。
2. 发给顾客一-张卡片，上面记录着消费的数量，一般还有个有效期限。每次消费时，如果顾客出示这张卡片，则此次消费就会与以前或以后的消费相联系起来。这种做法就是在客户端保持状态，也就是cookie,顾客就相当于浏览器。
3. 发给顾客一 张会员卡，除了卡号之外什么信息也不纪录，每次消费时，如果顾客出示该卡片，则店员在店里的记录本上找到这个卡号对应的记录添加一-些消费信息。这种做法就是在服务器端保持状态。

### 五、编写登录逻辑代码

#### 1. 给用户登录定义方法

1. 在 `UserService` 中编写 `doLogin` 接口

```java
    /**
     * 用户登录
     * @param userAccount 用户账号
     * @param userPassword 用户密码
     * @param request 用户登录状态
     * @return
     */
    User doLogin(String userAccount, String userPassword, HttpServletRequest request);
```

2. 实现接口：alter + enter

![image-20230316081538823](http://qiniu.user-center.icu/img/image-20230316081538823.png)

```java
    @Override
    public User doLogin(String userAccount, String userPassword, HttpServletRequest request) {
        return null;
    }
```

#### 2. 写逻辑

1. 编写具体的登录逻辑

由于登录逻辑中也需要用到校验和加密，因此直接将注册中的校验和加密复制到登录中，将`checkPassword`删掉，并将返回值修改为`null`即可

```java
    @Override
    public User doLogin(String userAccount, String userPassword, HttpServletRequest request) {
        // 1.校验
        if (StringUtils.isAnyBlank(userAccount, userPassword)) {
            return null;
        }
        if (userAccount.length() < 4) {
            return null;
        }
        if (userPassword.length() < 8) {
            return null;
        }
        // 账户不能包含特殊字符
        String validPattern  = "[`~!@#$%^&*()+=|{}':;',\\\\[\\\\].<>/?~！@#￥%……&*（）——+|{}【】‘；：”“’。，、？]";
        Matcher matcher = Pattern.compile(validPattern).matcher(userAccount);
        if (matcher.find()) {
            return null;
        }
        // 2.加密
        final String STAL = "fickle";
        String encryptPassword = DigestUtils.md5DigestAsHex((STAL + userPassword).getBytes());
        return null;
    }
```

可以发现在登录和注册中的加密都有用到 `final String STAL = "fickle";`，我将其提取出来，设置为公共的值

```java
    /**
     * 盐值，用于混淆密码
     */
    private static final String STAL = "fickle";
```

2. 使用`slf4j`记录日志

打上`@slf4j`可以使用log来打印日志信息

![image-20230316082552216](http://qiniu.user-center.icu/img/image-20230316082552216.png)

3. 添加查询用户是否存在的逻辑，并用记录登录失败的日志

```java
        // 查询用户是否存在
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        queryWrapper.eq("userAccount", userAccount);
        queryWrapper.eq("userPassword", userPassword);
        User user = userMapper.selectOne(queryWrapper);
        if (user == null) {
            log.info("user login failed, userAccount Cannot match userPassword");
            return null;
        }
```

4. 设置用户登录状态

**怎么记录用户登录状态呢？**

> 我们前面`doLogin`方法中除了传递用户账户、密码外，还传递了一个`HttpServletRequest`，我们便用`HttpServletRequest`来记录用户的登录状态

我们使用`request`，用`getSession()`拿到session，用`setAttribute()`往session中设置一些值。

```java
request.getSession().setAttribute();
```

`setAttribute()`它是一个map，可以用来存储键值对，因此我们需要设置一个键值对，给用户的登录状态分配一个键

```java
    /**
     * 用户登录状态键
     */
    private static final String USER_LOGIN_STATE = "userLoginState";
```

往`setAttribute()`中传入这个键，塞入user值

```java
        // 4.记录用户登录状态
        request.getSession().setAttribute(USER_LOGIN_STATE, user);
```

#### 3. 用户脱敏

1. 先new一个user，对象

```java
		User safetyUser = new User();
```

2. alter + enter，快速生成set方法

```java
        // 4.用户脱敏
        User safetyUser = new User();
        safetyUser.setId();
        safetyUser.setUsername();
        safetyUser.setUserAccount();
        safetyUser.setAvatarUrl();
        safetyUser.setGender();
        safetyUser.setUserPassword();
        safetyUser.setEmail();
        safetyUser.setUserStatus();
        safetyUser.setPhone();
        safetyUser.setCreatTime();
        safetyUser.setUpdateTime();
        safetyUser.setIsDelete();
```

3. 设置需要返回的值

```java
        // 4.用户脱敏
        User safetyUser = new User();
        safetyUser.setId(user.getId());
        safetyUser.setUsername(user.getUsername());
        safetyUser.setUserAccount(user.getUserAccount());
        safetyUser.setAvatarUrl(user.getAvatarUrl());
        safetyUser.setGender(user.getGender());
        safetyUser.setEmail(user.getEmail());
        safetyUser.setUserStatus(user.getUserStatus());
        safetyUser.setPhone(user.getPhone());
        safetyUser.setCreatTime(user.getCreatTime());
```

#### 4. 思考代码有什么问题

原代码

```java
    @Override
    public User doLogin(String userAccount, String userPassword, HttpServletRequest request) {
        // 1.校验
        if (StringUtils.isAnyBlank(userAccount, userPassword)) {
            // todo 修改Wie自定义异常
            return null;
        }
        if (userAccount.length() < 4) {
            return null;
        }
        if (userPassword.length() < 8) {
            return null;
        }
        // 账户不能包含特殊字符
        String validPattern  = "[`~!@#$%^&*()+=|{}':;',\\\\[\\\\].<>/?~！@#￥%……&*（）——+|{}【】‘；：”“’。，、？]";
        Matcher matcher = Pattern.compile(validPattern).matcher(userAccount);
        if (matcher.find()) {
            return null;
        }
        // 2.加密
        String encryptPassword = DigestUtils.md5DigestAsHex((STAL + userPassword).getBytes());
        // 查询用户是否存在
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        queryWrapper.eq("userAccount", userAccount);
        queryWrapper.eq("userPassword", userPassword);
        User user = userMapper.selectOne(queryWrapper);
        if (user == null) {
            log.info("user login failed, userAccount Cannot match userPassword");
            return null;
        }
        // 3.用户脱敏
        User safetyUser = new User();
        safetyUser.setId(user.getId());
        safetyUser.setUsername(user.getUsername());
        safetyUser.setUserAccount(user.getUserAccount());
        safetyUser.setAvatarUrl(user.getAvatarUrl());
        safetyUser.setGender(user.getGender());
        safetyUser.setEmail(user.getEmail());
        safetyUser.setUserStatus(user.getUserStatus());
        safetyUser.setPhone(user.getPhone());
        safetyUser.setCreatTime(user.getCreatTime());
        // 4.记录用户登录状态
        request.getSession().setAttribute(USER_LOGIN_STATE, user);
        return safetyUser;
    }
```

这段代码是存在一定的问题的，如果说这个用户已经被逻辑删除了，那么这这个用户还能被查询出来吗？这个是不一定的，要看一下 mybatis-plus 框架了

mybatis-plus 框架它有一个逻辑删除，默认帮助我们查询出来未删除的用户，可以去官方文档查一下：[逻辑删除 | MyBatis-Plus (baomidou.com)](https://baomidou.com/pages/6b03c5/#使用方法)

![image-20230316085816554](http://qiniu.user-center.icu/img/image-20230316085816554.png)

![image-20230316090034149](http://qiniu.user-center.icu/img/image-20230316090034149.png)

1. 添加一下配置

![image-20230316090145081](http://qiniu.user-center.icu/img/image-20230316090145081.png)

2. 在实体类字段上添加`@TableLogic`注解

![image-20230316090301945](http://qiniu.user-center.icu/img/image-20230316090301945.png)

#### 5. 控制层controller封装请求

开始写Controller，要把接口封装成请求

> controller 层倾向于多请求参数本身的校验，不涉及业务逻辑本身（越少越好）
>
> service 层是对业务逻辑的校验（有可能被controller之外的类调用）
>
> @RestController 适用于编写 restful 风格的 api，返回值默认为 json 类型

1. 在controller包下创建一个UserController类

打上`@RestController`注解，咱们这个类里面所有请求的接口返回值，响应的数据类型都是`application json`

![image-20230316090846903](http://qiniu.user-center.icu/img/image-20230316090846903.png)

2. 再添加一个注解`@RequestMapping`，定义请求路径，这里的请求路径就写个`user`好了

![image-20230316091752131](http://qiniu.user-center.icu/img/image-20230316091752131.png)

3. 下载个插件`auto filling java call arguments`，自动填充java参数

![image-20230316092116444](http://qiniu.user-center.icu/img/image-20230316092116444.png)



在UserController类里面写两个请求，一个是用户注册，一个用户登录

##### 5.1 用户注册

1. 编写用户注册的接口

```java
    @PostMapping("/register")
    public long userRegister() {
    }
```

2. 自动填充参数

光标放置在括号里面，按下 alter + enter，选择 auto fill call parameters

![image-20230316093911244](http://qiniu.user-center.icu/img/image-20230316093911244.png)

参数就自动传递过来了

![image-20230316093954362](http://qiniu.user-center.icu/img/image-20230316093954362.png)

3. 我们封装一个对象，专门用来接收请求参数，在domain包下新建一个request包

![image-20230316094809801](http://qiniu.user-center.icu/img/image-20230316094809801.png)

如果说要是 json 格式的参数的话，我们最好封装一个对象来记录所有的请求参数，然后我们在 request 包小新增一个对象叫 UserRegisterRequest 实体类，并继承 Serializable

![image-20230317080824387](http://qiniu.user-center.icu/img/image-20230317080824387.png)

实现序列化接口，右键选择 generate -> serialVersionUID，生成序列化 ID，但是右键点击 generate 时没有出现 serialVersionUID

> file -> settings -> editor ->inspections
>
> ![image-20230317083347639](http://qiniu.user-center.icu/img/image-20230317083347639.png)
>
> 光标放置在类名上，alter + enter，选择第一个
>
> ![image-20230317083453048](http://qiniu.user-center.icu/img/image-20230317083453048.png)

4. 编写 UserRegisterRequest 类

```java
@Data
public class UserRegisterRequest implements Serializable {
    private static final long serialVersionUID = 6010448209356722607L;

    private String userAccount;
    private String userPassword;
    private String checkPassword;

}
```

5. 回到 userRegister 接口，使用 UserRegisterRequest 接收前端传过来的参数

打上一个注解 `@RequestBody`，没有这个注解，SpringMVC 框架不知道如何将前端传过来的 json 参数去找一个合适的对象相关联

![image-20230317084112349](http://qiniu.user-center.icu/img/image-20230317084112349.png)

6. 写一下校验逻辑，完善代码

```java
    @PostMapping("/register")
    public Long userRegister(@RequestBody UserRegisterRequest userRegisterRequest) {
        // 前端传过来的值为空时
        if (userRegisterRequest == null) {
            return null;
        }
        String userAccount = userRegisterRequest.getUserAccount();
        String userPassword = userRegisterRequest.getUserPassword();
        String checkPassword = userRegisterRequest.getCheckPassword();
        // 参数有任意一个为空时
        if (StringUtils.isAnyBlank(userAccount, userPassword, checkPassword)) {
            return null;
        }
        return userService.userRegister(userAccount, userPassword, checkPassword);
    }
```

##### 5.2 用户登录

1. 将刚刚写的用户注册的请求复制一下，改为用户登录

先改成这个样子，后面再继续改

![image-20230317084726542](http://qiniu.user-center.icu/img/image-20230317084726542.png)

2. 依据着 UserRegisterRequest 编写一个 UserLoginRequest 请求体

```java
@Data
public class UserLoginRequest implements Serializable {
    private static final long serialVersionUID = 6010448209356722607L;

    private String userAccount;
    private String userPassword;

}
```

3. 回到 userLogin 继续改

```java
    @PostMapping("/login")
    public User userLogin(@RequestBody UserLoginRequest userLoginRequest, HttpServletRequest request) {
        // 前端传过来的值为空时
        if (userLoginRequest == null) {
            return null;
        }
        String userAccount = userLoginRequest.getUserAccount();
        String userPassword = userLoginRequest.getUserPassword();
        // 参数有任意一个为空时
        if (StringUtils.isAnyBlank(userAccount, userPassword)) {
            return null;
        }
        return userService.doLogin(userAccount, userPassword, request);
    }
```

4. 为了统一格式，将 UserService 和 UserServiceImpl 中的 doLogin 修改为 userLogin

![image-20230317085508374](http://qiniu.user-center.icu/img/image-20230317085508374.png)

#### 6. 测试

1. idea 自带了一个测试工具，Tool -> HTTP Client -> Create Request in HTTP Client

![image-20230317090454915](http://qiniu.user-center.icu/img/image-20230317090454915.png)

![image-20230317090507315](http://qiniu.user-center.icu/img/image-20230317090507315.png)

2. 以 debug 模式启动 application

![image-20230317090703588](http://qiniu.user-center.icu/img/image-20230317090703588.png)

3. 因为我们的登录和注册都是 post 请求，因此我们这里添加一个 post 请求，并将原本的 get 请求删掉即可

![image-20230317090813900](http://qiniu.user-center.icu/img/image-20230317090813900.png)

![image-20230317090858447](http://qiniu.user-center.icu/img/image-20230317090858447.png)

4. 修改一下测试接口和数据

![image-20230317091123728](http://qiniu.user-center.icu/img/image-20230317091123728.png)

> 第一次查询的时候没有查询到结果，debug 后发现返回的结果为空，可知是未查询到数据
>
> 最后发现，在登录的时候，账户和密码匹配的时候，密码使用的是为加密的密码，因此没有查询到数据
>
> ![image-20230317102348716](http://qiniu.user-center.icu/img/image-20230317102348716.png)
>
> 改成加密后密码就可以了...

5. 测试完后，发现多了一个 json 格式内容

![image-20230317102543438](http://qiniu.user-center.icu/img/image-20230317102543438.png)

点进去看一下

可以看到与数据库中的内容是相对应的，且已经进行脱敏处理

![image-20230317102603833](http://qiniu.user-center.icu/img/image-20230317102603833.png)

6. 再试一下逻辑删除，将数据库中的逻辑删除字段设置为 `1`

![image-20230317102754019](http://qiniu.user-center.icu/img/image-20230317102754019.png)

再次测试可以发现，被逻辑删除的用户将不能够再被查询出来了

### 六、用户管理接口

> **！！！鉴权（只能管理员使用）**
>
> 1. 查询用户
>    1. 允许根据用户名查询
> 2. 删除用户

在 UserController 中编写查询用户和删除用户的接口

#### 1. 编写用户管理接口

**查询用户**

```java
    /**
     * 查询用户
     * @param username 用户名称
     * @return
     */
	@GetMapping("/search")
    public List<User> searchUser(String username) {
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        if (StringUtils.isNotBlank(username)) {
            queryWrapper.like("username", username);
        }
        return userService.list(queryWrapper);
    }
```

**删除用户**

```java
    /**
     * 删除用户
     * @param id 用户id
     * @return
     */
	@PostMapping("/delete")
    public boolean deleteUser(@RequestBody int id) {
        if (id < 0) {
            return false;
        }
        return userService.removeById(id);
    }
```

**思考一下**，这两个函数有没有问题？

这个接口是不安全的，任何一个人都可以调用，并且也没有校验调用者是否是管理员，因为这个接口是开放出去的

#### 2. 修改数据库表

我们现在要给 user 表添加一个字段，添加一个叫做身份或者权限的字段

1. 打开数据库表的编辑页面

![image-20230317104701750](http://qiniu.user-center.icu/img/image-20230317104701750.png)

2. 添加一个权限字段

![image-20230317104824108](http://qiniu.user-center.icu/img/image-20230317104824108.png)

3. 由于我们修改了数据库表，因此我们要修改 mybatis-plus 那一些列的代码，我们继续利用 mybatis-plus 插件重新生成一边即可

![image-20230317105007802](http://qiniu.user-center.icu/img/image-20230317105007802.png)

重复之前的搬运工作（这次搬运只需要搬运 domain 包下的 user 类即可），要注意不要忘记添加逻辑删除的字段

新生成的 `UserMapper.xml` 文件记得修改所对应的文件路径

![image-20230319155539282](http://qiniu.user-center.icu/img/image-20230319155539282.png)

4. UserServiceImpl 中的用户脱敏增添权限的 set 方法

![image-20230317105457086](http://qiniu.user-center.icu/img/image-20230317105457086.png)

#### 3. 修改用户管理接口

1. 对于用户管理接口我们要进行权限校验，那么我们首先就要拿到一个用户的登录状态

![image-20230317105715550](http://qiniu.user-center.icu/img/image-20230317105715550.png)

> 这个 getAttribute 应该取什么呢？我们是不是在 UserServiceImpl 中定义了一个用户登录的状态键，将这个状态键提取到 UserService 中
>
> ![image-20230317110200898](http://qiniu.user-center.icu/img/image-20230317110200898.png)
>
> ![image-20230317110234733](http://qiniu.user-center.icu/img/image-20230317110234733.png)

```java
    /**
     * 查询用户
     * @param username 用户名称
     * @return
     */
    @GetMapping("/search")
    public List<User> searchUser(String username, HttpServletRequest request) {
        // 仅管理员可查询
        Object userObj = request.getSession().getAttribute(UserService.USER_LOGIN_STATE);
        User user = (User) userObj;
        if (user == null || user.getUserRole() != 1) {
            return new ArrayList<>();
        }
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        if (StringUtils.isNotBlank(username)) {
            queryWrapper.like("username", username);
        }
        return userService.list(queryWrapper);
    }
```

> 这段代码算绝对完美吗？
>
> NO！这里的用户角色是有点问题的

2. 我们新建一个包，叫 constant，并在该包下新建一个 UserConstant 接口

![image-20230317112212331](http://qiniu.user-center.icu/img/image-20230317112212331.png)

将刚刚的用户登录状态键搬过来，并在两个权限常量

导入

![image-20230317114036111](http://qiniu.user-center.icu/img/image-20230317114036111.png)

![image-20230317114054986](http://qiniu.user-center.icu/img/image-20230317114054986.png)

利用常量，将之前判断用户权限的 `1` 改为 `ADMIN_ROLE`

![image-20230317114222491](http://qiniu.user-center.icu/img/image-20230317114222491.png)

3. 删除接口同样的逻辑

```java
    /**
     * 删除用户
     * @param id 用户id
     * @param request 用户登录状态
     * @return
     */
    @PostMapping("/delete")
    public boolean deleteUser(@RequestBody int id, HttpServletRequest request) {
        // 仅管理员可删除
        Object userObj = request.getSession().getAttribute(USER_LOGIN_STATE);
        User user = (User) userObj;
        if (user == null || user.getUserRole() != ADMIN_ROLE) {
            return false;
        }
        if (id < 0) {
            return false;
        }
        return userService.removeById(id);
    }
```

4. 提取公有函数

不难看出这两部分是重复的，我们将其提取出来写成一个公有函数

![image-20230317114550819](http://qiniu.user-center.icu/img/image-20230317114550819.png)

```java
    /**
     * 是否为管理员
     * @param request 用户登录状态
     * @return
     */
    private boolean isAdmin(HttpServletRequest request) {
        Object userObj = request.getSession().getAttribute(USER_LOGIN_STATE);
        User user = (User) userObj;
        if (user == null || user.getUserRole() != ADMIN_ROLE) {
            return false;
        }
        return true;
    }
```

> ![image-20230317115748226](http://qiniu.user-center.icu/img/image-20230317115748226.png)
>
> 这里的 if 可以简化
>
> ![image-20230317115803117](http://qiniu.user-center.icu/img/image-20230317115803117.png)

修改校验

![image-20230317120145708](http://qiniu.user-center.icu/img/image-20230317120145708.png)

5. 设置 session 的失效时间

在 `application.yml` 中添加 session 的失效时间（1天）

```yaml
spring:
  # session 失效时间
  session:
    timeout: 86400
```

6. 移除一下之前的登录状态，将 target 删除

![image-20230319154739046](http://qiniu.user-center.icu/img/image-20230319154739046.png)

7. 将用户的权限改为管理员

![image-20230319155904449](http://qiniu.user-center.icu/img/image-20230319155904449.png)

#### 4. 测试用户管理接口

1.  程序以 debug 的模式启动，并登录测试

![image-20230319160053293](http://qiniu.user-center.icu/img/image-20230319160053293.png)

2. 测试用户管理查询

![image-20230319160121301](http://qiniu.user-center.icu/img/image-20230319160121301.png)

3. 查询成功，查看一下返回值都有什么

![image-20230319160506172](http://qiniu.user-center.icu/img/image-20230319160506172.png)

![image-20230319160521733](http://qiniu.user-center.icu/img/image-20230319160521733.png)

可以看到，返回的数据有点多，没有将密码之类的数据过滤掉

我们将之前写的用户脱敏改造成一个方法 `getSafetyUser` 

```java
    /**
     * 用户脱敏
     * @param originUser 未脱敏的用户信息
     * @return
     */
    public User getSafetyUser(User originUser) {
        User safetyUser = new User();
        safetyUser.setId(originUser.getId());
        safetyUser.setUsername(originUser.getUsername());
        safetyUser.setUserAccount(originUser.getUserAccount());
        safetyUser.setAvatarUrl(originUser.getAvatarUrl());
        safetyUser.setGender(originUser.getGender());
        safetyUser.setEmail(originUser.getEmail());
        safetyUser.setUserStatus(originUser.getUserStatus());
        safetyUser.setPhone(originUser.getPhone());
        safetyUser.setCreatTime(originUser.getCreatTime());
        safetyUser.setUserRole(originUser.getUserRole());
        return safetyUser;
    }
```

![image-20230319161011377](http://qiniu.user-center.icu/img/image-20230319161011377.png)

在 `getSafetyUser` 上加个 `@Override` 注解，然后 Pull 到接口中

![image-20230319161232578](http://qiniu.user-center.icu/img/image-20230319161232578.png)

后面再需要用到脱敏的地方，直接调用方法就行了

```java
    /**
     * 查询用户
     * @param username 用户名称
     * @param request 用户登录状态
     * @return
     */
    @GetMapping("/search")
    public List<User> searchUser(String username, HttpServletRequest request) {
        if (!isAdmin(request)) {
            return new ArrayList<>();
        }
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        if (StringUtils.isNotBlank(username)) {
            queryWrapper.like("username", username);
        }
        List<User> userList = userService.list(queryWrapper);
        return userList.stream().map(user -> userService.getSafetyUser(user)).collect(Collectors.toList());
    }
```

![image-20230319162455684](http://qiniu.user-center.icu/img/image-20230319162455684.png)

4. 再次测试可以发现返回的数据是经过脱敏之后的了

![image-20230319162702145](http://qiniu.user-center.icu/img/image-20230319162702145.png)

### 七、写代码流程

- 先做设计
- 代码实现
- 持续优化！！！（复用代码、提取公共逻辑/常量）

## 前端

### 一、修改整理前端页面

#### 1. 修改底部版权信息

![image-20230319164158690](http://qiniu.user-center.icu/img/image-20230319164158690.png)

![image-20230319164218760](http://qiniu.user-center.icu/img/image-20230319164218760-1679215339566-1.png)

#### 2. 修改 Logo

![image-20230319164556847](http://qiniu.user-center.icu/img/image-20230319164556847.png)

> 我这里就不进行修改了（省下点时间【🐶保命】）

#### 3. 删除多余代码

1. 删除其他登录方式

![image-20230319164853216](http://qiniu.user-center.icu/img/image-20230319164853216.png)

2. 删除手机号登录

![image-20230319164921824](http://qiniu.user-center.icu/img/image-20230319164921824.png)

3. 删除自动提示错误的用户和密码

![image-20230319164955788](http://qiniu.user-center.icu/img/image-20230319164955788.png)

> 我这里就不删了，万一以后学到了怎么做呢，不就可以完善了嘛，开始画大饼（🐶保命）

4. 将用户名改为账号,按 ctrl + f，全部替换

![image-20230319165428896](http://qiniu.user-center.icu/img/image-20230319165428896.png)

> 总之，能不改的地方我就不改了...

### 二、对接（请求）后台的接口

#### 1. 修改前端登录接口类型

1. 找到 `handleSubmit`，点击 `LoginParams`

![image-20230319172845573](http://qiniu.user-center.icu/img/image-20230319172845573.png)

![image-20230319172853902](http://qiniu.user-center.icu/img/image-20230319172853902.png)

2. 将 username 和 password 重构为 userAccount 和 userPassword（快捷键 shift + f6）

![image-20230319173300656](http://qiniu.user-center.icu/img/image-20230319173300656.png)

#### 2. 修改 request 请求地址

1. 找到登录，点击 login

![image-20230319173630561](http://qiniu.user-center.icu/img/image-20230319173630561.png)

![image-20230319173642228](http://qiniu.user-center.icu/img/image-20230319173642228.png)

2. 根据官方文档可以得知我们要在 `app.ts` 里面配置

![image-20230319174751633](http://qiniu.user-center.icu/img/image-20230319174751633.png)

```react
export const request: RequestConfig = {
  prefix: 'http://localhost:8080',
  timeout: 1000,
}
```

3. 请求地址修改为 `/user/login`

![image-20230319175108384](http://qiniu.user-center.icu/img/image-20230319175108384.png)

4. 去登录测试一下（看一下请求地址是否正确）

![image-20230319175417946](http://qiniu.user-center.icu/img/image-20230319175417946.png)

### 三、代理

> 正向代理：替客户端向服务器发送请求，可以解决跨域问题
>
> 反向代理：替服务器统一接收请求
>
> 怎么搞代理？
>
> Nginx 服务器
>
> Node.js 服务器
>
> 原本请求：http://localhost:8000/api/user/login
>
> 代理到请求：http://localhost:8080/api/user/login
>
> 反向代理和正向代理的区别：[反向代理和正向代理区别 - 泛夜泰克 - 博客园 (cnblogs.com)](https://www.cnblogs.com/taostaryu/p/10547132.html)
>
> ![image-20230319184149091](http://qiniu.user-center.icu/img/image-20230319184149091.png)

#### 1. 存在的问题

现在我们就遇到了跨域错误，为什么会跨域？

因为我们当前前端浏览器里的地址是8000端口，但是我们的后端，它是8080端口，端口不一样，就是跨域的。跨域的话，有多种方式解决，要么搭一个代理，要么在你的后端去支持跨域，但是后端支持跨域很不安全。

#### 2. 配置代理

1. Ant Design Pro 它提供了一个配置代理的方式，我们直接用它的代理即可

![image-20230319185226198](http://qiniu.user-center.icu/img/image-20230319185226198.png)

2. 将地址改为我们要代理的地址

![image-20230319185344380](http://qiniu.user-center.icu/img/image-20230319185344380.png)

3. 删掉之前设置 `prefix`，并将超时时间改为 10000（10秒）

![image-20230319190413525](http://qiniu.user-center.icu/img/image-20230319190413525.png)

> 前面做了些无用功....

4. 请求地址加上 `api`

![image-20230319190649590](http://qiniu.user-center.icu/img/image-20230319190649590.png)

5. 让后端支持一下，也统一加上 `/api`

![image-20230319190740830](http://qiniu.user-center.icu/img/image-20230319190740830.png)

```yaml
server:
  port: 8080
  servlet:
    context-path: /api
```

5. 在后端打隔断点，看看后端能不能接收到请求

可以发现后端可以接收到请求，但是没有拿到数据....

![image-20230319191638579](http://qiniu.user-center.icu/img/image-20230319191638579.png)

#### 3. 修改前端登录代码

1. 在 `index.tsx` 中把 username 替换成 userAccount，将 password 替换成 userPassword（区别大小写匹配）

![image-20230319192254550](http://qiniu.user-center.icu/img/image-20230319192254550.png)

![image-20230319192316642](http://qiniu.user-center.icu/img/image-20230319192316642.png)

2. 给密码添加一个长度校验

![image-20230319192436297](http://qiniu.user-center.icu/img/image-20230319192436297.png)

3. 这里改成 user，如果 user 存在的话，就显示登录成功，并且设置用户的登录状态为 user

![image-20230319192652764](http://qiniu.user-center.icu/img/image-20230319192652764.png)

![image-20230319192748823](http://qiniu.user-center.icu/img/image-20230319192748823.png)

4. 测试一下，长度的校验成功了

![image-20230319192832417](http://qiniu.user-center.icu/img/image-20230319192832417.png)

5. 测试一下后台能不能拿到账号和密码

![image-20230319192952209](http://qiniu.user-center.icu/img/image-20230319192952209.png)

6. 使用数据库里的账号密码登录，看看前端能不能获得响应数据

可以看到，获得了响应数据，说明前后端已经连通成功了！

![image-20230319193200974](http://qiniu.user-center.icu/img/image-20230319193200974.png)

### 五、完成前端注册功能

#### 1. 增加注册页面

1. 直接复制登录页面，重命名为 Register（复制整个 Login 文件夹，粘贴到 useer 文件夹下，重命名）

![image-20230319200601211](http://qiniu.user-center.icu/img/image-20230319200601211.png)

2. 复制玩页面后，记得吧组件的名称改一下

![image-20230319200753292](http://qiniu.user-center.icu/img/image-20230319200753292.png)



#### 2. 定义注册的地址

1. 我们需要去定义一下，用户在地址栏里面输入什么网址，才能够访问到新建的页面，新建路由

> 我们现在是用了 react router 这样一个路由组件，可以帮助我们把 url 和写的页面组件关联上，这样的话用户访问某一个地址。比如说 `user/register`，然后访问它的时候，后面去指定一个我们写的组件的位置，比如说 `user/register`，他就会找到 user 配置目录下的 register

![image-20230319202907033](http://qiniu.user-center.icu/img/image-20230319202907033.png)

2. 还要在 app.tsx 修改一些内容（不做这些访问 register 会重定向到 login 页面）

注释掉

![image-20230319203518611](http://qiniu.user-center.icu/img/image-20230319203518611.png)

将这段代码

![image-20230319203828863](http://qiniu.user-center.icu/img/image-20230319203828863.png)

修改为

![image-20230319203954880](http://qiniu.user-center.icu/img/image-20230319203954880.png)

3. 再试一下 `http:localhost:8000/user/register`，看看是否可以正常访问

可以正常访问，没有放生重定向....

![image-20230319204709328](http://qiniu.user-center.icu/img/image-20230319204709328.png)

**为什么会触发这种重定向到登录页的逻辑？**

> 主要是因为`app.tsx`它是这个前端项目的全局文件，里面定义了刚进入一个页面时要执行的逻辑，比如说我们刚进入页面要获取用户信息，如果没有获取到用户信息，就重定向到登录页面让你登录，那同时，因为使用的这个矿建，更偏向于后台管理系统，所以说每个页面都会去校验。如果说用户没有登录，没有登录状态，那我们就把它重定向到登录页面

#### 3. 写前端代码

1. 将前端页面修改成这样就可以了（终究是没逃过呀🐶）

![image-20230319210750671](http://qiniu.user-center.icu/img/image-20230319210750671.png)

2. 将**登录**全局替换成**注册**

![image-20230319211012882](http://qiniu.user-center.icu/img/image-20230319211012882.png)

3. 但是登录按钮的文字没有变成注册（是因为我们使用的线程的loginform组件）

增加代码

![image-20230319211703347](http://qiniu.user-center.icu/img/image-20230319211703347.png)

这样前端页面就算写好了

![image-20230319211832282](http://qiniu.user-center.icu/img/image-20230319211832282.png)

#### 4. 提交逻辑

1. ctrl + 单击这个 `LoginParams`，去补充注册参数

![image-20230319212025404](http://qiniu.user-center.icu/img/image-20230319212025404.png)

2. 复制 `LoginParams` 改为 `RegisterParams` 并进行修改

```ts
  type RegisterParams = {
    userAccount?: string;
    userPassword?: string;
    checkPassword?: string;
    type?: string;
  };
```

3. 将 `index.tsx` 中的 `LoginParams` 替换为 `RegisterParams` 

![image-20230319212321142](http://qiniu.user-center.icu/img/image-20230319212321142.png)

4. 补充一些校验逻辑

![image-20230319214214882](http://qiniu.user-center.icu/img/image-20230319214214882.png)

5. 编写一个注册接口

```ts
/** 注册接口 POST /api/user/register */
export async function register(body: API.LoginParams, options?: { [key: string]: any }) {
  return request<API.LoginResult>('/api/user/register', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    data: body,
    ...(options || {}),
  });
}
```

6. 定义一下注册返回类型

这里的 `LoginResult` 定义了后端给前端返回的类型数据

![image-20230319215107964](http://qiniu.user-center.icu/img/image-20230319215107964.png)

我们定义一个注册需要返回的类型数据

```ts
  type RegisterResult = number;
```

7. 修改一下注册逻辑

将 user 改为 id，login 改为 register

![image-20230320104522681](http://qiniu.user-center.icu/img/image-20230320104522681.png)

8. 修改注册成功跳转的位置和注册失败的提示信息

![image-20230320110452157](http://qiniu.user-center.icu/img/image-20230320110452157.png)

#### 5. 测试一下

1. 先试一下密码不一致有没有弹出提示

![image-20230320105746429](http://qiniu.user-center.icu/img/image-20230320105746429.png)

2. 测试以及重复的账号注册

注册失败，但是没有提示为什么注册（账号重复），这是一个待优化的点

![image-20230320110546399](http://qiniu.user-center.icu/img/image-20230320110546399.png)

返回值是 `-1`，因为我们后端刚开始写的时候，失败的返回值全是 `-1`

![image-20230320110557906](http://qiniu.user-center.icu/img/image-20230320110557906.png)

3. 注册一个新的账号

注册成功

![image-20230320110756444](http://qiniu.user-center.icu/img/image-20230320110756444.png)

返回值为 id，并且跳转了登录页面

![image-20230320110836237](http://qiniu.user-center.icu/img/image-20230320110836237.png)

4. 在登录页面上添加一个注册账号的链接

![image-20230320132251865](http://qiniu.user-center.icu/img/image-20230320132251865.png)

### 六、获取当前用户登录状态、信息接口

#### 1. 在 UserController 中添加获取当前用户登录状态、信息接口

```java
    @GetMapping("/current")
    public User getCurrentUser(HttpServletRequest request) {
        Object userObj = request.getSession().getAttribute(USER_LOGIN_STATE);
        User currentUser = (User) userObj;
        if (currentUser == null) {
            return null;
        }
        Long userId = currentUser.getId();
        // todo 校验用户是否合法
        User user = userService.getById(userId);
        return userService.getSafetyUser(user);
    }
```

> 代码有些问题，没有判断用户是否封号

#### 2. 补写前端代码

1. 回到前端，找到 `queryCurrentUser`

![image-20230320133313341](http://qiniu.user-center.icu/img/image-20230320133313341.png)

2. 修改一下

![image-20230320133541820](http://qiniu.user-center.icu/img/image-20230320133541820.png)

3. 修改返回值 `CurrentUser`

![image-20230320135939348](http://qiniu.user-center.icu/img/image-20230320135939348.png)

根据数据库修改成决定要返回的东西

![image-20230320140216242](http://qiniu.user-center.icu/img/image-20230320140216242.png)

4. 将之前设置不需要用户登录态的白名单写成一个常量

```ts
const NO_NEED_LOGIN_WHITE_LIST = ['/user/register', loginPath];
```

5. 修改代码

![image-20230320141401927](http://qiniu.user-center.icu/img/image-20230320141401927.png)

#### 3. 登录测试

1. 成功登录，进入管理页面

![image-20230320141758685](http://qiniu.user-center.icu/img/image-20230320141758685.png)

2. 但是头像没有显示出来

推测：前后端的变量名没有对应，我们去前端修改一下

![image-20230320142328039](http://qiniu.user-center.icu/img/image-20230320142328039.png)

3. 刷新页面，头像就已经显示出来了

![image-20230320142829643](http://qiniu.user-center.icu/img/image-20230320142829643.png)

### 七、完成用户管理后台前端

#### 1. 创建用户管理页面

1. 在 pages 文件夹下新建 Admin 文件夹，将 user 文件夹下的 Register 文件夹复制到 Admin 文件夹下，改名为 UserManage

![image-20230320145401769](http://qiniu.user-center.icu/img/image-20230320145401769.png)

2. 在 route.ts 中添加一个路由

![image-20230320144528110](http://qiniu.user-center.icu/img/image-20230320144528110.png)



3. 访问一下

无权访问

![image-20230320145512037](http://qiniu.user-center.icu/img/image-20230320145512037.png)

对比上面的 `/user`，可以发现 `/admin` 多了 `access:canAdmin` 也就是管理员才能访问

![image-20230320145630375](http://qiniu.user-center.icu/img/image-20230320145630375.png)

4. 修改一下 access 的判断逻辑

![image-20230320145917643](http://qiniu.user-center.icu/img/image-20230320145917643.png)

5. 刷新页面可以发现已经正常显示了

![image-20230320150028455](http://qiniu.user-center.icu/img/image-20230320150028455.png)

#### 2. 修改删掉没用的代码

1. 去官方文档直接使用现有的表格：[ProForm - 高级表单 - Pro Components (ant.design)](https://procomponents.ant.design/components/form)

![image-20230320151323925](http://qiniu.user-center.icu/img/image-20230320151323925.png)

```ts
import { EllipsisOutlined, PlusOutlined } from '@ant-design/icons';
import type { ActionType, ProColumns } from '@ant-design/pro-components';
import { ProTable, TableDropdown } from '@ant-design/pro-components';
import { Button, Dropdown, Space, Tag } from 'antd';
import { useRef } from 'react';
import request from 'umi-request';

type GithubIssueItem = {
  url: string;
  id: number;
  number: number;
  title: string;
  labels: {
    name: string;
    color: string;
  }[];
  state: string;
  comments: number;
  created_at: string;
  updated_at: string;
  closed_at?: string;
};

const columns: ProColumns<GithubIssueItem>[] = [
  {
    dataIndex: 'index',
    valueType: 'indexBorder',
    width: 48,
  },
  {
    title: '标题',
    dataIndex: 'title',
    copyable: true,
    ellipsis: true,
    tip: '标题过长会自动收缩',
    formItemProps: {
      rules: [
        {
          required: true,
          message: '此项为必填项',
        },
      ],
    },
  },
  {
    disable: true,
    title: '状态',
    dataIndex: 'state',
    filters: true,
    onFilter: true,
    ellipsis: true,
    valueType: 'select',
    valueEnum: {
      all: { text: '超长'.repeat(50) },
      open: {
        text: '未解决',
        status: 'Error',
      },
      closed: {
        text: '已解决',
        status: 'Success',
        disabled: true,
      },
      processing: {
        text: '解决中',
        status: 'Processing',
      },
    },
  },
  {
    disable: true,
    title: '标签',
    dataIndex: 'labels',
    search: false,
    renderFormItem: (_, { defaultRender }) => {
      return defaultRender(_);
    },
    render: (_, record) => (
      <Space>
        {record.labels.map(({ name, color }) => (
          <Tag color={color} key={name}>
            {name}
          </Tag>
        ))}
      </Space>
    ),
  },
  {
    title: '创建时间',
    key: 'showTime',
    dataIndex: 'created_at',
    valueType: 'date',
    sorter: true,
    hideInSearch: true,
  },
  {
    title: '创建时间',
    dataIndex: 'created_at',
    valueType: 'dateRange',
    hideInTable: true,
    search: {
      transform: (value) => {
        return {
          startTime: value[0],
          endTime: value[1],
        };
      },
    },
  },
  {
    title: '操作',
    valueType: 'option',
    key: 'option',
    render: (text, record, _, action) => [
      <a
        key="editable"
        onClick={() => {
          action?.startEditable?.(record.id);
        }}
      >
        编辑
      </a>,
      <a href={record.url} target="_blank" rel="noopener noreferrer" key="view">
        查看
      </a>,
      <TableDropdown
        key="actionGroup"
        onSelect={() => action?.reload()}
        menus={[
          { key: 'copy', name: '复制' },
          { key: 'delete', name: '删除' },
        ]}
      />,
    ],
  },
];

export default () => {
  const actionRef = useRef<ActionType>();
  return (
    <ProTable<GithubIssueItem>
      columns={columns}
      actionRef={actionRef}
      cardBordered
      request={async (params = {}, sort, filter) => {
        console.log(sort, filter);
        return request<{
          data: GithubIssueItem[];
        }>('https://proapi.azurewebsites.net/github/issues', {
          params,
        });
      }}
      editable={{
        type: 'multiple',
      }}
      columnsState={{
        persistenceKey: 'pro-table-singe-demos',
        persistenceType: 'localStorage',
        onChange(value) {
          console.log('value: ', value);
        },
      }}
      rowKey="id"
      search={{
        labelWidth: 'auto',
      }}
      options={{
        setting: {
          listsHeight: 400,
        },
      }}
      form={{
        // 由于配置了 transform，提交的参与与定义的不同这里需要转化一下
        syncToUrl: (values, type) => {
          if (type === 'get') {
            return {
              ...values,
              created_at: [values.startTime, values.endTime],
            };
          }
          return values;
        },
      }}
      pagination={{
        pageSize: 5,
        onChange: (page) => console.log(page),
      }}
      dateFormatter="string"
      headerTitle="高级表格"
      toolBarRender={() => [
        <Button key="button" icon={<PlusOutlined />} type="primary">
          新建
        </Button>,
        <Dropdown
          key="menu"
          menu={{
            items: [
              {
                label: '1st item',
                key: '1',
              },
              {
                label: '2nd item',
                key: '1',
              },
              {
                label: '3rd item',
                key: '1',
              },
            ],
          }}
        >
          <Button>
            <EllipsisOutlined />
          </Button>
        </Dropdown>,
      ]}
    />
  );
};
```

2. 粘贴到 `/Admin/UserManage/index.tsx` 下

删除一些不需要的代码（按自己需求来）

![image-20230320151818733](http://qiniu.user-center.icu/img/image-20230320151818733.png)

3. 修改列名，改成 `API.CurrentUser`

![image-20230320152005238](http://qiniu.user-center.icu/img/image-20230320152005238.png)

4. 修改展示的列，根据数据库中字段修改

![image-20230321083105628](http://qiniu.user-center.icu/img/image-20230321083105628.png)

5. 在 `api.ts` 下增加一个搜索用户的接口

```tsx
/** 搜索接口 GET /api/notices */
export async function searchUsers(options?: { [key: string]: any }) {
  return request<API.NoticeIconList>('/api/user/search', {
    method: 'GET',
    ...(options || {}),
  });
}
```

6. 回到 usermanage 下的 index.tsx 文件，增加调用用户搜索函数

![image-20230321084648363](http://qiniu.user-center.icu/img/image-20230321084648363.png)

7. 访问 http://localhost:8000/admin/user-manage?current=1&pageSize=5

![image-20230321084815636](http://qiniu.user-center.icu/img/image-20230321084815636.png)

8. 这里的用户头像有问题，我们修改一下它的渲染逻辑

![image-20230321085104213](http://qiniu.user-center.icu/img/image-20230321085104213.png)

![image-20230321085211130](http://qiniu.user-center.icu/img/image-20230321085211130.png)

9. 用户角色的地方显示 0 和 1，不太友好，我们优化一下

![image-20230321085917112](http://qiniu.user-center.icu/img/image-20230321085917112.png)

![image-20230321085927134](http://qiniu.user-center.icu/img/image-20230321085927134.png)

## 项目优化

### 一、用户校验

> 这里的用户校验仅限于用户可信的情况

1. 先让用户自己填写：2 - 5位编号（自觉）
2. 后台补充对编号的校验：长度校验、唯一性校验
3. 前端补充输入框，适配后端
4. 后期拉取星球数据，定期清理违规用户

### 二、后端优化

1. 返回通用对象（给对象补充一些信息，告诉前端这个请求在业务层上是成功还是失败）

   - 自定义错误码
   - 返回类支持返回正常和错误

2. 封装全局异常处理

   - 定义业务异常类

     - 相对于 java 的异常类，支持更多字段
     - 自定义构造函数，更灵活/便捷的设置字段

   - 编写全局异常处理器

     作用：

     - 捕获代码中所有的异常，内部消化，让前端得到更详细的业务报错信息
     - 同时屏蔽掉项目框架本身的异常，不暴露服务器的异常
     - 集中处理，比如记录日志

     实现

     - Spring AOP：在调用方法前进行额外的处理

3. todo 全局请求日志和登录校验

### 三、前端优化

1. 对接后端的返回值，取 data
2. 全局响应处理
   1. 应用场景：我们需要接口的通用响应进行统一处理，比如从 response 中取出 data；或者根据 code 去集中处理错误。比如用户未登录、没有权限等。
   2. 优势：不用在每个接口请求中都去写相同的逻辑
   3. 实现：参考用到的请求封装工具的官方文档

### 四、用户注销前后端

#### 1. 后端

1. 先写业务层逻辑（service层）

![image-20230321092114729](http://qiniu.user-center.icu/img/image-20230321092114729.png)

用户注销需要接收什么参数？我们回想一下用户登录用到了什么参数。

> 当用户登录成功后，我们在 session 中保存了以后的登录状态，之后，我们判断用户是否登录就是从 session 中有没有这个标识，就可以知道用户有没有登录

> 同样的，如果我们要注销用户，	就要做的与用户登录相反，移除一个登录态，把同样的一个登录态的标识移除即可

```java
    /**
     * 用户注销
     * @param request 用户登录状态
     * @return
     */
    int userLogout(HttpServletRequest request);
```

2. 移除用户登录态

我们从 request 中取出 session，我们之前是将用户的登录状态标识设置为一个常量 `USER_LOGIN_STATE`，我们现在就将这个属性移除就可以了

```java
    @Override
    public int userLogout(HttpServletRequest request) {
        // 移除登录态
        request.getSession().removeAttribute(USER_LOGIN_STATE);
        return 1;
    }
```

3. 编写 controller 层

```java
    /**
     * 用户注销
     * @param request 用户登录状态
     * @return
     */
    @PostMapping("/logout")
    public Integer userLogout(HttpServletRequest request) {
        // 前端传过来的值为空时
        if (request == null) {
            return null;
        }
        return userService.userLogout(request);
    }
```

#### 2. 前端

> 如果说要注销，肯定要把前端已经存在的登录态给它设置为空，我们前端登录存在了 `app.tsx`，这里定义了一个 currentUser，尤其是 `getInitialState` 方法，每次属性页面或者刚进入新页面时，最先执行的一个方法。
>
> 在这个方法中，定义了一些要初始化的操作，比如获取已登录的用户的信息，会把用户信息放到 `InitialState` 里面，如果我们要注销，就要把 `InitialState` 里已存在的用户信息清空掉

1. 修改一下退出登录接口

```tsx
/** 退出登录接口 POST /api/user/logout */
export async function outLogin(options?: { [key: string]: any }) {
  return request<Record<string, any>>('/api/user/logout', {
    method: 'POST',
    ...(options || {}),
  });
}
```

2. 测试一下

退出成功，响应值是 1

![image-20230321094403699](http://qiniu.user-center.icu/img/image-20230321094403699.png)

### 五、补充用户注册校验前后端逻辑

#### 1. 后端

1. 在数据库中补充一个字段（星球编号-planetCode）

![image-20230321094813976](http://qiniu.user-center.icu/img/image-20230321094813976.png)

2. 修改数据库表结构后，要记得用 mybatis-plus 插件重新生成一下代码

！！！记得给逻辑删除字段添加注释

！！！记得修改 xml 文件的文件路径（已经踩过一次坑了）

![image-20230321095316781](http://qiniu.user-center.icu/img/image-20230321095316781.png)

![image-20230321095309148](http://qiniu.user-center.icu/img/image-20230321095309148.png)

3. 给脱敏函数增加一个星球编号

![image-20230321111455715](http://qiniu.user-center.icu/img/image-20230321111455715.png)

4. 给请求注册体添加一个星球编号

![image-20230321111553045](http://qiniu.user-center.icu/img/image-20230321111553045.png)

5. controller 层的注册方法补充一个校验和参数

![image-20230321111811727](http://qiniu.user-center.icu/img/image-20230321111811727.png)

6. 在 service 方法中补充星球编号字段

![image-20230321112150140](http://qiniu.user-center.icu/img/image-20230321112150140.png)

7. 添加一些星球编号的校验

```java
        if (planetCode.length() > 5 ) {
            return -1;
        }
```

```java
        // 星球编号不能重复
        queryWrapper = new QueryWrapper<>();
        queryWrapper.eq("planetCode", planetCode);
        count = userMapper.selectCount(queryWrapper);
        if (count > 0) {
            return -1;
        }
```

8. 测试一下

```java
    @Test
    void userRegister() {
        String userAccount = "planet";
        String userPassword = "12345678";
        String checkPassword = "12345678";
        String planetCode = "123";
        long result = userService.userRegister(userAccount, userPassword, checkPassword, planetCode);
        Assertions.assertEquals(-1, result);
    }
```

![image-20230321113546169](http://qiniu.user-center.icu/img/image-20230321113546169.png)

#### 2. 前端

1. 补充用户注册时的一个星球编号的输入框

![image-20230321113901863](http://qiniu.user-center.icu/img/image-20230321113901863.png)

![image-20230321113911220](http://qiniu.user-center.icu/img/image-20230321113911220.png)

2. 再修改一下前端传给后端的请求

![image-20230321114039216](http://qiniu.user-center.icu/img/image-20230321114039216.png)

3. 在用户管理查询页面中增加一列星球编号

![image-20230321114659192](http://qiniu.user-center.icu/img/image-20230321114659192.png)

### 六、后端代码优化

#### 1. 通用返回对象

**为什么要做通用返回对象？**

> 后端直接返回一个对象给前端，如果这个数据出问题了、后端处理报错了、查不到优化，前端如果不可以区分的话，也不知道它到底为什么报错。
>
> 比如说一个测试，它返回了一个有六项的列表，例如后台返回一个空数组，前端可能也不会意识到它是错误的，如果说后台因为一些异常，我们强制给他返回空数组，但前端可能不知道对不对，他还以为这个只是一个本来就是数据库里没有用户的一个值。
>
> 所以我们需要定义一个通用的返回对象。

1. 在 common 包下新建 BaseResponse 基本返回类

![image-20230322100744169](http://qiniu.user-center.icu/img/image-20230322100744169.png)

2. BaseResponse 的内容

```java
public class BaseResponse<T> implements Serializable {

    private int code;
    private T data;
    private String message;

    public BaseResponse(int code, T data, String message) {
        this.code = code;
        this.data = data;
        this.message = message;
    }

    public BaseResponse(int code, T data) {
        this(code, data, "");
    }

}
```

3. 在 common 包下新建一个工具类 ResultUtil

![image-20230322101255595](http://qiniu.user-center.icu/img/image-20230322101255595.png)

4. ResultUtil 的内容

```java
public class ResultUtil {

    public static <T> BaseResponse<T> success(T data) {
        return new BaseResponse<>(0, data, "ok");
    }

}
```

5. 我们将之前所有的请求都用 BaseResponse 封装一下，比如之前的用户注册返回类型是 int，我们现在给它修改成 BaseResponse

![image-20230322101840020](http://qiniu.user-center.icu/img/image-20230322101840020.png)

6. 登录也改一下

![image-20230322102104232](http://qiniu.user-center.icu/img/image-20230322102104232.png)

其它接口都一样，也都改一下

#### 2. 自定义错误码

> 在此之前，我们出现任何错误都是直接返回 -1，但是返回 -1 前端不知道是出现了什么样的错误
>
> 因此，我们要定义一个通用的错误码，定义一套错误的规范

1. 我们在 common 包下，新建一个 ErrorCode 枚举值

![image-20230322102922903](http://qiniu.user-center.icu/img/image-20230322102922903.png)

2. ErrorCode 的内容

```java
public enum ErrorCode {

    SUCCESS(0, "ok", ""),
    PARAMS_ERROR(40000, "请求参数错误", ""),
    NULL_ERROR(40001, "请求数据为空", ""),
    NOT_LOGIN(40100, "未登录", ""),
    NO_AUTH(40101, "无权限", "");

    private final int code;
    private final String message;
    private final String description;

    ErrorCode(int code, String message, String description) {
        this.code = code;
        this.message = message;
        this.description = description;
    }

    public int getCode() {
        return code;
    }

    public String getMessage() {
        return message;
    }

    public String getDescription() {
        return description;
    }
}
```

3. 修改 BaseResponse 的内容

```java
public class BaseResponse<T> implements Serializable {

    private int code;
    private T data;
    private String message;
    private String description;

    public BaseResponse(int code, T data, String message, String description) {
        this.code = code;
        this.data = data;
        this.message = message;
        this.description = description;
    }

    public BaseResponse(int code, T data, String message) {
        this.code = code;
        this.data = data;
        this.message = message;
    }

    public BaseResponse(int code, T data) {
        this(code, data, "", "");
    }

    public BaseResponse(ErrorCode errorCode) {
        this(errorCode.getCode(), null, errorCode.getMessage(), errorCode.getDescription());
    }

}
```

4. 完善 ResultUtil

```java
public class ResultUtil {

    /**
     * 成功
     * @param data 返回值
     * @return
     * @param <T> 泛型
     */
    public static <T> BaseResponse<T> success(T data) {
        return new BaseResponse<>(0, data, "ok");
    }

    /**
     * 失败
     * @param errorCode 错误代码
     * @return
     */
    public static BaseResponse error(ErrorCode errorCode) {
        return new  BaseResponse<>(errorCode);
    }

}
```

5. 在 controller 中修改返回错误的地方

![image-20230322104222702](http://qiniu.user-center.icu/img/image-20230322104222702.png)

> 我们有很多地方都要改成这个样子，这样写其实不是很优雅，我们每次都要去调用这个错误返回类，接下来我们就要封装全局异常处理，就是我们将所有的错误都放到一个地方去处理

#### 3. 封装全局异常处理

1. 先定义全局异常，新建一个 exception 包，在该包下新建 BusinessException 类

![image-20230322104932443](http://qiniu.user-center.icu/img/image-20230322104932443.png)

2. BusinessException 的内容

```java
public class BusinessException extends RuntimeException{

    private final int code;
    private final String description;

    public BusinessException(int code, String description) {
        this.code = code;
        this.description = description;
    }

    public BusinessException(ErrorCode errorCode) {
        super(errorCode.getMessage());
        this.code = errorCode.getCode();
        this.description = errorCode.getDescription();
    }

    public BusinessException(ErrorCode errorCode, String description) {
        super(errorCode.getMessage());
        this.code = errorCode.getCode();
        this.description = description;
    }

    public int getCode() {
        return code;
    }

    public String getDescription() {
        return description;
    }
}
```

3. 修改一下 controller 的错误返回

![image-20230322105551496](http://qiniu.user-center.icu/img/image-20230322105551496.png)

并将之前没有修改的错误返回信息全部都进行修改

4. 同理，service 层也都需要进行修改

![image-20230322110741163](http://qiniu.user-center.icu/img/image-20230322110741163.png)

5. 测试一下

返回值依旧是 500，为什么呢？

![image-20230322114418060](http://qiniu.user-center.icu/img/image-20230322114418060.png)

后台也抛异常了，那么它的返回值不应该是 40000 么？

![image-20230322114504877](http://qiniu.user-center.icu/img/image-20230322114504877.png)

所以我们缺失了一个东西，全局异常处理器

> **全局异常处理器**：捕获代码中的所有异常集中处理

6. 我们去 exception 包下新建一个 GlobalExceptionHandler

![image-20230322114825927](http://qiniu.user-center.icu/img/image-20230322114825927.png)

7. GlobalExceptionHandler 的内容

```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    @ExceptionHandler(BusinessException.class)
    public BaseResponse businessExceptionHandler(BusinessException e) {
        log.error("businessException:" + e.getDescription(), e);
        return ResultUtil.error(e.getCode(), e.getMessage(), e.getDescription());
    }

    @ExceptionHandler(RuntimeException.class)
    public BaseResponse runtimeExceptionHandler(BusinessException e) {
        log.error("runtimeException:", e);
        return ResultUtil.error(ErrorCode.SYSTEM_ERROR, e.getMessage(), "");
    }

}
```

8. 再次测试一下

测试成功，前端收到了后端我们自己定义的状态码

![image-20230324092315929](http://qiniu.user-center.icu/img/image-20230324092315929.png)

### 七、前端代码优化

#### 1. 给前端定义通用返回对象

1. 添加通用返回类

![image-20230324092751207](http://qiniu.user-center.icu/img/image-20230324092751207.png)

2. 给 register 的响应类型封装一下

![image-20230324092908844](http://qiniu.user-center.icu/img/image-20230324092908844.png)

3. 修改一下注册的逻辑，使其与后端适配一下

![image-20230324094645644](http://qiniu.user-center.icu/img/image-20230324094645644.png)

![image-20230324094620186](http://qiniu.user-center.icu/img/image-20230324094620186.png)

4. 将全部的 API 都进行封装

![image-20230324094759874](http://qiniu.user-center.icu/img/image-20230324094759874.png)

![image-20230324094820800](http://qiniu.user-center.icu/img/image-20230324094820800.png)

![image-20230324095000180](http://qiniu.user-center.icu/img/image-20230324095000180.png)

对应的逻辑也进行一下修改

#### 2. 响应拦截器

1. 编写一个响应拦截器

```java
  requestConfig.responseInterceptors = [
    async function (response: Response, option: RequestOptionsInit): Response
    | Promise<Response> {
      const data = await  response.clone().json();
      console.log('全局响应拦截器', data);
    }
  ]
```

![image-20230324103921921](http://qiniu.user-center.icu/img/image-20230324103921921.png)

2. 测试一下，看看刚刚写的响应拦截器是否起作用

![image-20230324110816028](http://qiniu.user-center.icu/img/image-20230324110816028.png)

3. 它直接得到了后端传过来的真实的值，我们现在要把所有接口中的 data 数据取出来

```tsx
requestConfig.responseInterceptors = [
  async function (response: Response, option: RequestOptionsInit): Response
    | Promise<Response> {
    const res = await  response.clone().json();
    if (res.code === 0) {
      return res.data;
    }
  }
]
```

![image-20230324111116969](http://qiniu.user-center.icu/img/image-20230324111116969.png)

> 如果它等于 0 就表示响应成功，响应成功后，直接 return res.data
>
> 这样的话前端不用做任何修改，之前我们把注册手动判断 res.code = 0，判断 data 是否为 0，现在的话直接取出来的就是 data

4. 修改注册的逻辑代码

![image-20230324111444929](http://qiniu.user-center.icu/img/image-20230324111444929.png)

**注意**：

> request.ts 属于 .umi，它是这个框架自带帮我们生成的文件，它不是我们自己的，有可能会被覆盖掉
>
> 在 .gitignore 添加上 .umi，让这个编辑器帮我们识别出来，它就是项目自动生成的文件

![image-20230324111708521](http://qiniu.user-center.icu/img/image-20230324111708521.png)

#### 3. 写一个请求类，覆盖默认的 request 方法

1. 在 src 文件夹下新建一个 plugins 文件夹

![image-20230324111910375](http://qiniu.user-center.icu/img/image-20230324111910375.png)

2. 在 plugins 文件夹下新建 globalRequest.ts

![image-20230324112022272](http://qiniu.user-center.icu/img/image-20230324112022272.png)

3. 在 globalRequest.ts 中填写以下内容

```tsx
/**
 * request 网络请求工具
 * 更详细的 api 文档: https://github.com/umijs/umi-request
 */
import {extend} from 'umi-request';

/**
 * 配置request请求时的默认参数
 */
const request = extend({
  credentials: 'include', // 默认请求是否带上cookie
  // requestType: 'form',
});

/**
 * 所以请求拦截器
 */
request.interceptors.request.use((url, options): any => {
  console.log('do request url = ${url}');
  return {
    url,
    options: {
      ...options,
      headers: {
      },
    },
  };
});

/**
 * 所有响应拦截器
 */
request.interceptors.response.use(async (response, options): Promise<any> => {

  const data = await response.clone().json();

  return response;
});

export default request;
```

4. 前端请求接收到一个响应之后，我们先获取到这个相应的 data 值，然后从这个 data 中判断一下

![image-20230324120421675](http://qiniu.user-center.icu/img/image-20230324120421675.png)

5. 在 api.ts 中引入我们自己写的

![image-20230324120516014](http://qiniu.user-center.icu/img/image-20230324120516014.png)

6. 测试注册

可以看到已经可以正常的抛出错误了

![image-20230324120618304](http://qiniu.user-center.icu/img/image-20230324120618304.png)

7. 测试登录

正常提示

![image-20230324120736735](http://qiniu.user-center.icu/img/image-20230324120736735.png)

8. 测试退出后访问管理页面

先进入管理页面并复制地址栏的 url：http://localhost:8000/admin/user-manage?current=1&pageSize=5

退出登录后直接访问该地址

正常提示，要先登录

![image-20230324120907690](http://qiniu.user-center.icu/img/image-20230324120907690.png)

同时返回了 40100 状态码

![image-20230324120951401](http://qiniu.user-center.icu/img/image-20230324120951401.png)



## 项目部署

### 一、多环境

> 本地开发：localhost
>
> 多环境：指同一套项目代码在不同的阶段需要根据实际情况来调整配置并且部署到不同的机器上

**为什么需要？**

1. 每个环境互不影响
2. 区分不同的阶段：开发、测试、生产
3. 对项目进行优化：
   1. 本地日志几倍
   2. 精简依赖，节省项目体积
   3. 项目的环境、参数可以调整，比如 JVM 参数

针对不同的环境可以做不同的时期

### 二、多环境分类

> 1. 本都环境（自己的电脑）localhost
> 2. 开发环境（远程开发）大家连同一台机器，为了大家开发方便
> 3. 测试环境（测试）开发 / 测试 / 产品，单元测试 / 性能测试 / 功能测试 / 系统集成测试，独立的数据库、独立的服务器
> 4. 预发布环境（体验服）：和正式环境一致，正式数据库，更严谨，查出更多问题
> 5. 正式环境（线上，公开对外访问的项目）：尽量不要改动，保证上线前的代码是 ”完美“ 运行的
> 6. 沙箱环境（实验环境）：为了做实验

### 三、前端多环境实战

#### 1. 开发环境和本地环境

随便测试一下，可以看到前端请求地址是 localhost:8080

![image-20230324135949531](http://qiniu.user-center.icu/img/image-20230324135949531.png)

**localhost 是本机，那正式把项目上线之后还能继续用 localhost 吗**

> 在请求一个网页资源的时候，首先把这些网站文件，拿到自己的浏览器里，之后，如果说这个网页还需要依赖什么文件，我们都是从自己的电脑上发出请求，所以这个 localhost，其实请求的是我们自己的电脑。
>
> 那么我们之后要把后端要部署上线。那么我们自己电脑，肯定不能 24 小时开着，所以这个地址肯定要修改一下。

| 请求地址 |                |
| -------- | -------------- |
| 开发环境 | localhost:8000 |
| 线上环境 | 自己备案的域名 |

问题来了，怎么让前端知道什么时候该请求 localhost，什么时候该请求远程地址呢？

> 我们可以在启动项目的时候，或者说再构建项目的时候，把这个环境变量写进去，通过传入一个变量来区分环境

2. 举个栗子

> 现在的问题是怎么把这个参数传进入，回想一下前端启动项目的时候是怎么启动的？是在 `package.json` 里启动的，这里定义了一系列的命令，我们能不能在执行命令的时候给这个前端项目传递一些参数？肯定是可以的

#### 2. 本地测试

1. 项目用的是 umi 框架，build 时会自动传入 NODE_ENV == production 参数，start 时 NODE_ENV 参数为 development

![image-20230324143004454](http://qiniu.user-center.icu/img/image-20230324143004454.png)

2. 来到 `app.tsx`，里面有个 `process.env.NODE_ENV`

> 前端项目就是通过这个 `process.env.NODE_ENV` 拿到了我们去打包时的参数，去用 npm 命令启动项目的时候传入的一些参数，我们通过 NODE_ENV 这样一个对象去取出这个 NODE_ENV 字段，就可以通过这样的一个参数来判断出项目的本地启动还是线上启动

![image-20230324143053823](http://qiniu.user-center.icu/img/image-20230324143053823.png)

3. 验证一下

直接 alert 一下

![image-20230324144317222](http://qiniu.user-center.icu/img/image-20230324144317222.png)

4. 改成用 build 启动项目，再试一下

> build 就是构建，现在主流的前端项目基本上都是要做构建的，这个构建过程中它做了哪些事情？他就是把咱们写的代码，各种资源，JS、CS、HTML 文件，全部做一些压缩、混淆，去给它做一个编排，然后做一些删减、精简之类的，把它全部打包到一个目录里

![image-20230324150354480](http://qiniu.user-center.icu/img/image-20230324150354480.png)

| 启动方式 |                                                              |
| -------- | ------------------------------------------------------------ |
| 开发环境 | npm run start （本地启动，监听端口、自动更新）               |
| 线上环境 | npm run build （项目构建打包），可以使用 serve 工具启动 （npm -i serve） |

现在这个项目已经编译出来了这样一个 dist 目录，打开，可以看到一堆文件，这些就是把我们已经写好的可以读懂的代码转换成一些更精简，节省空间，或者说加密之类的代码。

![image-20230324150505410](http://qiniu.user-center.icu/img/image-20230324150505410.png)

![image-20230324152444223](http://qiniu.user-center.icu/img/image-20230324152444223.png)

我们现在可以在本地去运行一下这个项目：右键这个 dist 文件夹 -> open in -> terminal

![image-20230324202629812](http://qiniu.user-center.icu/img/image-20230324202629812.png)

输入 serve 启动项目

![image-20230324202813694](http://qiniu.user-center.icu/img/image-20230324202813694.png)

> 相当于在本地给你启动了一个外部服务器，可以在本地把咱们这个网页文件放到服务器上，并且给你启动起来，让你能够访问

去访问地址：http://localhost:3000/user/login，可以看到弹出的是 production

![image-20230324202959496](http://qiniu.user-center.icu/img/image-20230324202959496.png)

用 serve 启动相当于我们在自己的电脑上运行了这个正式环境，现在自己的电脑就是服务器，只不过别人访问不了而已

> 为什么输出了 production？
>
> 项目是从哪儿来的？我们是通过 package.json 的build 命令打包，得到了 dist，再用 serve 命令运行的。
>
> 也就是说，当我们运行 umi build 命令的时候，其实 umi 框架已经帮我们吧 NODE_ENV = production 传入进来了

5. 更新前端的跨域请求

现在我们的程序就能够根据这个变量来改变前端的项目行为了。比如说。我们是不是需要做到，线上的项目要请求线上的后端，找到全局请求类

> prefix 就是可以指定我们每次请求的前缀，就可以改变我们每次请求前面的这些地址，就是什么域名端口之类的。

![image-20230324204250843](http://qiniu.user-center.icu/img/image-20230324204250843.png)

我们再重新 build 一下，启动一下项目，再去访问刚刚的地址，看一下请求后端的路径

![image-20230324204628728](http://qiniu.user-center.icu/img/image-20230324204628728.png)

这个请求地址已经改变了，这里填写自己的后端域名即可，也就是说，我们通过一个变量成功的区分出了本地以及线上的项目，那么如果要加入测试环境，可以如法炮制。

#### 3. 开发环境和线上环境的区别

> 项目的配置：
>
> 不同的项目（框架）都有不同的配置文件，umi 的配置文件是 config，可以在配置文件后添加对应的环境名称后缀来区分开发环境和生产环境
>
> 比如：
>
> - 开发环境：config.dev.ts
> - 生产环境：config.prod.ts
> - 公共配置：config.ts 不带后缀

我们现在本地运行的这些代码，没有做一些压缩、加密混淆，是因为本地我们自己运行其实不用太考虑性能，但是我们要发布到线上的时候，你可能要对网站做一些什么按需加载，可能要对网站做一个静态化。

> 静态化，其实就是做了一件什么事情？它是根据页面的路由，把每个路由都给你生成一个 index.html，都给你生成一个静态文件

### 四、后端多环境实战

> 想一下后端做了什么事情，是不是就是提供了用户的增删改查、登录注册。
>
> 那用户的增删改查的数据是存在本地的 mysql 数据库，上线的时候，是不是要把这个数据库地址改成一个远程的地址，起码要公网可访问，或者说自己前端/后端项目部署的那个服务器能访问

后端多环境主要是改：

> - 依赖的环境地址
>   - 数据库地址
>   - 缓存地址
>   - 消息队列地址
>   - 项目端口号
> - 服务器配置

#### 1. 后端怎么去区分不同的环境？

> 这种模式就跟前端是一样的，基本上所有的项目都是这种模式：通过在配置文件后面加一个猴嘴来区分环境，那后端项目也一样

后端的 springboot 项目，通过 application.yml（配置文件）添加不同的后缀来区分配置文件

1. 复制 `application.yml`，粘贴到 `resources` 包下，重命名为 `application-prod.yml`

![image-20230325092613041](http://qiniu.user-center.icu/img/image-20230325092613041.png)

> `application.yml` 就是公共的配置，公共配置就是任何环境它都会加载这个配置，所以像一些 mybatis-plus 这种框架层面的，任何环境都一样的配置，就写在公共配置类里面就好了

2. 在做后台开发的时候，要做这样一件事情，就是把每次建好的数据库的创建表的语句全部保存下来，可以写到文档里，也可以写到自己的本地。

![image-20230325102932802](http://qiniu.user-center.icu/img/image-20230325102932802.png)

3. 在 `user-center` 包下新建 sql 包，在 sql 包下创建 `create_table.sql` 文件

![image-20230325103119216](http://qiniu.user-center.icu/img/image-20230325103119216.png)

> 将建表语句放到项目目录中，前提是这个语句是可以给其他人看的，或者是给团队、开源数据的话，可以给别人看

### 附加：在云服务器上安装配置mysql

#### a. 访问服务器官网

公网ip最好不要泄露，容易遭受攻击

![image-20230325105717456](http://qiniu.user-center.icu/img/image-20230325105717456.png)

#### b. 重置密码

1. 找到重置密码

![image-20230325105900883](http://qiniu.user-center.icu/img/image-20230325105900883.png)

2. 重置密码会强制关机，等一会它就重启成功了

![image-20230325110242503](http://qiniu.user-center.icu/img/image-20230325110242503.png)

3. 可以使用 putty、xshell、MobaXterm 等远程软件进行连接

| 服务器信息       |                    |
| ---------------- | ------------------ |
| 实例规格         | CPU：2核 内存：2核 |
| 系统盘           | 40GB SSD云硬盘     |
| 流量包           | 300GB/月           |
| 公网IP           | x.x.x.x            |
| 远程连接登录名   | root               |
| 远程连接登录密码 | xxxx               |
| 系统镜像         | CentOS7.6          |
| mysql用户名      | xxx                |
| mysql用户密码    | xxxxxx             |

#### c. 创建快照

1. 我们创建一个快照，方便后续回滚练习

![image-20230325110826297](http://qiniu.user-center.icu/img/image-20230325110826297.png)

2. 免费的快照最多创建两个，超过两个就要收费了

![image-20230325111730440](http://qiniu.user-center.icu/img/image-20230325111730440.png)

#### d. 远程工具连接云服务器

1. 使用 xshell 连接服务器

![image-20230325111937244](http://qiniu.user-center.icu/img/image-20230325111937244.png)

![image-20230325112551824](http://qiniu.user-center.icu/img/image-20230325112551824.png)

#### e. MySql安装

1. 安装 `mysql`

```shell
yum install mysql
```

![image-20230325113012460](http://qiniu.user-center.icu/img/image-20230325113012460.png)

遇到这里输入 y，回车

![image-20230325113210880](http://qiniu.user-center.icu/img/image-20230325113210880.png)

显示 succeeded，说明安装成功

2. 安装 `myslq-devel`

```shell
yum install mysql-devel
```

![image-20230325113347211](http://qiniu.user-center.icu/img/image-20230325113347211.png)

输入 y，回车

![image-20230325113423931](http://qiniu.user-center.icu/img/image-20230325113423931.png)

安装成功

3. 安装 `mysql-server`

```shell
yum install mysql-server
```

![image-20230325113732514](http://qiniu.user-center.icu/img/image-20230325113732514.png)

安装失败

【原因】

> CentOS 7 版本将 myslq 数据软件从默认的程序列表中移除，用 mariadb 代替了

【解决方案】

**方法一**：安装 mariadb

> mariadb 数据库管理系统是 mysql 的一个分支，主要由开源社区维护，采用 gpl 授权许可。开发这个分支的原因之一是：甲骨文公司收购了 mysql 后，有将 mysql 闭源的风险，因此社区采用分支的方式来避开这个风险。 mariadb 的目的是完全兼容 mysql，包括 api 和命令行，使之能轻松的称为 mysql 的代替品

安装 `mariadb`，大小 59 M

```shell
yum install mariadb-server mariadb
```

![image-20230325114349102](http://qiniu.user-center.icu/img/image-20230325114349102.png)

输入 y，回车

![image-20230325114411076](http://qiniu.user-center.icu/img/image-20230325114411076.png)

安装完成

`mariadb`数据库的相关命令是

```shell
systemctl start mariadb	//启动
systemctl stop mariadb //停止
systemctl resatart mariadb //重启
systemctl enable mariadb //设置开机启动
```

先启动数据库

```shell
systemctl start mariadb
```

第一次的时候是不需要密码的，直接输入 `mysql` 就可以进入了

![image-20230325115004291](http://qiniu.user-center.icu/img/image-20230325115004291.png)

安装 mariadb 后，显示的也是 MariaDB[(none)] >，看起来很不习惯...

**方法二**：官网下载安装 mysql-server（遇到选择就输入 y ）

```
wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm
rpm -ivh mysql-community-release-el7-55.noarch.rpm
yum install mysql-community-server
```

![image-20230325122154431](http://qiniu.user-center.icu/img/image-20230325122154431.png)

![image-20230325122443026](http://qiniu.user-center.icu/img/image-20230325122443026.png)

![image-20230325122623714](http://qiniu.user-center.icu/img/image-20230325122623714.png)

（1）安装成功后启动 mysql 服务

```shell
systemctl start mysqld
```

（2）设置 mysql 服务开机自启动

```shell
systemctl enable mysqld
```

（3）mysql 数据库的相关命令

```shell
systemctl disable mysqld	//停止mysql开机自启动
systemctl status mysqld		//查看当前服务状态
systemctl restart mysqld	//重启服务
systemctl stop mysqld		//停止服务
```

**为了安全期间，在远程连接的时候，最好不要使用root账号，但是root账号的密码还是要设置一下的**

> 别人写个轮询，按IP号段遍历过去 端口3306  账号密码 root/root  root/123456  尝试链接，连上哪个算哪个，连不上下个IP继续，就看谁家不锁门。
>
> [恶人表，没了 (qq.com)](https://mp.weixin.qq.com/s/VHAEerEssmO4BB7gveXaMg)
>
> 所以，mysql的用户名和密码最好不要设置相同或者是123456（为了安全起见）

（4）初次安装mysql，root账号没有密码

![image-20230325193633887](http://qiniu.user-center.icu/img/image-20230325193633887.png)

（5）设置密码

```shell
set password for 'root'@'localhost' = password('xxxxxx');
```

如果出现以下错误：

```mysql
ERROR 1558 (HY000): Column count of mysql.user is wrong. Expected 43, found 42. Created with MySQL 50568, now running 50651. Please use mysql_upgrade to fix this error.
```

说明是系统自带的 mysql 的版本需要更新

退出mysql，输入以下命令

```
mysql_upgrade
```

新建一个用户，并设置密码

```mysql
create user 'fickler'@'%' identified by 'xxxxxx'
```

刷新权限使操作生效

```mysql
FLUSH PRIVILEGES;
```

（6）远程连接设置

把在数据库的所有表的所有权限赋值给位于所有IP的fickler用户

```mysql
grant all privileges on *.* to 'fickler'@'%' with grant option;
```

#### f. 防火墙开发3306端口

```shell
firewall-cmd --zone=public --add-port=3306/tcp --permanent
```

如果显示

```
FirewallD is not running
```

说明，防火墙关闭中，开启防火墙就行了

开启防火墙

```shell
systemctl start firewalld.service
```

开发3306端口

```shell
firewall-cmd --zone=public --add-port=3306/tcp --permanent
```

防火墙重新加载配置

```shell
firewall-cmd --reload
```

查看开放的端口

```shell
firewall-cmd --list-ports
```

#### g. 配置mysql默认编码为utf-8

修改 `/etc/my.cnf` 配置文件，在 [mysqld] 下添加编码配置

```shell
vim /etc/my.cnf
[mysqld]
character_set_server=utf8
init_connect='SET NAMES utf8'
```

重启mysql

```shell
systemctl restart mysqld
```

登录fickler用户查看编码

> 如果登录时出现错误，请看一下这篇文章：[mysql全局权限账户%无法登录如何解决_在人间负债^的博客-CSDN博客](https://blog.csdn.net/qq_52354698/article/details/129773384?spm=1001.2014.3001.5501)

![image-20230326115553440](http://qiniu.user-center.icu/img/image-20230326115553440.png)

#### h. 云服务器放行3306端口（不然项目无法获取到云服务器的mysql）

![image-20230326115744778](http://qiniu.user-center.icu/img/image-20230326115744778.png)

测试远程连接

![image-20230326115933763](http://qiniu.user-center.icu/img/image-20230326115933763.png)

连接成功后，出现一个新的数据库

![image-20230326120234080](http://qiniu.user-center.icu/img/image-20230326120234080.png)

#### 2.idea连接线上数据库后的布置

1. 进入控制台，新建一个 user_center 数据库

![image-20230326132949899](http://qiniu.user-center.icu/img/image-20230326132949899.png)

2. 切换到 user_center 数据库

![image-20230326133154701](http://qiniu.user-center.icu/img/image-20230326133154701.png)

3. 在 user_center 数据库下将之前的建表语句粘贴进去，运行![image-20230326133346138](http://qiniu.user-center.icu/img/image-20230326133346138.png)

4. 修改一下线上的配置

![image-20230326134012729](http://qiniu.user-center.icu/img/image-20230326134012729.png)

5. 测试一下，在本地运行生产环境的项目

将 springboot 项目打包成一个 jar 包，右键 maven -> Lifecycle -> package

![image-20230326134458042](http://qiniu.user-center.icu/img/image-20230326134458042.png)

报了一个错，这个是单元测试没有通过，这里先不用管，直接跳过就行

![image-20230326134810412](http://qiniu.user-center.icu/img/image-20230326134810412.png)

点击小闪电图标，跳过单元测试，然后再双击 package

![image-20230326134907734](http://qiniu.user-center.icu/img/image-20230326134907734.png)

target 包下出现构建好的 jar 包

![image-20230326134950061](http://qiniu.user-center.icu/img/image-20230326134950061.png)

快速进入终端

![image-20230326135237887](http://qiniu.user-center.icu/img/image-20230326135237887.png)

运行 jar 包，并传入一个参数

```shell
java -jar .\user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod
```

![image-20230326135921938](http://qiniu.user-center.icu/img/image-20230326135921938.png)

启动一下前端项目，注册一个用户，看一下是否可以注册成功

![image-20230326221341461](http://qiniu.user-center.icu/img/image-20230326221341461.png)

![image-20230326221439984](http://qiniu.user-center.icu/img/image-20230326221439984.png)



### 五、项目部署

#### 1. 原始部署

##### **（1）部署前端**

需要 web 服务器：nginx、apache、tomcat

1. 安装 nginx 服务器

> 1. 用系统自带的软件包管理器快速安装，比如 centos 的 yum
> 2. 自己到官网安装

2. 进入到 nginx 官网，选择 download（下载）

![image-20230326221952626](http://qiniu.user-center.icu/img/image-20230326221952626.png)

3. 下载稳定版本，右键复制链接地址

![image-20230326222104077](http://qiniu.user-center.icu/img/image-20230326222104077.png)

​	[nginx-1.22.1](http://nginx.org/download/nginx-1.22.1.tar.gz)

4. 我们在服务器下新建一个 `services` 目录，用来存放所有项目的依赖和安装包

```shell
mkdir services
```

将之前的 mysql 安装包移动到 services 目录下

```shell
mv mysql-community-release-el7-5.noarch.rpm /root/services/
```

5. 把 nginx 安装包下载下来，并改名为 `nginx-1.20.2.tar.gz`

```shell
curl -o nginx-1.20.2.tar.gz http://nginx.org/download/nginx-1.22.1.tar.gz
```

![image-20230326223013606](http://qiniu.user-center.icu/img/image-20230326223013606.png)

6. 解压 nginx

```shell
tar -zxvf nginx-1.20.2.tar.gz
```

7. 进入到 nginx，并安装相关的依赖

```shell
cd nginx-1.22.1/
yum install pcre pcre-devel -y
yum install openssl openssl-devel -y
```

8. 设置系统配置参数

```shell
./configure --with-http_ssl_module --with-http_v2_module --with-stream
```

9. 开始编译

```shell
make
```

10. 安装

```shell
make install
```

11. 现在命令行输入 nginx，会报错，说找不到命令，需要加入环境变量

```shell
vim /etc/profile
export PATH=$PATH:/usr/local/nginx/sbin
source /etc/profile
```

12. 查看当前所有 tcp 端口/查看启动情况

![image-20230326231858503](http://qiniu.user-center.icu/img/image-20230326231858503.png)

13. 复制 nginx.conf 配置文件，并重命名为 nginx.default.conf

```shell
cp nginx.conf nginx.default.conf
```

14. 前端 build 一下，打包

![image-20230326224615566](http://qiniu.user-center.icu/img/image-20230326224615566.png)

15. 将打包好的 dist 文件包上传到 services 文件夹里面

![image-20230326225149506](http://qiniu.user-center.icu/img/image-20230326225149506.png)

16. 将 dist 改名为 user-center-front，现在咱们所有的前端项目的代码都已经上传到服务器上了

```shell
cd user-center-front/
```

17. 修改配置文件，设置启动用户和前端项目所在路径

```shell
vim nginx.conf
```

![image-20230326232310274](http://qiniu.user-center.icu/img/image-20230326232310274.png)

![image-20230326232423082](http://qiniu.user-center.icu/img/image-20230326232423082.png)

18. 更新配置

```shell
nginx -s reload
```

19. 可以访问公网 ip 地址了，会出现 nginx 页面（访问前要在云服务器网站开放80端口，并且要在防火墙手动增加80端口）

```shell
firewall-cmd --zone=public --add-port=80/tcp --permanent
// 防火墙重新加载配置
firewall-cmd --reload
// 查看开发的端口
firewall-cmd --list-ports
```

20. 使用服务的公网IP地址去访问一下页面

![image-20230327103439829](http://qiniu.user-center.icu/img/image-20230327103439829.png)

OK~前端部署完毕！✿✿ヽ(°▽°)ノ✿

##### （2）后端部署

1. java 安装

```shell
yum install -y java-1.8.0-openjdk*
// yum安装不用配置环境变量，它直接帮我们安装好了
// 查看java版本，安装成功
java -version
```

2. 安装 maven

```shell
curl -o apache-maven-3.9.1-bin.tar.gz https://dlcdn.apache.org/maven/maven-3/3.9.1/binaries/apache-maven-3.9.1-bin.tar.gz
// 解压
tar -zxvf apache-maven-3.9.1-bin.tar.gz
```

3. 进入到 maven

```shell
cd apache-maven-3.9.1/
ls
m2.conf  mvn  mvn.cmd  mvnDebug  mvnDebug.cmd  mvnyjp
// 这里的 mvn 是 maven 的可执行文件，我们就是用这个文件去构建项目
```

4. 添加环境变量

```shell
vim /etc/profile
// 是文件生效
source /etc/profile
```

![image-20230327110543894](http://qiniu.user-center.icu/img/image-20230327110543894.png)

5. 看看环境变量配置是否成功，查看 maven 版本

```shell
mvn -v
```

![image-20230327110658433](http://qiniu.user-center.icu/img/image-20230327110658433.png)

6. 我们可以直接将代码拉倒服务器上，然后用 maven 编译，或者直接将之前编译好的 .jar 文件上传到服务器上

![image-20230327111622412](http://qiniu.user-center.icu/img/image-20230327111622412.png)

7. 执行

```shell
java -jar ./user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod
```

![image-20230327111935521](http://qiniu.user-center.icu/img/image-20230327111935521.png)

停止，让它在后台运行

```shell
nohup java -jar ./user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod &
```

![image-20230327112522437](http://qiniu.user-center.icu/img/image-20230327112522437.png)

8. 使用公网访问以下，看看是否可以访问的通

![image-20230327144315948](http://qiniu.user-center.icu/img/image-20230327144315948.png)

#### 2. 宝塔部署

> OK！重置服务器...🐶
>
> 宝塔只是一个 Linux 运维面板，方便管理服务器、方便安装软件

1. 选择重装系统

![image-20230327145054214](http://qiniu.user-center.icu/img/image-20230327145054214.png)

2. 放行端口

开放端口也可以限制IP地址，让只有本机可以访问到自己服务器的宝塔面板

![image-20230327145419483](http://qiniu.user-center.icu/img/image-20230327145419483.png)

3. 进入宝塔面板

![image-20230327145514242](http://qiniu.user-center.icu/img/image-20230327145514242.png)

4. 根据提示获取用户名和密码

![image-20230327145554847](http://qiniu.user-center.icu/img/image-20230327145554847.png)

![image-20230327145658165](http://qiniu.user-center.icu/img/image-20230327145658165.png)

5. 首次登录后要绑定手机号

![image-20230327145823115](http://qiniu.user-center.icu/img/image-20230327145823115.png)

6. 然后去面板设置，改下登录账号和密码

![image-20230327150646356](http://qiniu.user-center.icu/img/image-20230327150646356.png)

7. 现在利用宝塔快速安装需要的前后端软件

![image-20230327151334847](http://qiniu.user-center.icu/img/image-20230327151334847.png)

![image-20230327151510344](http://qiniu.user-center.icu/img/image-20230327151510344.png)

8. 在宝塔面板中添加站点

![image-20230328080650365](http://qiniu.user-center.icu/img/image-20230328080650365.png)

9. 进入站点的目录

![image-20230328080724858](http://qiniu.user-center.icu/img/image-20230328080724858.png)

10. 将默认的文件删掉

![image-20230328080812213](http://qiniu.user-center.icu/img/image-20230328080812213.png)

11. 但是有一个 PHP 文件删不掉，不用管它，那是它自己强制的一个设置

![image-20230328080957004](http://qiniu.user-center.icu/img/image-20230328080957004.png)

12. 然后直接将前端打包好的 dist 文件夹内的文件拖进去

![image-20230328081152276](http://qiniu.user-center.icu/img/image-20230328081152276.png)

![image-20230328081222129](http://qiniu.user-center.icu/img/image-20230328081222129.png)

13. 上传完毕后就可以直接在地址栏通过访问公网IP来访问项目了

![image-20230328081343827](http://qiniu.user-center.icu/img/image-20230328081343827.png)

14. 在 wwwroot 目录下新建一个 user-center-backend 文件夹

![image-20230328081648816](http://qiniu.user-center.icu/img/image-20230328081648816.png)

![image-20230328081734071](http://qiniu.user-center.icu/img/image-20230328081734071.png)

15. 进入这个目录，将之前后端打包好的 .jar 文件上传

![image-20230328081845789](http://qiniu.user-center.icu/img/image-20230328081845789.png)

16. 复制该路径`/www/wwwroot/user-center-backed`

先把 tomcat 停掉，不然用不了 8080 端口（装tomcat只是为了装java🐶）

![image-20230328082153373](http://qiniu.user-center.icu/img/image-20230328082153373.png)

![image-20230328082207188](http://qiniu.user-center.icu/img/image-20230328082207188.png)

17. 在网站里添加一个 java 项目

![image-20230328082348400](http://qiniu.user-center.icu/img/image-20230328082348400.png)

![image-20230328082559296](http://qiniu.user-center.icu/img/image-20230328082559296.png)

18. 添加成功，显示在运行中了

![image-20230328090154672](http://qiniu.user-center.icu/img/image-20230328090154672.png)

19. 去防火墙将 8080 端口放行

![image-20230328090257650](http://qiniu.user-center.icu/img/image-20230328090257650.png)

20. 现在访问一下公网+:8080端口

![image-20230328090413768](http://qiniu.user-center.icu/img/image-20230328090413768.png)

#### 3.Docker部署

> 公司绝大多数的项目都是用容器。它有一个好处，整个项目的环境，以及项目所用到的代码，我们刚刚手动安装的软件、上传代码，现在这些软件和代码都可以封装到一个镜像里面，就像我们的操作系统一样。
>
> 之后如果需要启动这个项目，直接启动这个镜像，把这个镜像拿来启动一下，就不需要去反复执行命令去安装了。
>
> docker 是容器，可以将项目的环境（比如java，nginx）和项目代码一起打包成镜像，所有人都能下载镜像，更容易分发和移植。
>
> 再启动项目时，不需要敲一大堆命令，而是直接下载镜像，启动就可以了。
>
> docker 可以理解为软件包。

1. 在宝塔上安装 docker

![image-20230328091347013](http://qiniu.user-center.icu/img/image-20230328091347013.png)

![image-20230328091531186](http://qiniu.user-center.icu/img/image-20230328091531186.png)

2. 安装完成后去查看一下是否安装成功

![image-20230328091941755](http://qiniu.user-center.icu/img/image-20230328091941755.png)

> 怎么将前后端项目制作成镜像，肯定是需要一个文件来定义，就我们把咱们的前端项目的依赖、启动流程，全部写到一个文件里面，这文件就叫 Dockerfile。

> Dockerfile 用于指定构建 Docker 镜像的方法
>
> Dockerfile 一般不需要完全从 0 开始写，建议去 github、gitee 参考同类的项目

这里直接复制鱼皮的

> Dockerfile 编写：
>
> - FROM 依赖的基础镜像
> - WORKDIR 工作目录
> - COPY 从本机复制文件
> - RUN 执行命令
> - CMD / ENTRYPOINT （附加额外参数）指定运行容器时默认执行的命令

```dockerfile
FROM maven:3.5-jdk-8-alpine as builder

# Copy local code to the container image.
WORKDIR /app
COPY pom.xml .
COPY src ./src

# Build a release artifact.
RUN mvn package -DskipTests

# Run the web service on container startup.
CMD ["java","-jar","/app/target/user-center-backend-0.0.1-SNAPSHOT.jar","--spring.profiles.active=prod"]
```

3. 新建 Dockerfile，粘贴过来

![image-20230328093527261](http://qiniu.user-center.icu/img/image-20230328093527261.png)

4. 去 `/www/wwwroot` 下，用 git 拉取后端项目

![image-20230328103222647](http://qiniu.user-center.icu/img/image-20230328103222647.png)

5. 根据 Dockerfile 构建后端镜像

```shell
docker build -t user-center-backed:v0.0.1 .
```

6. 复制鱼皮的前端的 Dockerfile 和 nginx.conf

**Dockerfile**

```dockerfile
FROM nginx

WORKDIR /usr/share/nginx/html/
USER root

COPY ./docker/nginx.conf /etc/nginx/conf.d/default.conf

COPY ./dist  /usr/share/nginx/html/

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

**nginx.conf**

```nginx
server {
    listen 80;

    # gzip config
    gzip on;
    gzip_min_length 1k;
    gzip_comp_level 9;
    gzip_types text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml;
    gzip_vary on;
    gzip_disable "MSIE [1-6]\.";

    root /usr/share/nginx/html;
    include /etc/nginx/mime.types;

    location / {
        try_files $uri /index.html;
    }

}
```

6. 在前端新建 Dockerfile，粘贴过来

![image-20230328104738079](http://qiniu.user-center.icu/img/image-20230328104738079.png)

7. 新建 docker 文件夹，在该文件夹下新建 nginx.conf，粘贴过来

![image-20230328104956398](http://qiniu.user-center.icu/img/image-20230328104956398.png)

8. git 提交完后，在拉取到 `/www/wwwroot` 文件夹下

![image-20230328105456696](http://qiniu.user-center.icu/img/image-20230328105456696.png)

9. 根据前端 dockerfile 构建前端镜像

```shell
sudo docker build -t user-center-fronted:v0.0.1 .
```

![image-20230328113120869](http://qiniu.user-center.icu/img/image-20230328113120869.png)

10. 报错了，我们直接将 dist 文件夹拖进宝塔面板

![image-20230328113350415](http://qiniu.user-center.icu/img/image-20230328113350415.png)

11. 再次构建

![image-20230328113523426](http://qiniu.user-center.icu/img/image-20230328113523426.png)

12. 查看打包好的 docker 镜像

![image-20230328114138464](http://qiniu.user-center.icu/img/image-20230328114138464.png)

13. 停掉宝塔的前后端项目，防止端口冲突

![image-20230328114226663](http://qiniu.user-center.icu/img/image-20230328114226663.png)

![image-20230328114244576](http://qiniu.user-center.icu/img/image-20230328114244576.png)

14. docker run 启动前/后端项目镜像

> 虚拟化
>
> 1. 端口映射：把本机的资源（实际访问地址）和容器内部资源（应用启动端口）进行关联
> 2. 目录映射：把本机的端口和容器应用的端口进行关联

15. 启动前端镜像

![image-20230328124135902](http://qiniu.user-center.icu/img/image-20230328124135902.png)

16. 关闭 nginx 服务器

虽然我们将网站关闭了，但是 nginx 服务器依旧占用这 80 端口，所以我们要将 nginx 服务器也关闭

![image-20230328124333070](http://qiniu.user-center.icu/img/image-20230328124333070.png)

17. 再次启动前端镜像，并用 `netstat -ntlp` 查看端口

![image-20230328124449785](http://qiniu.user-center.icu/img/image-20230328124449785.png)

18. 访问公网 ip

![image-20230328124547423](http://qiniu.user-center.icu/img/image-20230328124547423.png)

19. 查看日志

![image-20230328124710154](http://qiniu.user-center.icu/img/image-20230328124710154.png)

很明显，这样查看日志，只能查看一次

![image-20230328124738274](http://qiniu.user-center.icu/img/image-20230328124738274.png)

20. 持续输出日志

```shell
docker logs 容器ID -f
```

![image-20230328125024412](http://qiniu.user-center.icu/img/image-20230328125024412.png)

> 如果镜像太多，占用空间，我们怎么将不需要的镜像删掉呢？
>
> ```shell
> docker rmi -f 镜像ID
> ```

21. 启动后端项目镜像

```shell
docker run -p 8080:8080 user-center-backed:v0.0.1
```

![image-20230328125416803](http://qiniu.user-center.icu/img/image-20230328125416803.png)

22. 访问公网IP

![image-20230328125502069](http://qiniu.user-center.icu/img/image-20230328125502069.png)



#### 4. Docker平台部署

> 现在我们已经学会使用 docker 来部署一个项目了，但是每次我们依旧需要去输入命令，有点麻烦，再想一种简单的方式，那就是我们不需要买服务器，蹭别人的容器当平台，相当于别人给我们提供服务器，我们只需要将 docker 容器搭建好，然后去交给它们运行就好了

**有哪些容器平台？**

1. 云服务商的容器平台（腾讯云、阿里云）
2. 面向某个领域的容器平台（前端、后端微信云托管）

**容器平台的好处**

1. 不需要输入命令来操作，更加方便省事
2. 不用在控制台操作，更加傻瓜式，更简单
3. 大厂运维，比自己运维更省心
4. 额外的能力，比如监控、告警、其他（存储、负载均衡、自动扩容缩容、流水线）

## 项目上线

### 附加：域名

#### a. 域名的简单介绍

> 在 Internet 上有千百万台主机，为了区分这些主机，每一台主机都会被分配一个 IP 地址，但由于 IP 地址没有实际意义难于记忆，于是就有了域名（Domain Name）。而获得域名的方式是通过付费获得域名一年或多年内的使用权，我们称之为**域名注册！**

![image-20230328130815454](http://qiniu.user-center.icu/img/image-20230328130815454.png)

> 域名对于大部分的人来说就是网站的网址，每个域名背后都对应一个服务器的IP地址，虽然每次访问网站都要输入域名，但其实都是通过访问这个域名对应的 IP 地址的网址服务器来打开的。
>
> ![image-20230328131200618](http://qiniu.user-center.icu/img/image-20230328131200618.png)
>
> ![image-20230328131241286](http://qiniu.user-center.icu/img/image-20230328131241286.png)

![image-20230328131343401](http://qiniu.user-center.icu/img/image-20230328131343401.png)

#### b. 购买域名

> 其实准确来说是租的，一般类说，每个人都要去域名注册商那里购买自己喜欢的域名，域名都是以年为时间为单位来购买，和租的差不多，同时域名也支持转手卖，因为域名具有唯一性。
>
> 国内一般买域名就是阿里云和腾讯云，国外买域名的网站有很多，流程都很相似。

在国内，域名注册必须要经历四个步骤

![image-20230328131620748](http://qiniu.user-center.icu/img/image-20230328131620748.png)

以腾讯云做演示，打开腾讯云 -> 产品 -> 域名注册

![image-20230328132159809](http://qiniu.user-center.icu/img/image-20230328132159809.png)

> 一般一级域名的命令，不是所有字符都可以使用，只有三类字符是允许的
>
> - 26个英文字母
> - 0-9这十个数字
> - - 这个文件连字符

> 大部分人都是用纯英文或者单词拼写简写这样组合的方式，因为更容易记忆，比如输入 helloweb.com, 就会看到所有相关的域名信息、其他顶级域名下的一级域名，不同的顶级域名价格都是不一样的，域名- -次最多 买十年(租十年)。
> 在现实生活中，很多域名都是按自己或者企业的个人喜好来使用的，域名的分类只是一个分类，并环代表-定要按它的分类或者 含义来使用，你想怎么用，完全取决于你自己。

**小知识**

> 就像 IO（Indian Ocean）这个域名，它本身的意义是英国英属印度洋领地在互联网域名系统中拥有的国家及地区的顶级域名
> 但是由于在计算机科学领域，IO 常被作为IO（Input Output）输入和输出的缩写，使得 IO 这个域名很适合与技术相关的服务(使用)
> IO 域名也可以作为 Internet Organization，也就是互联网组织的缩写,因此该顶级域名也十分受初创公司和IT公司的欢迎，经常被用作开源项目的网站或API、-些在线的服务(网站)使用。

> 如果在域名查找列表里 要选择买域名的时候,有些域名会注明不能备案，就不用考虑了
> 如果注明是某个地区，不能备案，就要看自己的情况，个人的话，根据你的身份证所在的那个省备案；公司的话,就是公司注册地为准。
> 你会发现有些顶级域名，腾讯云或其他国内的域名注册商那里没有， 比如 IO 顶级域名，可以去国外的域名注册商那里看一下，但是一般这样的域名没有办法通过国内的备案，会影响在国内的使用。

![image-20230328132735395](http://qiniu.user-center.icu/img/image-20230328132735395.png)

点击域名价格，可以筛选便宜的域名

![image-20230328132852490](http://qiniu.user-center.icu/img/image-20230328132852490.png)

输入你想要的域名

![image-20230328132916329](http://qiniu.user-center.icu/img/image-20230328132916329.png)

点击添加

![image-20230328132937928](http://qiniu.user-center.icu/img/image-20230328132937928.png)

会被加入右侧的选购清单，点击立即购买

![image-20230328133019728](http://qiniu.user-center.icu/img/image-20230328133019728.png)

**购买域名需要实名认证**

现在我们要把买好的域名备案一下，基本上所有的正规的云服务提供商，都有备案服务，如果实名认证时间未满 72 小时在备案的时候会弹出

![image-20230328133321892](http://qiniu.user-center.icu/img/image-20230328133321892.png)

> 备案是我们国内对网络（网站）进行管理的一种机制，就是向有关部门门提交域名使用的人员或公司的实名信息，比如说这个域名主要用来做什么的、负责人的联系方式是什么等等，只有备案的域名，才能被正常的DNS解析（才能被正常访问）。如果你的域名使用的DNS解析服务器是国外的，那也可以不备案。
> 当然不建议这么做，因为毕竟备案了以后，会少很多的麻烦，在国内很多网络服务,如果要使用域名，都会要求该域名已经备案，网站就更不用说了。

传统的备案方式会比较麻烦，整个周期大概 20-30 天，腾讯云可以通过小程序进行备案

![image-20230328133539557](http://qiniu.user-center.icu/img/image-20230328133539557.png)

![image-20230328133552866](http://qiniu.user-center.icu/img/image-20230328133552866.png)

整个备案的流程，实是我们先在服务器的提供商的备案系统里填写资料，提交 -> 腾讯云的备案人员审核-遍资料， 有问题的话会打电话和你联系，帮你修改好有问题的地方 -> 资料都正确无误之后，腾讯云会提交到相应的备案管理部门 -> 等待备案管理部门的审核就好了

> 每个省都有 自己的备案管理机构，一般来说你的身 份证地址或公司的注册地址在哪个省，就会提交到哪个省管局去备案，每个省或直辖市的省管局规则有些不太一样，个人备案和公司备案也有不同的要求

用微信扫一扫，进入腾讯云备案小程序

![image-20230328134334834](http://qiniu.user-center.icu/img/image-20230328134334834.png)

点击未登录用户登陆一下， 然后点击开始备案，根据个人情况选择主办者性质，我选的是个人，这边就不展示图片了，根据要求填写信息即可，填写完信息点击验证 -> 弹出核对框,点击下一步

![image-20230328212143509](http://qiniu.user-center.icu/img/image-20230328212143509.png)

![image-20230328212205717](http://qiniu.user-center.icu/img/image-20230328212205717.png)

就会让你填写主体信息，请注意手机号码别填错了，后续很多事情，腾讯云的备案人员都会通过你的手机号码联系到你，填写完点击确定

![image-20230328212245757](http://qiniu.user-center.icu/img/image-20230328212245757.png)

到填写**网站信息**

> 这里的网站名称就是让你给用域名的网站取个名字，这里浅灰色的文字就是关于网站起名的一些要求，只要符合这里的要求就可以随便起，这个名字只是在备案信息里面作为网站的名字进行记录,并不会在你网站的任何地方进行展示。
> 如果你不知道怎么取，就随便先取一个，因为如果你取的名字有问题，等你提交以后,腾讯云的备案小姐姐会和你联系，告诉你如何修改的。

然后网站服务内容，-般个人网站就选择其他，备注就写一些你这个网站具体是干什么用的就行，备注不知道怎么填也是随便填一下， 有问题，万能的腾讯云小姐姐会和你联系。
然后点击保存网站信息 -> 下一步

![image-20230328212439671](http://qiniu.user-center.icu/img/image-20230328212439671.png)

![image-20230328212453101](http://qiniu.user-center.icu/img/image-20230328212453101.png)

就到了上传资料，这里是提交身份证照片和录制核验的视频，就是人脸识别的实名实人认证，按照提示操作就好了

![image-20230328212621627](http://qiniu.user-center.icu/img/image-20230328212621627.png)

打完 √ 就可以点击提交

提交完成之后，备案的基本流程都已经做完了，坐等腾讯云的小姐姐审核你的资料
如果有问题她会打电话叫你怎么修改
要注意资料审核提示的电话号码，不要拒接哦，可以根据提示关注腾讯云助手,这样有什么消息也能第一-时间收到

![image-20230328212726100](http://qiniu.user-center.icu/img/image-20230328212726100.png)

> 假如你填写的资料没有问题，或者在备案人员的帮助下修改好了有问题的部分，那么腾讯云备案人员，会在审核之后,把你的备案资料提交到相应的管局。
>
> 然后你可能会收到这样一条带验证码的信息 ，主要是来验证你的手机号码,你需要在收到这条信息的24小时之内，登录信息中的核验链接地址，去验证你的手机号，不然管局会驳回你的备案申请。
>
> 驳回也不是什么严重的事情，腾讯云备案这边会帮你重新提交，但如果你想早点完成备案还是要注意一下，别遗漏了这条信息。

![image-20230328212837832](http://qiniu.user-center.icu/img/image-20230328212837832.png)

> 完成了手机号码核验，你的域名备案申请就正式的在管局那边进行审核了。然后继续等几个工作日，管局通过你的域名备案审核之后，你会收到这么一条信息， 说明你的域名备案申请已经通过了（就是你的域名已经被相应的管局完成备案了）

![image-20230328212935694](http://qiniu.user-center.icu/img/image-20230328212935694.png)

但是这条信息还会去提示你去登录全国公安机关互联网站安全管理服务平台，去办理公安备案，这是什么? - -般的正规网站底部都会有一堆这种信息

![image-20230328213015360](http://qiniu.user-center.icu/img/image-20230328213015360.png)

这个互联网ICP备案号就是我们域名在管局那边完成备案之后，管局给你的域名设定的备案编号，这个登录腾讯云的备案小程序就能看到（这账号不是我的，借个图片）

![image-20230328213058539](http://qiniu.user-center.icu/img/image-20230328213058539.png)

还有一个叫泸公安备31000xxx。这串数字号码，这个是经过公安备案获取的，如果是企业网站，公安备案最好也去备案一下；
个人网站，要看具体情况，公安备案这个网站特别古老,浏览器还得支持Flash，也不能通过云服务商平台进行代办，需要用户自己去公安备案的网站去填写一些网站域名的资料，弄起来特别麻烦。
对于个人网站，或是小型网站来说，公安备案目前还不是一个必须的要求， 所以根据自己的情况去做，如果都能备案了最好。
这里只要完成管局的备案就能继续后面的内容了

**备案通过**

穿过传送门，咻~ 备案通过( 0w0)<
腾讯云和管局会根据你填写的邮箱给你发这两份邮件

![image-20230328213411751](http://qiniu.user-center.icu/img/image-20230328213411751.png)

> 工业和信息化部网站备案系统邮件通知:是告诉你备案的编号是什么和备案通过的通知及通过的日期等等
> 腾讯云:通知你完成备案，为你准备了备案大礼包啥的，备案成功后可以做什么
>
> ![image-20230328213511914](http://qiniu.user-center.icu/img/image-20230328213511914.png)
>
> ![image-20230328213526071](http://qiniu.user-center.icu/img/image-20230328213526071.png)

### 一、配置域名

#### 1. 前端绑定域名

在上方的搜索栏搜索`域名解析` -> 点击 DNS 解析 DNSPod

![image-20230328221648141](http://qiniu.user-center.icu/img/image-20230328221648141.png)

进入到 DNSPod，会看到你购买的域名

![image-20230328221731475](http://qiniu.user-center.icu/img/image-20230328221731475.png)

点击解析，添加域名的解析记录，点击`添加记录`添加一条想要使用的域名地址

![image-20230328221843959](http://qiniu.user-center.icu/img/image-20230328221843959.png)

![image-20230328221856452](http://qiniu.user-center.icu/img/image-20230328221856452.png)

![image-20230328221908130](http://qiniu.user-center.icu/img/image-20230328221908130.png)

填写`域名前缀`和`公网ip`，类型默认选 A 就行了，点击类型，下面会有提示，然后点击 `保存`

![image-20230328222045673](http://qiniu.user-center.icu/img/image-20230328222045673.png)

![image-20230328222104157](http://qiniu.user-center.icu/img/image-20230328222104157.png)

#### 2. 域名解析的流程

> 前端项目访问：用户输入网址 => 域名解析服务器（把网址解析为 ip 地址 / 交给其他的域名解析服务）=> 服务器 => （防火墙）=> nginx 接收请求，找到对应的文件，返回文件给前端 => 前端加载文件到浏览器中（js、css）=> 渲染页面
>
> 后端项目访问：用户输入网址 => 域名解析服务器 => 服务器 => nginx 接收请求 => 后端项目（比如 8080 端口）

访问一下 http://user-backend.user-center.icu/

![image-20230328223431873](http://qiniu.user-center.icu/img/image-20230328223431873.png)

因为我们用的是宝塔，我们之前指定前端项目是用 ip 地址访问的，得修改一下，添加上域名

![image-20230328231857228](http://qiniu.user-center.icu/img/image-20230328231857228.png)

#### 3. 后端绑定域名

![image-20230328233950021](http://qiniu.user-center.icu/img/image-20230328233950021.png)

这样很丑，难道每次我们都要让用户加个端口去访问吗？虽然说用户不可能直接调后端，但是对于开发者来说，其实加个端口号也不是那么舒服，能不能把这 个端口号去掉？

>去掉端口号，他是不是默认就访问的是80端口，80端口的请求就发到nginx，我们是不是可以让nginx接收到请求，然后再帮我们把请求转发到后端项目，可以做-个转发，转发到8080端口

配置一下，新建一个站点，来让这个新的站点接收80端口的请求，然后转发到后端项目

> 让 nginx 来转发请求，不仅可以用来转发请求，还可以改写请求去做拦截等。

![image-20230329081642292](http://qiniu.user-center.icu/img/image-20230329081642292.png)

添加反向代理

![image-20230329081739218](http://qiniu.user-center.icu/img/image-20230329081739218.png)

![image-20230329081907030](http://qiniu.user-center.icu/img/image-20230329081907030.png)

访问一下，不带端口

![image-20230329081945956](http://qiniu.user-center.icu/img/image-20230329081945956.png)

> nginx 反向代理是非常常用的一个方法。可以帮我们统一管理、接收请求，我们只需要去配置访问哪个域名、转发到哪个地址、哪个项目，或者说访问哪个域名、哪个目录的文件，只需要配置这个就行了。

### 附加：使用宝塔面板安装mysql

1. 在宝塔面板中的软件商店，下载安装 mysql，选择 5.7 版本以上

![image-20230329084332830](http://qiniu.user-center.icu/img/image-20230329084332830.png)

2. 安装完成后重置数据库管理员，放行 3306 端口

![image-20230329084647962](http://qiniu.user-center.icu/img/image-20230329084647962.png)

![image-20230329084729232](http://qiniu.user-center.icu/img/image-20230329084729232.png)

3. 使用服务器的远程连接，依照之前的 mysql 的创建再创建一个新的数据库

![image-20230329085159373](http://qiniu.user-center.icu/img/image-20230329085159373.png)

4. 使用 idea 远程连接测试一下

![image-20230329085326738](http://qiniu.user-center.icu/img/image-20230329085326738.png)

### 二、跨域问题解决

> 什么是跨域？浏览器为了用户的安全，仅允许向同域名、同端口的服务器发送请求。
>
> 我们前端的域名是 user-center.icu，后端域名是 user-backend，域名不一致就出现了跨域，跨域的话就报错 了

我们看一下网络请求，为了防止跨域，或者说为了检测跨域，浏览器会在正式发送请求之前，发送一个预检请求，预检的请求方法是 OPTIONS。

预检请求经常用来检查是否跨域，换句话说，当我们请求的域名和当前网络的域名不一致时，就会发送预检请求。

> 预检请求的作用：就是提前探路，比如说你要坐飞机，预检请求提前查看一下你这个飞机的航班有没有晚点，是不是正常运行的，如果不是正常运行的，那也不用发送下一个请求了，或者说下一个请求直接被拒绝掉

![image-20230329100521464](http://qiniu.user-center.icu/img/image-20230329100521464.png)

**如何解决跨域？（三种方式）**

1. 把域名、端口改成相同的
2. 网关支持（nginx）
3. 修改后端服务

**第一种方式：**

由于前端已经写死了，一般情况下就不进行修改了....

**第二种方式：**

> 让服务器告诉浏览器：允许跨域（返回 cross-origin-allow 响应头）

在 nginx 配置跨域，先将之前配置的反向代理删掉

![image-20230329100829012](http://qiniu.user-center.icu/img/image-20230329100829012.png)

```nginx
# 跨域配置
location ^~ /api/ {
    proxy_pass http://127.0.0.1:8080/api/;
    add_header 'Access-Control-Allow-Origin' $http_origin;
    add_header 'Access-Control-Allow-Credentials' 'true';
    add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
    add_header Access-Control-Allow-Headers '*';
    if ($request_method = 'OPTIONS') {
        add_header 'Access-Control-Allow-Credentials' 'true';
        add_header 'Access-Control-Allow-Origin' $http_origin;
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
        add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range';
        add_header 'Access-Control-Max-Age' 1728000;
        add_header 'Content-Type' 'text/plain; charset=utf-8';
        add_header 'Content-Length' 0;
        return 204;
    }
}
```

注册一下，成功了！🥳

![image-20230329112143268](http://qiniu.user-center.icu/img/image-20230329112143268.png)

**第三种方式**：修改后端服务

1. 第一种方式：配置 `@CrossOrigin` 注解

![image-20230329112503660](http://qiniu.user-center.icu/img/image-20230329112503660.png)

2. 第二种：添加 web 全局请求拦截器

![image-20230329112613614](http://qiniu.user-center.icu/img/image-20230329112613614.png)

3. 第三种：定义新的 corsFilter Bean

[SpringBoot设置Cors跨域的四种方式 - 简书 (jianshu.com)](https://www.jianshu.com/p/b02099a435bd)

### 收尾：网站添加网站备案号

> 网站备案成功后，需要在备案成功的网站底部悬挂I信部下发的网站备案号，生成链接指向工信部网站 [ICP/IP地址/域名信息备案管理系统 (miit.gov.cn)](https://beian.miit.gov.cn/#/Integrated/index) ，提供网站访问者查询核对。
> 未在网站底部添加网站备案号，将被备案所在省通信管理局责令改正,处五千元以上一万元以下罚款。

**鲁ICP备2022034240号**

去增加一个底部链接，重新 build，在宝塔中替换掉 dist 文件

![image-20230329113724260](http://qiniu.user-center.icu/img/image-20230329113724260.png)

有显示备案号，点击后可以链接到工信部网站即可

![image-20230329114206429](http://qiniu.user-center.icu/img/image-20230329114206429.png)

![image-20230329114223733](http://qiniu.user-center.icu/img/image-20230329114223733.png)

### 三、项目优化点

1. 功能扩充
   1. 管理员创建用户、修改用户信息、删除用户
   2. 上传头像
   3. 按照更多的条件去查询用户
   4. 更改权限
2. 修改 bug
3. 项目登录改为分布式 session（单点登录 - redis）
4. 通用性
   1. set-cookie domain 域名更通用，比如改为 *.xxx.com
   2. 把用户 管理系统 => 用户中心（之后所有的服务都请求这个后端）
5. 后台添加全局请求拦截器（统一去判断用户权限，统一记录请求日志）



## 简历写法

1. 为了提高开发效率，选用 Ant Design Pro 脚手架快速搭建基础页面，并对原始模板进行瘦身、抽象为可复用的公共模板，，便于后续同类项目的快速研发。
2. 在脚手架自带的 umi-request 请求库基础上进行改造和封装，添加全局请求拦截和全局异常处理逻辑、自带根据项目启动命令来区分环境，减少重复代码、提供项目可维护性。
3. 选用 MyBatis + MyBatis-Plus 进行数据访问层开发，复用大多数通用方法，并且通过继承定制了自己的**通用模板**，大幅提升了项目开发效率。
4. 为了明确接口的返回，自定义统一的错误码，并封装了**全局异常处理器**，从而规范了异常返回、屏蔽了项目冗余的报错细节。
5. 对于项目中的 JSON 格式化处理对象，采用了**双检索单例模式**进行管理，从而复用对象，避免了重复创建对象的开销，便于集中维护管理。
   1. 采用 Nginx 完成前端项目部署、采用 Docker 容器完成后端项目部署，并且使用宝塔面板对项目进行运维监控。

